/*
Copyright (C) 1999-2011 Marben Products. All rights reserved.

THIS FILE IS PROPRIETARY MATERIAL OF MARBEN PRODUCTS.
AND MAY BE USED ONLY BY DIRECT LICENSEES OF ASNSDK PRODUCT.
THIS FILE MAY NOT BE DISTRIBUTED.

===========================================================================

VDSasncopy.cc: C++ API copy constructor methods

Generated by ASNSDK TCE-C++ ASN.1 Compiler v6.0 - REF_8.55 - REF_8.41

===========================================================================
*/

/**@file
 * C++ API copy constructor methods
 */

#include <VDSasn.h>

namespace asn_wrapper
{
#ifdef asnCodCopytor
/**
 *    TypeAssignment : RequestBody
 *    Class constructor
 */
RequestBody::RequestBody(const RequestBody& object)
  : asntype()  ,optional(object.optional.length, optionalField)
  ,serviceId()
  ,serviceData()
  ,seq()

{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : RequestBody
 * Copy method
 */
void RequestBody::__copy (const asntype& obj)
{
  const RequestBody* object = asnSCast(const RequestBody*,&obj);
  optionalField[0] = object->optionalField[0];
 {
    if(asnGetPresence(object->optionalField,asn_serviceId) != asnFALSE)
    {
      serviceId = object->serviceId;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_serviceData) != asnFALSE)
    {
      if(object->serviceData != (ServiceData *)asnBNULL)
      {
        serviceData = (ServiceData*)object->serviceData->__create();
        serviceData->__copy(*object->serviceData);
      }
      else
      {
        serviceData = (ServiceData *) 0;
      }
    }
    else
    {
      this->serviceData = (ServiceData*) asnBNULL;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_seq) != asnFALSE)
    {
      seq = object->seq;
    }
 }
}

/**
 *    TypeAssignment : asncServiceData__serviceParameterss
 *    Class constructor
 */
asncServiceData__serviceParameterss::asncServiceData__serviceParameterss(const asncServiceData__serviceParameterss& object)
  : asnListElement()
  ,optional(object.optional.length, optionalField)
  ,key()
  ,intVal()
  ,stringVal()
  ,boolVal()
  ,timestampVal()
  ,dataVal()
{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : asncServiceData__serviceParameterss
 * Copy method
 */
void asncServiceData__serviceParameterss::__copy (const asntype& obj)
{
  const asncServiceData__serviceParameterss* object = asnSCast(const asncServiceData__serviceParameterss*,&obj);
  optionalField[0] = object->optionalField[0];
 {
    this->key.__copy (object->key);
 }
 {
    if(asnGetPresence(object->optionalField,asn_intVal) != asnFALSE)
    {
      intVal = object->intVal;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_ServiceParameter__stringVal) != asnFALSE)
    {
      this->stringVal.__copy (object->stringVal);
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_ServiceParameter__boolVal) != asnFALSE)
    {
      boolVal = object->boolVal;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_ServiceParameter__timestampVal) != asnFALSE)
    {
      if(object->timestampVal != (TimeStamp *)asnBNULL)
      {
        timestampVal = (TimeStamp*)object->timestampVal->__create();
        timestampVal->__copy(*object->timestampVal);
      }
      else
      {
        timestampVal = (TimeStamp *) 0;
      }
    }
    else
    {
      this->timestampVal = (TimeStamp*) asnBNULL;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_ServiceParameter__dataVal) != asnFALSE)
    {
      this->dataVal.__copy(object->dataVal);
    }
 }
}

/**
 *    TypeAssignment : asncattributess
 *    Class constructor
 */
asncattributess::asncattributess(const asncattributess& object)
  : asnListElement()
  ,optional(object.optional.length, optionalField)
  ,key()
  ,intVal()
  ,stringVal()
  ,boolVal()
  ,timestampVal()
  ,dataVal()
{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : asncattributess
 * Copy method
 */
void asncattributess::__copy (const asntype& obj)
{
  const asncattributess* object = asnSCast(const asncattributess*,&obj);
  optionalField[0] = object->optionalField[0];
 {
    this->key.__copy (object->key);
 }
 {
    if(asnGetPresence(object->optionalField,asn_intVal) != asnFALSE)
    {
      intVal = object->intVal;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_ServiceParameter__stringVal) != asnFALSE)
    {
      this->stringVal.__copy (object->stringVal);
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_ServiceParameter__boolVal) != asnFALSE)
    {
      boolVal = object->boolVal;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_ServiceParameter__timestampVal) != asnFALSE)
    {
      if(object->timestampVal != (TimeStamp *)asnBNULL)
      {
        timestampVal = (TimeStamp*)object->timestampVal->__create();
        timestampVal->__copy(*object->timestampVal);
      }
      else
      {
        timestampVal = (TimeStamp *) 0;
      }
    }
    else
    {
      this->timestampVal = (TimeStamp*) asnBNULL;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_ServiceParameter__dataVal) != asnFALSE)
    {
      this->dataVal.__copy(object->dataVal);
    }
 }
}

/**
 *    TypeAssignment : asncpoiss
 *    Class constructor
 */
asncpoiss::asncpoiss(const asncpoiss& object)
  : asnListElement()
  ,optional(object.optional.length, optionalField)
  ,name()
  ,position()
  ,type()
  ,contactInfo()
  ,url()
  ,attributes()
{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : asncpoiss
 * Copy method
 */
void asncpoiss::__copy (const asntype& obj)
{
  const asncpoiss* object = asnSCast(const asncpoiss*,&obj);
  optionalField[0] = object->optionalField[0];
 {
    this->name.__copy (object->name);
 }
 {
    if(asnGetPresence(object->optionalField,asn_PointOfInterest__position) != asnFALSE)
    {
      if(object->position != (Position *)asnBNULL)
      {
        position = (Position*)object->position->__create();
        position->__copy(*object->position);
      }
      else
      {
        position = (Position *) 0;
      }
    }
    else
    {
      this->position = (Position*) asnBNULL;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_type) != asnFALSE)
    {
      this->type.__copy (object->type);
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_contactInfo) != asnFALSE)
    {
      if(object->contactInfo != (ContactInfo *)asnBNULL)
      {
        contactInfo = (ContactInfo*)object->contactInfo->__create();
        contactInfo->__copy(*object->contactInfo);
      }
      else
      {
        contactInfo = (ContactInfo *) 0;
      }
    }
    else
    {
      this->contactInfo = (ContactInfo*) asnBNULL;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_url) != asnFALSE)
    {
      this->url.__copy (object->url);
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_attributes) != asnFALSE)
    {
      asncattributess *elt_asncattributess;
      elt_asncattributess = (asncattributess*) object->attributes.firstElement;
      for (asnMAXUINT countattributes=0; countattributes<object->attributes.count; countattributes++)
      {
        attributes.addElement(new asncattributess(*elt_asncattributess));
        elt_asncattributess = (asncattributess*) elt_asncattributess->nextElement;
      }
    }
 }
}

/**
 *    TypeAssignment : asncConfigurationItem__parameterss
 *    Class constructor
 */
asncConfigurationItem__parameterss::asncConfigurationItem__parameterss(const asncConfigurationItem__parameterss& object)
  : asnListElement()
  ,optional(object.optional.length, optionalField)
  ,key()
  ,intVal()
  ,stringVal()
  ,boolVal()
  ,timestampVal()
  ,dataVal()
{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : asncConfigurationItem__parameterss
 * Copy method
 */
void asncConfigurationItem__parameterss::__copy (const asntype& obj)
{
  const asncConfigurationItem__parameterss* object = asnSCast(const asncConfigurationItem__parameterss*,&obj);
  optionalField[0] = object->optionalField[0];
 {
    this->key.__copy (object->key);
 }
 {
    if(asnGetPresence(object->optionalField,asn_intVal) != asnFALSE)
    {
      intVal = object->intVal;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_ServiceParameter__stringVal) != asnFALSE)
    {
      this->stringVal.__copy (object->stringVal);
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_ServiceParameter__boolVal) != asnFALSE)
    {
      boolVal = object->boolVal;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_ServiceParameter__timestampVal) != asnFALSE)
    {
      if(object->timestampVal != (TimeStamp *)asnBNULL)
      {
        timestampVal = (TimeStamp*)object->timestampVal->__create();
        timestampVal->__copy(*object->timestampVal);
      }
      else
      {
        timestampVal = (TimeStamp *) 0;
      }
    }
    else
    {
      this->timestampVal = (TimeStamp*) asnBNULL;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_ServiceParameter__dataVal) != asnFALSE)
    {
      this->dataVal.__copy(object->dataVal);
    }
 }
}

/**
 *    TypeAssignment : asncConfiguration__itemss
 *    Class constructor
 */
asncConfiguration__itemss::asncConfiguration__itemss(const asncConfiguration__itemss& object)
  : asnListElement()
  ,name()
  ,parameters()
{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : asncConfiguration__itemss
 * Copy method
 */
void asncConfiguration__itemss::__copy (const asntype& obj)
{
  const asncConfiguration__itemss* object = asnSCast(const asncConfiguration__itemss*,&obj);
 {
    this->name.__copy (object->name);
 }
 {
    asncConfigurationItem__parameterss *elt_asncConfigurationItem__parameterss;
    elt_asncConfigurationItem__parameterss = (asncConfigurationItem__parameterss*) object->parameters.firstElement;
    for (asnMAXUINT countparameters=0; countparameters<object->parameters.count; countparameters++)
    {
      parameters.addElement(new asncConfigurationItem__parameterss(*elt_asncConfigurationItem__parameterss));
      elt_asncConfigurationItem__parameterss = (asncConfigurationItem__parameterss*) elt_asncConfigurationItem__parameterss->nextElement;
    }
 }
}

/**
 *    TypeAssignment : asncFragStrs__itemss
 *    Class constructor
 */
asncFragStrs__itemss::asncFragStrs__itemss(const asncFragStrs__itemss& object)
  : asnListElement()
  ,optional(object.optional.length, optionalField)
  ,id()
  ,activated()
  ,level()
  ,code()
{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : asncFragStrs__itemss
 * Copy method
 */
void asncFragStrs__itemss::__copy (const asntype& obj)
{
  const asncFragStrs__itemss* object = asnSCast(const asncFragStrs__itemss*,&obj);
  optionalField[0] = object->optionalField[0];
 {
    id = object->id;
 }
 {
    activated = object->activated;
 }
 {
    if(asnGetPresence(object->optionalField,asn_level) != asnFALSE)
    {
      level = object->level;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_FragItem__code) != asnFALSE)
    {
      this->code.__copy (object->code);
    }
 }
}

/**
 *    TypeAssignment : asncdtcss
 *    Class constructor
 */
asncdtcss::asncdtcss(const asncdtcss& object)
  : asnListElement()
  ,optional(object.optional.length, optionalField)
  ,dtc()
  ,status()
  ,failureCount()
  ,lastFail()
  ,firtFail()
  ,firstFailureOdometer()
  ,firstFailureBatteryVoltage()
  ,firstFailureVehicleSpeed()
{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : asncdtcss
 * Copy method
 */
void asncdtcss::__copy (const asntype& obj)
{
  const asncdtcss* object = asnSCast(const asncdtcss*,&obj);
  optionalField[0] = object->optionalField[0];
 {
    this->dtc.__copy (object->dtc);
 }
 {
    this->status.__copy(object->status);
 }
 {
    if(asnGetPresence(object->optionalField,asn_failureCount) != asnFALSE)
    {
      failureCount = object->failureCount;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_lastFail) != asnFALSE)
    {
      if(object->lastFail != (TimeStamp *)asnBNULL)
      {
        lastFail = (TimeStamp*)object->lastFail->__create();
        lastFail->__copy(*object->lastFail);
      }
      else
      {
        lastFail = (TimeStamp *) 0;
      }
    }
    else
    {
      this->lastFail = (TimeStamp*) asnBNULL;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_firtFail) != asnFALSE)
    {
      if(object->firtFail != (TimeStamp *)asnBNULL)
      {
        firtFail = (TimeStamp*)object->firtFail->__create();
        firtFail->__copy(*object->firtFail);
      }
      else
      {
        firtFail = (TimeStamp *) 0;
      }
    }
    else
    {
      this->firtFail = (TimeStamp*) asnBNULL;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_firstFailureOdometer) != asnFALSE)
    {
      firstFailureOdometer = object->firstFailureOdometer;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_firstFailureBatteryVoltage) != asnFALSE)
    {
      firstFailureBatteryVoltage = object->firstFailureBatteryVoltage;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_firstFailureVehicleSpeed) != asnFALSE)
    {
      firstFailureVehicleSpeed = object->firstFailureVehicleSpeed;
    }
 }
}

/**
 *    TypeAssignment : asncconnectEstablishedLists
 *    Class constructor
 */
asncconnectEstablishedLists::asncconnectEstablishedLists(const asncconnectEstablishedLists& object)
  : asnListElement()
  ,optional(object.optional.length, optionalField)
  ,connectTime()
  ,connectPosition()
  ,connectType()
  ,numRetriesConnect()
  ,retryReason()
{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : asncconnectEstablishedLists
 * Copy method
 */
void asncconnectEstablishedLists::__copy (const asntype& obj)
{
  const asncconnectEstablishedLists* object = asnSCast(const asncconnectEstablishedLists*,&obj);
  optionalField[0] = object->optionalField[0];
 {
    if(asnGetPresence(object->optionalField,asn_ConnectivityInfo__connectTime) != asnFALSE)
    {
      if(object->connectTime != (TimeStamp *)asnBNULL)
      {
        connectTime = (TimeStamp*)object->connectTime->__create();
        connectTime->__copy(*object->connectTime);
      }
      else
      {
        connectTime = (TimeStamp *) 0;
      }
    }
    else
    {
      this->connectTime = (TimeStamp*) asnBNULL;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_ConnectivityInfo__connectPosition) != asnFALSE)
    {
      if(object->connectPosition != (Position *)asnBNULL)
      {
        connectPosition = (Position*)object->connectPosition->__create();
        connectPosition->__copy(*object->connectPosition);
      }
      else
      {
        connectPosition = (Position *) 0;
      }
    }
    else
    {
      this->connectPosition = (Position*) asnBNULL;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_ConnectivityInfo__connectType) != asnFALSE)
    {
      this->connectType.__copy (object->connectType);
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_ConnectivityInfo__numRetriesConnect) != asnFALSE)
    {
      numRetriesConnect = object->numRetriesConnect;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_retryReason) != asnFALSE)
    {
      this->retryReason.__copy (object->retryReason);
    }
 }
}

/**
 *    TypeAssignment : asnclostConnectionsLists
 *    Class constructor
 */
asnclostConnectionsLists::asnclostConnectionsLists(const asnclostConnectionsLists& object)
  : asnListElement()
  ,optional(object.optional.length, optionalField)
  ,connectTime()
  ,connectPosition()
  ,connectType()
  ,numRetriesConnect()
  ,retryReason()
{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : asnclostConnectionsLists
 * Copy method
 */
void asnclostConnectionsLists::__copy (const asntype& obj)
{
  const asnclostConnectionsLists* object = asnSCast(const asnclostConnectionsLists*,&obj);
  optionalField[0] = object->optionalField[0];
 {
    if(asnGetPresence(object->optionalField,asn_ConnectivityInfo__connectTime) != asnFALSE)
    {
      if(object->connectTime != (TimeStamp *)asnBNULL)
      {
        connectTime = (TimeStamp*)object->connectTime->__create();
        connectTime->__copy(*object->connectTime);
      }
      else
      {
        connectTime = (TimeStamp *) 0;
      }
    }
    else
    {
      this->connectTime = (TimeStamp*) asnBNULL;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_ConnectivityInfo__connectPosition) != asnFALSE)
    {
      if(object->connectPosition != (Position *)asnBNULL)
      {
        connectPosition = (Position*)object->connectPosition->__create();
        connectPosition->__copy(*object->connectPosition);
      }
      else
      {
        connectPosition = (Position *) 0;
      }
    }
    else
    {
      this->connectPosition = (Position*) asnBNULL;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_ConnectivityInfo__connectType) != asnFALSE)
    {
      this->connectType.__copy (object->connectType);
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_ConnectivityInfo__numRetriesConnect) != asnFALSE)
    {
      numRetriesConnect = object->numRetriesConnect;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_retryReason) != asnFALSE)
    {
      this->retryReason.__copy (object->retryReason);
    }
 }
}

/**
 *    TypeAssignment : asncCarConfig__itemss
 *    Class constructor
 */
asncCarConfig__itemss::asncCarConfig__itemss(const asncCarConfig__itemss& object)
  : asnListElement()
  ,optional(object.optional.length, optionalField)
  ,key()
  ,intVal()
  ,stringVal()
  ,boolVal()
  ,timestampVal()
  ,dataVal()
{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : asncCarConfig__itemss
 * Copy method
 */
void asncCarConfig__itemss::__copy (const asntype& obj)
{
  const asncCarConfig__itemss* object = asnSCast(const asncCarConfig__itemss*,&obj);
  optionalField[0] = object->optionalField[0];
 {
    this->key.__copy (object->key);
 }
 {
    if(asnGetPresence(object->optionalField,asn_intVal) != asnFALSE)
    {
      intVal = object->intVal;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_ServiceParameter__stringVal) != asnFALSE)
    {
      this->stringVal.__copy (object->stringVal);
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_ServiceParameter__boolVal) != asnFALSE)
    {
      boolVal = object->boolVal;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_ServiceParameter__timestampVal) != asnFALSE)
    {
      if(object->timestampVal != (TimeStamp *)asnBNULL)
      {
        timestampVal = (TimeStamp*)object->timestampVal->__create();
        timestampVal->__copy(*object->timestampVal);
      }
      else
      {
        timestampVal = (TimeStamp *) 0;
      }
    }
    else
    {
      this->timestampVal = (TimeStamp*) asnBNULL;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_ServiceParameter__dataVal) != asnFALSE)
    {
      this->dataVal.__copy(object->dataVal);
    }
 }
}

/**
 *    TypeAssignment : asncAdditionalStatus__signalss
 *    Class constructor
 */
asncAdditionalStatus__signalss::asncAdditionalStatus__signalss(const asncAdditionalStatus__signalss& object)
  : asnListElement()
  ,optional(object.optional.length, optionalField)
  ,key()
  ,collectTime()
  ,value()
  ,stringVal()
  ,boolVal()
  ,timestampVal()
  ,dataVal()
{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : asncAdditionalStatus__signalss
 * Copy method
 */
void asncAdditionalStatus__signalss::__copy (const asntype& obj)
{
  const asncAdditionalStatus__signalss* object = asnSCast(const asncAdditionalStatus__signalss*,&obj);
  optionalField[0] = object->optionalField[0];
 {
    this->key.__copy (object->key);
 }
 {
    if(asnGetPresence(object->optionalField,asn_collectTime) != asnFALSE)
    {
      if(object->collectTime != (TimeStamp *)asnBNULL)
      {
        collectTime = (TimeStamp*)object->collectTime->__create();
        collectTime->__copy(*object->collectTime);
      }
      else
      {
        collectTime = (TimeStamp *) 0;
      }
    }
    else
    {
      this->collectTime = (TimeStamp*) asnBNULL;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_value) != asnFALSE)
    {
      value = object->value;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_GenericVehicleSignal__stringVal) != asnFALSE)
    {
      this->stringVal.__copy (object->stringVal);
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_GenericVehicleSignal__boolVal) != asnFALSE)
    {
      boolVal = object->boolVal;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_GenericVehicleSignal__timestampVal) != asnFALSE)
    {
      if(object->timestampVal != (TimeStamp *)asnBNULL)
      {
        timestampVal = (TimeStamp*)object->timestampVal->__create();
        timestampVal->__copy(*object->timestampVal);
      }
      else
      {
        timestampVal = (TimeStamp *) 0;
      }
    }
    else
    {
      this->timestampVal = (TimeStamp*) asnBNULL;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_GenericVehicleSignal__dataVal) != asnFALSE)
    {
      this->dataVal.__copy(object->dataVal);
    }
 }
}

/**
 *    TypeAssignment : asncrecentPositionss
 *    Class constructor
 */
asncrecentPositionss::asncrecentPositionss(const asncrecentPositionss& object)
  : asnListElement()
  ,optional(object.optional.length, optionalField)
  ,latitude()
  ,longitude()
  ,altitude()
  ,posCanBeTrusted()
  ,carLocatorStatUploadEn()
  ,marsCoordinates()
{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : asncrecentPositionss
 * Copy method
 */
void asncrecentPositionss::__copy (const asntype& obj)
{
  const asncrecentPositionss* object = asnSCast(const asncrecentPositionss*,&obj);
  optionalField[0] = object->optionalField[0];
 {
    if(asnGetPresence(object->optionalField,asn_latitude) != asnFALSE)
    {
      latitude = object->latitude;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_longitude) != asnFALSE)
    {
      longitude = object->longitude;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_altitude) != asnFALSE)
    {
      altitude = object->altitude;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_posCanBeTrusted) != asnFALSE)
    {
      posCanBeTrusted = object->posCanBeTrusted;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_carLocatorStatUploadEn) != asnFALSE)
    {
      carLocatorStatUploadEn = object->carLocatorStatUploadEn;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_marsCoordinates) != asnFALSE)
    {
      marsCoordinates = object->marsCoordinates;
    }
 }
}

/**
 *    TypeAssignment : asncOEMMSD__signalss
 *    Class constructor
 */
asncOEMMSD__signalss::asncOEMMSD__signalss(const asncOEMMSD__signalss& object)
  : asnListElement()
  ,optional(object.optional.length, optionalField)
  ,key()
  ,collectTime()
  ,value()
  ,stringVal()
  ,boolVal()
  ,timestampVal()
  ,dataVal()
{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : asncOEMMSD__signalss
 * Copy method
 */
void asncOEMMSD__signalss::__copy (const asntype& obj)
{
  const asncOEMMSD__signalss* object = asnSCast(const asncOEMMSD__signalss*,&obj);
  optionalField[0] = object->optionalField[0];
 {
    this->key.__copy (object->key);
 }
 {
    if(asnGetPresence(object->optionalField,asn_collectTime) != asnFALSE)
    {
      if(object->collectTime != (TimeStamp *)asnBNULL)
      {
        collectTime = (TimeStamp*)object->collectTime->__create();
        collectTime->__copy(*object->collectTime);
      }
      else
      {
        collectTime = (TimeStamp *) 0;
      }
    }
    else
    {
      this->collectTime = (TimeStamp*) asnBNULL;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_value) != asnFALSE)
    {
      value = object->value;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_GenericVehicleSignal__stringVal) != asnFALSE)
    {
      this->stringVal.__copy (object->stringVal);
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_GenericVehicleSignal__boolVal) != asnFALSE)
    {
      boolVal = object->boolVal;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_GenericVehicleSignal__timestampVal) != asnFALSE)
    {
      if(object->timestampVal != (TimeStamp *)asnBNULL)
      {
        timestampVal = (TimeStamp*)object->timestampVal->__create();
        timestampVal->__copy(*object->timestampVal);
      }
      else
      {
        timestampVal = (TimeStamp *) 0;
      }
    }
    else
    {
      this->timestampVal = (TimeStamp*) asnBNULL;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_GenericVehicleSignal__dataVal) != asnFALSE)
    {
      this->dataVal.__copy(object->dataVal);
    }
 }
}

/**
 *    TypeAssignment : asncNotification__parameterss
 *    Class constructor
 */
asncNotification__parameterss::asncNotification__parameterss(const asncNotification__parameterss& object)
  : asnListElement()
  ,optional(object.optional.length, optionalField)
  ,key()
  ,intVal()
  ,stringVal()
  ,boolVal()
  ,timestampVal()
  ,dataVal()
{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : asncNotification__parameterss
 * Copy method
 */
void asncNotification__parameterss::__copy (const asntype& obj)
{
  const asncNotification__parameterss* object = asnSCast(const asncNotification__parameterss*,&obj);
  optionalField[0] = object->optionalField[0];
 {
    this->key.__copy (object->key);
 }
 {
    if(asnGetPresence(object->optionalField,asn_intVal) != asnFALSE)
    {
      intVal = object->intVal;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_ServiceParameter__stringVal) != asnFALSE)
    {
      this->stringVal.__copy (object->stringVal);
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_ServiceParameter__boolVal) != asnFALSE)
    {
      boolVal = object->boolVal;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_ServiceParameter__timestampVal) != asnFALSE)
    {
      if(object->timestampVal != (TimeStamp *)asnBNULL)
      {
        timestampVal = (TimeStamp*)object->timestampVal->__create();
        timestampVal->__copy(*object->timestampVal);
      }
      else
      {
        timestampVal = (TimeStamp *) 0;
      }
    }
    else
    {
      this->timestampVal = (TimeStamp*) asnBNULL;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_ServiceParameter__dataVal) != asnFALSE)
    {
      this->dataVal.__copy(object->dataVal);
    }
 }
}

/**
 *    TypeAssignment : asncpartIdentifierss
 *    Class constructor
 */
asncpartIdentifierss::asncpartIdentifierss(const asncpartIdentifierss& object)
  : asnListElement()
  ,value()
{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : asncpartIdentifierss
 * Copy method
 */
void asncpartIdentifierss::__copy (const asntype& obj)
{
  const asncpartIdentifierss* object = asnSCast(const asncpartIdentifierss*,&obj);
  this->value.__copy(object->value);
}

/**
 *    TypeAssignment : asncvalidationKeyss
 *    Class constructor
 */
asncvalidationKeyss::asncvalidationKeyss(const asncvalidationKeyss& object)
  : asnListElement()
  ,optional(object.optional.length, optionalField)
  ,validationKey()
  ,partIdentifiers()
{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : asncvalidationKeyss
 * Copy method
 */
void asncvalidationKeyss::__copy (const asntype& obj)
{
  const asncvalidationKeyss* object = asnSCast(const asncvalidationKeyss*,&obj);
  optionalField[0] = object->optionalField[0];
 {
    this->validationKey.__copy (object->validationKey);
 }
 {
    if(asnGetPresence(object->optionalField,asn_partIdentifiers) != asnFALSE)
    {
      asncpartIdentifierss *elt_asncpartIdentifierss;
      elt_asncpartIdentifierss = (asncpartIdentifierss*) object->partIdentifiers.firstElement;
      for (asnMAXUINT countpartIdentifiers=0; countpartIdentifiers<object->partIdentifiers.count; countpartIdentifiers++)
      {
        partIdentifiers.addElement(new asncpartIdentifierss(*elt_asncpartIdentifierss));
        elt_asncpartIdentifierss = (asncpartIdentifierss*) elt_asncpartIdentifierss->nextElement;
      }
    }
 }
}

/**
 *    TypeAssignment : asncecuInventorys
 *    Class constructor
 */
asncecuInventorys::asncecuInventorys(const asncecuInventorys& object)
  : asnListElement()
  ,optional(object.optional.length, optionalField)
  ,ecuAddress()
  ,validationKeys()
  ,exceptionMessage()
{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : asncecuInventorys
 * Copy method
 */
void asncecuInventorys::__copy (const asntype& obj)
{
  const asncecuInventorys* object = asnSCast(const asncecuInventorys*,&obj);
  optionalField[0] = object->optionalField[0];
 {
    this->ecuAddress.__copy (object->ecuAddress);
 }
 {
    asncvalidationKeyss *elt_asncvalidationKeyss;
    elt_asncvalidationKeyss = (asncvalidationKeyss*) object->validationKeys.firstElement;
    for (asnMAXUINT countvalidationKeys=0; countvalidationKeys<object->validationKeys.count; countvalidationKeys++)
    {
      validationKeys.addElement(new asncvalidationKeyss(*elt_asncvalidationKeyss));
      elt_asncvalidationKeyss = (asncvalidationKeyss*) elt_asncvalidationKeyss->nextElement;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_exceptionMessage) != asnFALSE)
    {
      this->exceptionMessage.__copy (object->exceptionMessage);
    }
 }
}

/**
 *    TypeAssignment : asncInventoryInstruction__ecuInstructionss
 *    Class constructor
 */
asncInventoryInstruction__ecuInstructionss::asncInventoryInstruction__ecuInstructionss(const asncInventoryInstruction__ecuInstructionss& object)
  : asnListElement()
  ,optional(object.optional.length, optionalField)
  ,ecuAddress()
  ,validationKeys()
  ,exceptionMessage()
{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : asncInventoryInstruction__ecuInstructionss
 * Copy method
 */
void asncInventoryInstruction__ecuInstructionss::__copy (const asntype& obj)
{
  const asncInventoryInstruction__ecuInstructionss* object = asnSCast(const asncInventoryInstruction__ecuInstructionss*,&obj);
  optionalField[0] = object->optionalField[0];
 {
    this->ecuAddress.__copy (object->ecuAddress);
 }
 {
    asncvalidationKeyss *elt_asncvalidationKeyss;
    elt_asncvalidationKeyss = (asncvalidationKeyss*) object->validationKeys.firstElement;
    for (asnMAXUINT countvalidationKeys=0; countvalidationKeys<object->validationKeys.count; countvalidationKeys++)
    {
      validationKeys.addElement(new asncvalidationKeyss(*elt_asncvalidationKeyss));
      elt_asncvalidationKeyss = (asncvalidationKeyss*) elt_asncvalidationKeyss->nextElement;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_exceptionMessage) != asnFALSE)
    {
      this->exceptionMessage.__copy (object->exceptionMessage);
    }
 }
}

/**
 *    TypeAssignment : asncsoftwarePartInstallationInstructionss
 *    Class constructor
 */
asncsoftwarePartInstallationInstructionss::asncsoftwarePartInstallationInstructionss(const asncsoftwarePartInstallationInstructionss& object)
  : asnListElement()
  ,partidentifier()
  ,estimatedInstallationtime()
{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : asncsoftwarePartInstallationInstructionss
 * Copy method
 */
void asncsoftwarePartInstallationInstructionss::__copy (const asntype& obj)
{
  const asncsoftwarePartInstallationInstructionss* object = asnSCast(const asncsoftwarePartInstallationInstructionss*,&obj);
 {
    this->partidentifier.__copy (object->partidentifier);
 }
 {
    estimatedInstallationtime = object->estimatedInstallationtime;
 }
}

/**
 *    TypeAssignment : asncInstruction__ecuInstructionss
 *    Class constructor
 */
asncInstruction__ecuInstructionss::asncInstruction__ecuInstructionss(const asncInstruction__ecuInstructionss& object)
  : asnListElement()
  ,ecuAddress()
  ,queuedRequest()
  ,securityKey()
  ,softwarePartInstallationInstructions()
{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : asncInstruction__ecuInstructionss
 * Copy method
 */
void asncInstruction__ecuInstructionss::__copy (const asntype& obj)
{
  const asncInstruction__ecuInstructionss* object = asnSCast(const asncInstruction__ecuInstructionss*,&obj);
 {
    this->ecuAddress.__copy (object->ecuAddress);
 }
 {
    queuedRequest = object->queuedRequest;
 }
 {
    this->securityKey.__copy (object->securityKey);
 }
 {
    asncsoftwarePartInstallationInstructionss *elt_asncsoftwarePartInstallationInstructionss;
    elt_asncsoftwarePartInstallationInstructionss = (asncsoftwarePartInstallationInstructionss*) object->softwarePartInstallationInstructions.firstElement;
    for (asnMAXUINT countsoftwarePartInstallationInstructions=0; countsoftwarePartInstallationInstructions<object->softwarePartInstallationInstructions.count; countsoftwarePartInstallationInstructions++)
    {
      softwarePartInstallationInstructions.addElement(new asncsoftwarePartInstallationInstructionss(*elt_asncsoftwarePartInstallationInstructionss));
      elt_asncsoftwarePartInstallationInstructionss = (asncsoftwarePartInstallationInstructionss*) elt_asncsoftwarePartInstallationInstructionss->nextElement;
    }
 }
}

/**
 *    TypeAssignment : asncpartidentifierss
 *    Class constructor
 */
asncpartidentifierss::asncpartidentifierss(const asncpartidentifierss& object)
  : asnListElement()
  ,value()
{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : asncpartidentifierss
 * Copy method
 */
void asncpartidentifierss::__copy (const asntype& obj)
{
  const asncpartidentifierss* object = asnSCast(const asncpartidentifierss*,&obj);
  this->value.__copy(object->value);
}

/**
 *    TypeAssignment : asncassignmentValidationss
 *    Class constructor
 */
asncassignmentValidationss::asncassignmentValidationss(const asncassignmentValidationss& object)
  : asnListElement()
  ,validationType()
  ,ecuAddress()
  ,validationkey()
  ,partidentifiers()
{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : asncassignmentValidationss
 * Copy method
 */
void asncassignmentValidationss::__copy (const asntype& obj)
{
  const asncassignmentValidationss* object = asnSCast(const asncassignmentValidationss*,&obj);
 {
    this->validationType.__copy (object->validationType);
 }
 {
    this->ecuAddress.__copy (object->ecuAddress);
 }
 {
    this->validationkey.__copy (object->validationkey);
 }
 {
    asncpartidentifierss *elt_asncpartidentifierss;
    elt_asncpartidentifierss = (asncpartidentifierss*) object->partidentifiers.firstElement;
    for (asnMAXUINT countpartidentifiers=0; countpartidentifiers<object->partidentifiers.count; countpartidentifiers++)
    {
      partidentifiers.addElement(new asncpartidentifierss(*elt_asncpartidentifierss));
      elt_asncpartidentifierss = (asncpartidentifierss*) elt_asncpartidentifierss->nextElement;
    }
 }
}

/**
 *    TypeAssignment : asncinstructionss
 *    Class constructor
 */
asncinstructionss::asncinstructionss(const asncinstructionss& object)
  : asnListElement()
  ,ecuRemaining()
  ,installationInstructionSversion()
  ,requiredPreparationTime()
  ,expectedInstallationTime()
  ,area1112SecurityCode()
  ,ecuInstructions()
  ,assignmentValidations()
{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : asncinstructionss
 * Copy method
 */
void asncinstructionss::__copy (const asntype& obj)
{
  const asncinstructionss* object = asnSCast(const asncinstructionss*,&obj);
 {
    ecuRemaining = object->ecuRemaining;
 }
 {
    this->installationInstructionSversion.__copy (object->installationInstructionSversion);
 }
 {
    requiredPreparationTime = object->requiredPreparationTime;
 }
 {
    expectedInstallationTime = object->expectedInstallationTime;
 }
 {
    this->area1112SecurityCode.__copy (object->area1112SecurityCode);
 }
 {
    asncInstruction__ecuInstructionss *elt_asncInstruction__ecuInstructionss;
    elt_asncInstruction__ecuInstructionss = (asncInstruction__ecuInstructionss*) object->ecuInstructions.firstElement;
    for (asnMAXUINT countecuInstructions=0; countecuInstructions<object->ecuInstructions.count; countecuInstructions++)
    {
      ecuInstructions.addElement(new asncInstruction__ecuInstructionss(*elt_asncInstruction__ecuInstructionss));
      elt_asncInstruction__ecuInstructionss = (asncInstruction__ecuInstructionss*) elt_asncInstruction__ecuInstructionss->nextElement;
    }
 }
 {
    asncassignmentValidationss *elt_asncassignmentValidationss;
    elt_asncassignmentValidationss = (asncassignmentValidationss*) object->assignmentValidations.firstElement;
    for (asnMAXUINT countassignmentValidations=0; countassignmentValidations<object->assignmentValidations.count; countassignmentValidations++)
    {
      assignmentValidations.addElement(new asncassignmentValidationss(*elt_asncassignmentValidationss));
      elt_asncassignmentValidationss = (asncassignmentValidationss*) elt_asncassignmentValidationss->nextElement;
    }
 }
}

/**
 *    TypeAssignment : asncsoftwarePartSummaryss
 *    Class constructor
 */
asncsoftwarePartSummaryss::asncsoftwarePartSummaryss(const asncsoftwarePartSummaryss& object)
  : asnListElement()
  ,partIdentifier()
  ,partRetries()
  ,measuredInstallationTime()
  ,softwarePartStatus()
{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : asncsoftwarePartSummaryss
 * Copy method
 */
void asncsoftwarePartSummaryss::__copy (const asntype& obj)
{
  const asncsoftwarePartSummaryss* object = asnSCast(const asncsoftwarePartSummaryss*,&obj);
 {
    this->partIdentifier.__copy (object->partIdentifier);
 }
 {
    partRetries = object->partRetries;
 }
 {
    measuredInstallationTime = object->measuredInstallationTime;
 }
 {
    this->softwarePartStatus.__copy (object->softwarePartStatus);
 }
}

/**
 *    TypeAssignment : asncecuSummaryss
 *    Class constructor
 */
asncecuSummaryss::asncecuSummaryss(const asncecuSummaryss& object)
  : asnListElement()
  ,ecuAddress()
  ,ecuRetries()
  ,ecuStatus()
  ,softwarePartSummarys()
{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : asncecuSummaryss
 * Copy method
 */
void asncecuSummaryss::__copy (const asntype& obj)
{
  const asncecuSummaryss* object = asnSCast(const asncecuSummaryss*,&obj);
 {
    this->ecuAddress.__copy (object->ecuAddress);
 }
 {
    ecuRetries = object->ecuRetries;
 }
 {
    this->ecuStatus.__copy (object->ecuStatus);
 }
 {
    asncsoftwarePartSummaryss *elt_asncsoftwarePartSummaryss;
    elt_asncsoftwarePartSummaryss = (asncsoftwarePartSummaryss*) object->softwarePartSummarys.firstElement;
    for (asnMAXUINT countsoftwarePartSummarys=0; countsoftwarePartSummarys<object->softwarePartSummarys.count; countsoftwarePartSummarys++)
    {
      softwarePartSummarys.addElement(new asncsoftwarePartSummaryss(*elt_asncsoftwarePartSummaryss));
      elt_asncsoftwarePartSummaryss = (asncsoftwarePartSummaryss*) elt_asncsoftwarePartSummaryss->nextElement;
    }
 }
}

/**
 *    TypeAssignment : asncexceptionReportss
 *    Class constructor
 */
asncexceptionReportss::asncexceptionReportss(const asncexceptionReportss& object)
  : asnListElement()
  ,optional(object.optional.length, optionalField)
  ,installationOrderId()
  ,timestamp()
  ,issuerId()
  ,clientConfigurationId()
  ,dataFileName()
  ,ecuAddress()
  ,validationKey()
  ,partIdentifier()
  ,dataBlockNumber()
  ,exceptionMessage()
{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : asncexceptionReportss
 * Copy method
 */
void asncexceptionReportss::__copy (const asntype& obj)
{
  const asncexceptionReportss* object = asnSCast(const asncexceptionReportss*,&obj);
  optionalField[0] = object->optionalField[0];
 {
    if(asnGetPresence(object->optionalField,asn_ExceptionReport__installationOrderId) != asnFALSE)
    {
      this->installationOrderId.__copy (object->installationOrderId);
    }
 }
 {
    this->timestamp.__copy (object->timestamp);
 }
 {
    this->issuerId.__copy (object->issuerId);
 }
 {
    if(asnGetPresence(object->optionalField,asn_clientConfigurationId) != asnFALSE)
    {
      this->clientConfigurationId.__copy (object->clientConfigurationId);
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_dataFileName) != asnFALSE)
    {
      this->dataFileName.__copy (object->dataFileName);
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_ecuAddress) != asnFALSE)
    {
      this->ecuAddress.__copy (object->ecuAddress);
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_validationKey) != asnFALSE)
    {
      this->validationKey.__copy (object->validationKey);
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_partIdentifier) != asnFALSE)
    {
      this->partIdentifier.__copy (object->partIdentifier);
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_dataBlockNumber) != asnFALSE)
    {
      dataBlockNumber = object->dataBlockNumber;
    }
 }
 {
    if(object->exceptionMessage != (ExceptionMessage *)asnBNULL)
    {
      exceptionMessage = (ExceptionMessage*)object->exceptionMessage->__create();
      exceptionMessage->__copy(*object->exceptionMessage);
    }
    else
    {
      exceptionMessage = (ExceptionMessage *) 0;
    }
 }
}

/**
 *    TypeAssignment : asncurlss
 *    Class constructor
 */
asncurlss::asncurlss(const asncurlss& object)
  : asnListElement()
  ,value()
{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : asncurlss
 * Copy method
 */
void asncurlss::__copy (const asntype& obj)
{
  const asncurlss* object = asnSCast(const asncurlss*,&obj);
  this->value.__copy(object->value);
}

/**
 *    TypeAssignment : asncserviceParamss
 *    Class constructor
 */
asncserviceParamss::asncserviceParamss(const asncserviceParamss& object)
  : asnListElement()
  ,optional(object.optional.length, optionalField)
  ,key()
  ,intVal()
  ,stringVal()
  ,boolVal()
  ,timestampVal()
  ,dataVal()
{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : asncserviceParamss
 * Copy method
 */
void asncserviceParamss::__copy (const asntype& obj)
{
  const asncserviceParamss* object = asnSCast(const asncserviceParamss*,&obj);
  optionalField[0] = object->optionalField[0];
 {
    this->key.__copy (object->key);
 }
 {
    if(asnGetPresence(object->optionalField,asn_intVal) != asnFALSE)
    {
      intVal = object->intVal;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_ServiceParameter__stringVal) != asnFALSE)
    {
      this->stringVal.__copy (object->stringVal);
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_ServiceParameter__boolVal) != asnFALSE)
    {
      boolVal = object->boolVal;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_ServiceParameter__timestampVal) != asnFALSE)
    {
      if(object->timestampVal != (TimeStamp *)asnBNULL)
      {
        timestampVal = (TimeStamp*)object->timestampVal->__create();
        timestampVal->__copy(*object->timestampVal);
      }
      else
      {
        timestampVal = (TimeStamp *) 0;
      }
    }
    else
    {
      this->timestampVal = (TimeStamp*) asnBNULL;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_ServiceParameter__dataVal) != asnFALSE)
    {
      this->dataVal.__copy(object->dataVal);
    }
 }
}

/**
 *    TypeAssignment : asncassignFileInfoss
 *    Class constructor
 */
asncassignFileInfoss::asncassignFileInfoss(const asncassignFileInfoss& object)
  : asnListElement()
  ,partidentifier()
  ,softwarePartSignature()
  ,fileCheckSum()
{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : asncassignFileInfoss
 * Copy method
 */
void asncassignFileInfoss::__copy (const asntype& obj)
{
  const asncassignFileInfoss* object = asnSCast(const asncassignFileInfoss*,&obj);
 {
    this->partidentifier.__copy (object->partidentifier);
 }
 {
    this->softwarePartSignature.__copy (object->softwarePartSignature);
 }
 {
    this->fileCheckSum.__copy (object->fileCheckSum);
 }
}

/**
 *    TypeAssignment : asncRvdcSetting__serviceParameterss
 *    Class constructor
 */
asncRvdcSetting__serviceParameterss::asncRvdcSetting__serviceParameterss(const asncRvdcSetting__serviceParameterss& object)
  : asnListElement()
  ,optional(object.optional.length, optionalField)
  ,key()
  ,intVal()
  ,stringVal()
  ,boolVal()
  ,timestampVal()
  ,dataVal()
{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : asncRvdcSetting__serviceParameterss
 * Copy method
 */
void asncRvdcSetting__serviceParameterss::__copy (const asntype& obj)
{
  const asncRvdcSetting__serviceParameterss* object = asnSCast(const asncRvdcSetting__serviceParameterss*,&obj);
  optionalField[0] = object->optionalField[0];
 {
    this->key.__copy (object->key);
 }
 {
    if(asnGetPresence(object->optionalField,asn_intVal) != asnFALSE)
    {
      intVal = object->intVal;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_ServiceParameter__stringVal) != asnFALSE)
    {
      this->stringVal.__copy (object->stringVal);
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_ServiceParameter__boolVal) != asnFALSE)
    {
      boolVal = object->boolVal;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_ServiceParameter__timestampVal) != asnFALSE)
    {
      if(object->timestampVal != (TimeStamp *)asnBNULL)
      {
        timestampVal = (TimeStamp*)object->timestampVal->__create();
        timestampVal->__copy(*object->timestampVal);
      }
      else
      {
        timestampVal = (TimeStamp *) 0;
      }
    }
    else
    {
      this->timestampVal = (TimeStamp*) asnBNULL;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_ServiceParameter__dataVal) != asnFALSE)
    {
      this->dataVal.__copy(object->dataVal);
    }
 }
}

/**
 *    TypeAssignment : asncinstalledMas
 *    Class constructor
 */
asncinstalledMas::asncinstalledMas(const asncinstalledMas& object)
  : asnListElement()
  ,maId()
  ,maVersion()
{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : asncinstalledMas
 * Copy method
 */
void asncinstalledMas::__copy (const asntype& obj)
{
  const asncinstalledMas* object = asnSCast(const asncinstalledMas*,&obj);
 {
    maId = object->maId;
 }
 {
    maVersion = object->maVersion;
 }
}

/**
 *    TypeAssignment : asncMaSynchronizationReq__serviceParameterss
 *    Class constructor
 */
asncMaSynchronizationReq__serviceParameterss::asncMaSynchronizationReq__serviceParameterss(const asncMaSynchronizationReq__serviceParameterss& object)
  : asnListElement()
  ,optional(object.optional.length, optionalField)
  ,key()
  ,intVal()
  ,stringVal()
  ,boolVal()
  ,timestampVal()
  ,dataVal()
{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : asncMaSynchronizationReq__serviceParameterss
 * Copy method
 */
void asncMaSynchronizationReq__serviceParameterss::__copy (const asntype& obj)
{
  const asncMaSynchronizationReq__serviceParameterss* object = asnSCast(const asncMaSynchronizationReq__serviceParameterss*,&obj);
  optionalField[0] = object->optionalField[0];
 {
    this->key.__copy (object->key);
 }
 {
    if(asnGetPresence(object->optionalField,asn_intVal) != asnFALSE)
    {
      intVal = object->intVal;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_ServiceParameter__stringVal) != asnFALSE)
    {
      this->stringVal.__copy (object->stringVal);
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_ServiceParameter__boolVal) != asnFALSE)
    {
      boolVal = object->boolVal;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_ServiceParameter__timestampVal) != asnFALSE)
    {
      if(object->timestampVal != (TimeStamp *)asnBNULL)
      {
        timestampVal = (TimeStamp*)object->timestampVal->__create();
        timestampVal->__copy(*object->timestampVal);
      }
      else
      {
        timestampVal = (TimeStamp *) 0;
      }
    }
    else
    {
      this->timestampVal = (TimeStamp*) asnBNULL;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_ServiceParameter__dataVal) != asnFALSE)
    {
      this->dataVal.__copy(object->dataVal);
    }
 }
}

/**
 *    TypeAssignment : asncremoveMass
 *    Class constructor
 */
asncremoveMass::asncremoveMass(const asncremoveMass& object)
  : asnListElement()
  ,maId()
  ,maVersion()
{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : asncremoveMass
 * Copy method
 */
void asncremoveMass::__copy (const asntype& obj)
{
  const asncremoveMass* object = asnSCast(const asncremoveMass*,&obj);
 {
    maId = object->maId;
 }
 {
    maVersion = object->maVersion;
 }
}

/**
 *    TypeAssignment : asncdiagnosticCommandss
 *    Class constructor
 */
asncdiagnosticCommandss::asncdiagnosticCommandss(const asncdiagnosticCommandss& object)
  : asnListElement()
  ,optional(object.optional.length, optionalField)
  ,ecuAddress()
  ,serviceId()
  ,input()
  ,compareType()
  ,compareValue()
  ,delayUntilNextTriggerCommand()
{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : asncdiagnosticCommandss
 * Copy method
 */
void asncdiagnosticCommandss::__copy (const asntype& obj)
{
  const asncdiagnosticCommandss* object = asnSCast(const asncdiagnosticCommandss*,&obj);
  optionalField[0] = object->optionalField[0];
 {
    this->ecuAddress.__copy (object->ecuAddress);
 }
 {
    this->serviceId.__copy (object->serviceId);
 }
 {
    this->input.__copy (object->input);
 }
 {
    if(asnGetPresence(object->optionalField,asn_compareType) != asnFALSE)
    {
      compareType = object->compareType;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_compareValue) != asnFALSE)
    {
      this->compareValue.__copy (object->compareValue);
    }
 }
 {
    delayUntilNextTriggerCommand = object->delayUntilNextTriggerCommand;
 }
}

/**
 *    TypeAssignment : asncecusAndPartNumberss
 *    Class constructor
 */
asncecusAndPartNumberss::asncecusAndPartNumberss(const asncecusAndPartNumberss& object)
  : asnListElement()
  ,ecuAddress()
  ,diagnosticPartNumber()
{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : asncecusAndPartNumberss
 * Copy method
 */
void asncecusAndPartNumberss::__copy (const asntype& obj)
{
  const asncecusAndPartNumberss* object = asnSCast(const asncecusAndPartNumberss*,&obj);
 {
    this->ecuAddress.__copy (object->ecuAddress);
 }
 {
    this->diagnosticPartNumber.__copy (object->diagnosticPartNumber);
 }
}

/**
 *    TypeAssignment : asncdiagnosticCommands
 *    Class constructor
 */
asncdiagnosticCommands::asncdiagnosticCommands(const asncdiagnosticCommands& object)
  : asnListElement()
  ,optional(object.optional.length, optionalField)
  ,ecuAddress()
  ,serviceId()
  ,input()
  ,compareType()
  ,compareValue()
  ,delayUntilNextTriggerCommand()
{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : asncdiagnosticCommands
 * Copy method
 */
void asncdiagnosticCommands::__copy (const asntype& obj)
{
  const asncdiagnosticCommands* object = asnSCast(const asncdiagnosticCommands*,&obj);
  optionalField[0] = object->optionalField[0];
 {
    this->ecuAddress.__copy (object->ecuAddress);
 }
 {
    this->serviceId.__copy (object->serviceId);
 }
 {
    this->input.__copy (object->input);
 }
 {
    if(asnGetPresence(object->optionalField,asn_compareType) != asnFALSE)
    {
      compareType = object->compareType;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_compareValue) != asnFALSE)
    {
      this->compareValue.__copy (object->compareValue);
    }
 }
 {
    delayUntilNextTriggerCommand = object->delayUntilNextTriggerCommand;
 }
}

/**
 *    TypeAssignment : asncMeasurementAssignment__serviceParameterss
 *    Class constructor
 */
asncMeasurementAssignment__serviceParameterss::asncMeasurementAssignment__serviceParameterss(const asncMeasurementAssignment__serviceParameterss& object)
  : asnListElement()
  ,optional(object.optional.length, optionalField)
  ,key()
  ,intVal()
  ,stringVal()
  ,boolVal()
  ,timestampVal()
  ,dataVal()
{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : asncMeasurementAssignment__serviceParameterss
 * Copy method
 */
void asncMeasurementAssignment__serviceParameterss::__copy (const asntype& obj)
{
  const asncMeasurementAssignment__serviceParameterss* object = asnSCast(const asncMeasurementAssignment__serviceParameterss*,&obj);
  optionalField[0] = object->optionalField[0];
 {
    this->key.__copy (object->key);
 }
 {
    if(asnGetPresence(object->optionalField,asn_intVal) != asnFALSE)
    {
      intVal = object->intVal;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_ServiceParameter__stringVal) != asnFALSE)
    {
      this->stringVal.__copy (object->stringVal);
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_ServiceParameter__boolVal) != asnFALSE)
    {
      boolVal = object->boolVal;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_ServiceParameter__timestampVal) != asnFALSE)
    {
      if(object->timestampVal != (TimeStamp *)asnBNULL)
      {
        timestampVal = (TimeStamp*)object->timestampVal->__create();
        timestampVal->__copy(*object->timestampVal);
      }
      else
      {
        timestampVal = (TimeStamp *) 0;
      }
    }
    else
    {
      this->timestampVal = (TimeStamp*) asnBNULL;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_ServiceParameter__dataVal) != asnFALSE)
    {
      this->dataVal.__copy(object->dataVal);
    }
 }
}

/**
 *    TypeAssignment : asncnewMass
 *    Class constructor
 */
asncnewMass::asncnewMass(const asncnewMass& object)
  : asnListElement()
  ,optional(object.optional.length, optionalField)
  ,maId()
  ,maVersion()
  ,vin()
  ,maFormatVersion()
  ,maExecutionPriority()
  ,telematicsParameters()
  ,usageModesAllowed()
  ,startCondition()
  ,stopCondition()
  ,retentiondate()
  ,authorizationStatus()
  ,executionTrigger()
  ,ecusAndPartNumbers()
  ,diagnosticCommand()
  ,dataIntegrityCheck()
  ,serviceParameters()
{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : asncnewMass
 * Copy method
 */
void asncnewMass::__copy (const asntype& obj)
{
  const asncnewMass* object = asnSCast(const asncnewMass*,&obj);
  optionalField[0] = object->optionalField[0];
 {
    maId = object->maId;
 }
 {
    maVersion = object->maVersion;
 }
 {
    this->vin.__copy (object->vin);
 }
 {
    maFormatVersion = object->maFormatVersion;
 }
 {
    maExecutionPriority = object->maExecutionPriority;
 }
 {
    if(object->telematicsParameters != (TelematicsParameters *)asnBNULL)
    {
      telematicsParameters = (TelematicsParameters*)object->telematicsParameters->__create();
      telematicsParameters->__copy(*object->telematicsParameters);
    }
    else
    {
      telematicsParameters = (TelematicsParameters *) 0;
    }
 }
 {
    usageModesAllowed = object->usageModesAllowed;
 }
 {
    this->startCondition.__copy (object->startCondition);
 }
 {
    if(object->stopCondition != (StopCondition *)asnBNULL)
    {
      stopCondition = (StopCondition*)object->stopCondition->__create();
      stopCondition->__copy(*object->stopCondition);
    }
    else
    {
      stopCondition = (StopCondition *) 0;
    }
 }
 {
    this->retentiondate.__copy (object->retentiondate);
 }
 {
    if(object->authorizationStatus != (AuthorizationStatus *)asnBNULL)
    {
      authorizationStatus = (AuthorizationStatus*)object->authorizationStatus->__create();
      authorizationStatus->__copy(*object->authorizationStatus);
    }
    else
    {
      authorizationStatus = (AuthorizationStatus *) 0;
    }
 }
 {
    if(object->executionTrigger != (ExecutionTrigger *)asnBNULL)
    {
      executionTrigger = (ExecutionTrigger*)object->executionTrigger->__create();
      executionTrigger->__copy(*object->executionTrigger);
    }
    else
    {
      executionTrigger = (ExecutionTrigger *) 0;
    }
 }
 {
    asncecusAndPartNumberss *elt_asncecusAndPartNumberss;
    elt_asncecusAndPartNumberss = (asncecusAndPartNumberss*) object->ecusAndPartNumbers.firstElement;
    for (asnMAXUINT countecusAndPartNumbers=0; countecusAndPartNumbers<object->ecusAndPartNumbers.count; countecusAndPartNumbers++)
    {
      ecusAndPartNumbers.addElement(new asncecusAndPartNumberss(*elt_asncecusAndPartNumberss));
      elt_asncecusAndPartNumberss = (asncecusAndPartNumberss*) elt_asncecusAndPartNumberss->nextElement;
    }
 }
 {
    asncdiagnosticCommands *elt_asncdiagnosticCommands;
    elt_asncdiagnosticCommands = (asncdiagnosticCommands*) object->diagnosticCommand.firstElement;
    for (asnMAXUINT countdiagnosticCommand=0; countdiagnosticCommand<object->diagnosticCommand.count; countdiagnosticCommand++)
    {
      diagnosticCommand.addElement(new asncdiagnosticCommands(*elt_asncdiagnosticCommands));
      elt_asncdiagnosticCommands = (asncdiagnosticCommands*) elt_asncdiagnosticCommands->nextElement;
    }
 }
 {
    this->dataIntegrityCheck.__copy (object->dataIntegrityCheck);
 }
 {
    if(asnGetPresence(object->optionalField,asn_MeasurementAssignment__serviceParameters) != asnFALSE)
    {
      asncMeasurementAssignment__serviceParameterss *elt_asncMeasurementAssignment__serviceParameterss;
      elt_asncMeasurementAssignment__serviceParameterss = (asncMeasurementAssignment__serviceParameterss*) object->serviceParameters.firstElement;
      for (asnMAXUINT countserviceParameters=0; countserviceParameters<object->serviceParameters.count; countserviceParameters++)
      {
        serviceParameters.addElement(new asncMeasurementAssignment__serviceParameterss(*elt_asncMeasurementAssignment__serviceParameterss));
        elt_asncMeasurementAssignment__serviceParameterss = (asncMeasurementAssignment__serviceParameterss*) elt_asncMeasurementAssignment__serviceParameterss->nextElement;
      }
    }
 }
}

/**
 *    TypeAssignment : asncMaSynchronization__serviceParameterss
 *    Class constructor
 */
asncMaSynchronization__serviceParameterss::asncMaSynchronization__serviceParameterss(const asncMaSynchronization__serviceParameterss& object)
  : asnListElement()
  ,optional(object.optional.length, optionalField)
  ,key()
  ,intVal()
  ,stringVal()
  ,boolVal()
  ,timestampVal()
  ,dataVal()
{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : asncMaSynchronization__serviceParameterss
 * Copy method
 */
void asncMaSynchronization__serviceParameterss::__copy (const asntype& obj)
{
  const asncMaSynchronization__serviceParameterss* object = asnSCast(const asncMaSynchronization__serviceParameterss*,&obj);
  optionalField[0] = object->optionalField[0];
 {
    this->key.__copy (object->key);
 }
 {
    if(asnGetPresence(object->optionalField,asn_intVal) != asnFALSE)
    {
      intVal = object->intVal;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_ServiceParameter__stringVal) != asnFALSE)
    {
      this->stringVal.__copy (object->stringVal);
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_ServiceParameter__boolVal) != asnFALSE)
    {
      boolVal = object->boolVal;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_ServiceParameter__timestampVal) != asnFALSE)
    {
      if(object->timestampVal != (TimeStamp *)asnBNULL)
      {
        timestampVal = (TimeStamp*)object->timestampVal->__create();
        timestampVal->__copy(*object->timestampVal);
      }
      else
      {
        timestampVal = (TimeStamp *) 0;
      }
    }
    else
    {
      this->timestampVal = (TimeStamp*) asnBNULL;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_ServiceParameter__dataVal) != asnFALSE)
    {
      this->dataVal.__copy(object->dataVal);
    }
 }
}

/**
 *    TypeAssignment : asncMeasurementDataPackage__serviceParameterss
 *    Class constructor
 */
asncMeasurementDataPackage__serviceParameterss::asncMeasurementDataPackage__serviceParameterss(const asncMeasurementDataPackage__serviceParameterss& object)
  : asnListElement()
  ,optional(object.optional.length, optionalField)
  ,key()
  ,intVal()
  ,stringVal()
  ,boolVal()
  ,timestampVal()
  ,dataVal()
{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : asncMeasurementDataPackage__serviceParameterss
 * Copy method
 */
void asncMeasurementDataPackage__serviceParameterss::__copy (const asntype& obj)
{
  const asncMeasurementDataPackage__serviceParameterss* object = asnSCast(const asncMeasurementDataPackage__serviceParameterss*,&obj);
  optionalField[0] = object->optionalField[0];
 {
    this->key.__copy (object->key);
 }
 {
    if(asnGetPresence(object->optionalField,asn_intVal) != asnFALSE)
    {
      intVal = object->intVal;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_ServiceParameter__stringVal) != asnFALSE)
    {
      this->stringVal.__copy (object->stringVal);
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_ServiceParameter__boolVal) != asnFALSE)
    {
      boolVal = object->boolVal;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_ServiceParameter__timestampVal) != asnFALSE)
    {
      if(object->timestampVal != (TimeStamp *)asnBNULL)
      {
        timestampVal = (TimeStamp*)object->timestampVal->__create();
        timestampVal->__copy(*object->timestampVal);
      }
      else
      {
        timestampVal = (TimeStamp *) 0;
      }
    }
    else
    {
      this->timestampVal = (TimeStamp*) asnBNULL;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_ServiceParameter__dataVal) != asnFALSE)
    {
      this->dataVal.__copy(object->dataVal);
    }
 }
}

/**
 *    TypeAssignment : asnctrackpointss
 *    Class constructor
 */
asnctrackpointss::asnctrackpointss(const asnctrackpointss& object)
  : asnListElement()
  ,optional(object.optional.length, optionalField)
  ,systemTime()
  ,position()
  ,speed()
  ,direction()
  ,isSVT()
  ,odometer()
  ,travelDistanceSinceLastWaypoint()
  ,fuelConsumptionSinceLastWaypoint()
  ,electricConsumptionSinceLastSample()
  ,electricRegenerationSinceLastSample()
{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : asnctrackpointss
 * Copy method
 */
void asnctrackpointss::__copy (const asntype& obj)
{
  const asnctrackpointss* object = asnSCast(const asnctrackpointss*,&obj);
  optionalField[0] = object->optionalField[0];
 {
    if(object->systemTime != (TimeStamp *)asnBNULL)
    {
      systemTime = (TimeStamp*)object->systemTime->__create();
      systemTime->__copy(*object->systemTime);
    }
    else
    {
      systemTime = (TimeStamp *) 0;
    }
 }
 {
    if(object->position != (Position *)asnBNULL)
    {
      position = (Position*)object->position->__create();
      position->__copy(*object->position);
    }
    else
    {
      position = (Position *) 0;
    }
 }
 {
    speed = object->speed;
 }
 {
    if(asnGetPresence(object->optionalField,asn_TrackPoint__direction) != asnFALSE)
    {
      direction = object->direction;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_isSVT) != asnFALSE)
    {
      isSVT = object->isSVT;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_TrackPoint__odometer) != asnFALSE)
    {
      odometer = object->odometer;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_travelDistanceSinceLastWaypoint) != asnFALSE)
    {
      travelDistanceSinceLastWaypoint = object->travelDistanceSinceLastWaypoint;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_fuelConsumptionSinceLastWaypoint) != asnFALSE)
    {
      fuelConsumptionSinceLastWaypoint = object->fuelConsumptionSinceLastWaypoint;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_electricConsumptionSinceLastSample) != asnFALSE)
    {
      electricConsumptionSinceLastSample = object->electricConsumptionSinceLastSample;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_electricRegenerationSinceLastSample) != asnFALSE)
    {
      electricRegenerationSinceLastSample = object->electricRegenerationSinceLastSample;
    }
 }
}

/**
 *    TypeAssignment : asncwaypointss
 *    Class constructor
 */
asncwaypointss::asncwaypointss(const asncwaypointss& object)
  : asnListElement()
  ,optional(object.optional.length, optionalField)
  ,latitude()
  ,longitude()
  ,altitude()
  ,posCanBeTrusted()
  ,carLocatorStatUploadEn()
  ,marsCoordinates()
{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : asncwaypointss
 * Copy method
 */
void asncwaypointss::__copy (const asntype& obj)
{
  const asncwaypointss* object = asnSCast(const asncwaypointss*,&obj);
  optionalField[0] = object->optionalField[0];
 {
    if(asnGetPresence(object->optionalField,asn_latitude) != asnFALSE)
    {
      latitude = object->latitude;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_longitude) != asnFALSE)
    {
      longitude = object->longitude;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_altitude) != asnFALSE)
    {
      altitude = object->altitude;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_posCanBeTrusted) != asnFALSE)
    {
      posCanBeTrusted = object->posCanBeTrusted;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_carLocatorStatUploadEn) != asnFALSE)
    {
      carLocatorStatUploadEn = object->carLocatorStatUploadEn;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_marsCoordinates) != asnFALSE)
    {
      marsCoordinates = object->marsCoordinates;
    }
 }
}

/**
 *    TypeAssignment : asnctripFragmentss
 *    Class constructor
 */
asnctripFragmentss::asnctripFragmentss(const asnctripFragmentss& object)
  : asnListElement()
  ,optional(object.optional.length, optionalField)
  ,startTime()
  ,startPosition()
  ,startOdometer()
  ,startFuelLevel()
  ,startElectricConsumption()
  ,startElectricRegeneration()
  ,endTime()
  ,endPosition()
  ,endOdometer()
  ,endFuelLevel()
  ,endElectricConsumption()
  ,endElectricRegeneration()
{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : asnctripFragmentss
 * Copy method
 */
void asnctripFragmentss::__copy (const asntype& obj)
{
  const asnctripFragmentss* object = asnSCast(const asnctripFragmentss*,&obj);
  optionalField[0] = object->optionalField[0];
  optionalField[1] = object->optionalField[1];
 {
    if(object->startTime != (TimeStamp *)asnBNULL)
    {
      startTime = (TimeStamp*)object->startTime->__create();
      startTime->__copy(*object->startTime);
    }
    else
    {
      startTime = (TimeStamp *) 0;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_startPosition) != asnFALSE)
    {
      if(object->startPosition != (Position *)asnBNULL)
      {
        startPosition = (Position*)object->startPosition->__create();
        startPosition->__copy(*object->startPosition);
      }
      else
      {
        startPosition = (Position *) 0;
      }
    }
    else
    {
      this->startPosition = (Position*) asnBNULL;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_TripFragment__startOdometer) != asnFALSE)
    {
      startOdometer = object->startOdometer;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_startFuelLevel) != asnFALSE)
    {
      startFuelLevel = object->startFuelLevel;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_startElectricConsumption) != asnFALSE)
    {
      startElectricConsumption = object->startElectricConsumption;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_startElectricRegeneration) != asnFALSE)
    {
      startElectricRegeneration = object->startElectricRegeneration;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_TripFragment__endTime) != asnFALSE)
    {
      if(object->endTime != (TimeStamp *)asnBNULL)
      {
        endTime = (TimeStamp*)object->endTime->__create();
        endTime->__copy(*object->endTime);
      }
      else
      {
        endTime = (TimeStamp *) 0;
      }
    }
    else
    {
      this->endTime = (TimeStamp*) asnBNULL;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_endPosition) != asnFALSE)
    {
      if(object->endPosition != (Position *)asnBNULL)
      {
        endPosition = (Position*)object->endPosition->__create();
        endPosition->__copy(*object->endPosition);
      }
      else
      {
        endPosition = (Position *) 0;
      }
    }
    else
    {
      this->endPosition = (Position*) asnBNULL;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_TripFragment__endOdometer) != asnFALSE)
    {
      endOdometer = object->endOdometer;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_endFuelLevel) != asnFALSE)
    {
      endFuelLevel = object->endFuelLevel;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_endElectricConsumption) != asnFALSE)
    {
      endElectricConsumption = object->endElectricConsumption;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_endElectricRegeneration) != asnFALSE)
    {
      endElectricRegeneration = object->endElectricRegeneration;
    }
 }
}

/**
 *    TypeAssignment : asnctrackPointss
 *    Class constructor
 */
asnctrackPointss::asnctrackPointss(const asnctrackPointss& object)
  : asnListElement()
  ,optional(object.optional.length, optionalField)
  ,systemTime()
  ,position()
  ,speed()
  ,direction()
  ,isSVT()
  ,odometer()
  ,travelDistanceSinceLastWaypoint()
  ,fuelConsumptionSinceLastWaypoint()
  ,electricConsumptionSinceLastSample()
  ,electricRegenerationSinceLastSample()
{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : asnctrackPointss
 * Copy method
 */
void asnctrackPointss::__copy (const asntype& obj)
{
  const asnctrackPointss* object = asnSCast(const asnctrackPointss*,&obj);
  optionalField[0] = object->optionalField[0];
 {
    if(object->systemTime != (TimeStamp *)asnBNULL)
    {
      systemTime = (TimeStamp*)object->systemTime->__create();
      systemTime->__copy(*object->systemTime);
    }
    else
    {
      systemTime = (TimeStamp *) 0;
    }
 }
 {
    if(object->position != (Position *)asnBNULL)
    {
      position = (Position*)object->position->__create();
      position->__copy(*object->position);
    }
    else
    {
      position = (Position *) 0;
    }
 }
 {
    speed = object->speed;
 }
 {
    if(asnGetPresence(object->optionalField,asn_TrackPoint__direction) != asnFALSE)
    {
      direction = object->direction;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_isSVT) != asnFALSE)
    {
      isSVT = object->isSVT;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_TrackPoint__odometer) != asnFALSE)
    {
      odometer = object->odometer;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_travelDistanceSinceLastWaypoint) != asnFALSE)
    {
      travelDistanceSinceLastWaypoint = object->travelDistanceSinceLastWaypoint;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_fuelConsumptionSinceLastWaypoint) != asnFALSE)
    {
      fuelConsumptionSinceLastWaypoint = object->fuelConsumptionSinceLastWaypoint;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_electricConsumptionSinceLastSample) != asnFALSE)
    {
      electricConsumptionSinceLastSample = object->electricConsumptionSinceLastSample;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_electricRegenerationSinceLastSample) != asnFALSE)
    {
      electricRegenerationSinceLastSample = object->electricRegenerationSinceLastSample;
    }
 }
}

/**
 *    TypeAssignment : asncdidDatas
 *    Class constructor
 */
asncdidDatas::asncdidDatas(const asncdidDatas& object)
  : asnListElement()
  ,id()
  ,data()
{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : asncdidDatas
 * Copy method
 */
void asncdidDatas::__copy (const asntype& obj)
{
  const asncdidDatas* object = asnSCast(const asncdidDatas*,&obj);
 {
    id = object->id;
 }
 {
    this->data.__copy(object->data);
 }
}

/**
 *    TypeAssignment : asncdtcDatas
 *    Class constructor
 */
asncdtcDatas::asncdtcDatas(const asncdtcDatas& object)
  : asnListElement()
  ,id()
  ,data()
{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : asncdtcDatas
 * Copy method
 */
void asncdtcDatas::__copy (const asntype& obj)
{
  const asncdtcDatas* object = asnSCast(const asncdtcDatas*,&obj);
 {
    id = object->id;
 }
 {
    this->data.__copy(object->data);
 }
}

/**
 *    TypeAssignment : asncdatas
 *    Class constructor
 */
asncdatas::asncdatas(const asncdatas& object)
  : asnListElement()
  ,ecu()
  ,diagnosticNumber()
  ,didData()
  ,dtcData()
{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : asncdatas
 * Copy method
 */
void asncdatas::__copy (const asntype& obj)
{
  const asncdatas* object = asnSCast(const asncdatas*,&obj);
 {
    ecu = object->ecu;
 }
 {
    this->diagnosticNumber.__copy (object->diagnosticNumber);
 }
 {
    asncdidDatas *elt_asncdidDatas;
    elt_asncdidDatas = (asncdidDatas*) object->didData.firstElement;
    for (asnMAXUINT countdidData=0; countdidData<object->didData.count; countdidData++)
    {
      didData.addElement(new asncdidDatas(*elt_asncdidDatas));
      elt_asncdidDatas = (asncdidDatas*) elt_asncdidDatas->nextElement;
    }
 }
 {
    asncdtcDatas *elt_asncdtcDatas;
    elt_asncdtcDatas = (asncdtcDatas*) object->dtcData.firstElement;
    for (asnMAXUINT countdtcData=0; countdtcData<object->dtcData.count; countdtcData++)
    {
      dtcData.addElement(new asncdtcDatas(*elt_asncdtcDatas));
      elt_asncdtcDatas = (asncdtcDatas*) elt_asncdtcDatas->nextElement;
    }
 }
}

/**
 *    TypeAssignment : asncconditionss
 *    Class constructor
 */
asncconditionss::asncconditionss(const asncconditionss& object)
  : asnListElement()
  ,condition()
{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : asncconditionss
 * Copy method
 */
void asncconditionss::__copy (const asntype& obj)
{
  const asncconditionss* object = asnSCast(const asncconditionss*,&obj);
 {
    this->condition.__copy (object->condition);
 }
}

/**
 *    TypeAssignment : asnctimerss
 *    Class constructor
 */
asnctimerss::asnctimerss(const asnctimerss& object)
  : asnListElement()
  ,optional(object.optional.length, optionalField)
  ,timerActivation()
  ,duration()
  ,dayofWeek()
  ,startTimeofDay()
  ,endtimeofDay()
{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : asnctimerss
 * Copy method
 */
void asnctimerss::__copy (const asntype& obj)
{
  const asnctimerss* object = asnSCast(const asnctimerss*,&obj);
  optionalField[0] = object->optionalField[0];
 {
    timerActivation = object->timerActivation;
 }
 {
    if(asnGetPresence(object->optionalField,asn_TimerInfo__duration) != asnFALSE)
    {
      duration = object->duration;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_dayofWeek) != asnFALSE)
    {
      this->dayofWeek.__copy(object->dayofWeek);
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_TimerInfo__startTimeofDay) != asnFALSE)
    {
      this->startTimeofDay.__copy(object->startTimeofDay);
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_endtimeofDay) != asnFALSE)
    {
      this->endtimeofDay.__copy(object->endtimeofDay);
    }
 }
}

/**
 *    TypeAssignment : RequestHeader
 *    Class constructor
 */
RequestHeader::RequestHeader(const RequestHeader& object)
  : asntype()  ,optional(object.optional.length, optionalField)
  ,requestid()
  ,timeStamp()
  ,eventId()
  ,creatorId()
  ,messageTTL()
  ,requestType()
  ,ackRequired()

{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : RequestHeader
 * Copy method
 */
void RequestHeader::__copy (const asntype& obj)
{
  const RequestHeader* object = asnSCast(const RequestHeader*,&obj);
  optionalField[0] = object->optionalField[0];
 {
    requestid = object->requestid;
 }
 {
    if(object->timeStamp != (TimeStamp *)asnBNULL)
    {
      timeStamp = (TimeStamp*)object->timeStamp->__create();
      timeStamp->__copy(*object->timeStamp);
    }
    else
    {
      timeStamp = (TimeStamp *) 0;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_eventId) != asnFALSE)
    {
      if(object->eventId != (TimeStamp *)asnBNULL)
      {
        eventId = (TimeStamp*)object->eventId->__create();
        eventId->__copy(*object->eventId);
      }
      else
      {
        eventId = (TimeStamp *) 0;
      }
    }
    else
    {
      this->eventId = (TimeStamp*) asnBNULL;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_creatorId) != asnFALSE)
    {
      creatorId = object->creatorId;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_messageTTL) != asnFALSE)
    {
      messageTTL = object->messageTTL;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_requestType) != asnFALSE)
    {
      requestType = object->requestType;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_ackRequired) != asnFALSE)
    {
      ackRequired = object->ackRequired;
    }
 }
}

/**
 *    TypeAssignment : TimeStamp
 *    Class constructor
 */
TimeStamp::TimeStamp(const TimeStamp& object)
  : asntype()  ,optional(object.optional.length, optionalField)
  ,seconds()
  ,milliseconds()

{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : TimeStamp
 * Copy method
 */
void TimeStamp::__copy (const asntype& obj)
{
  const TimeStamp* object = asnSCast(const TimeStamp*,&obj);
  optionalField[0] = object->optionalField[0];
 {
    seconds = object->seconds;
 }
 {
    if(asnGetPresence(object->optionalField,asn_milliseconds) != asnFALSE)
    {
      milliseconds = object->milliseconds;
    }
 }
}

/**
 *    TypeAssignment : VDServiceRequest
 *    Class constructor
 */
VDServiceRequest::VDServiceRequest(const VDServiceRequest& object)
  : asntype()  ,optional(object.optional.length, optionalField)
  ,header()
  ,body()

{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : VDServiceRequest
 * Copy method
 */
void VDServiceRequest::__copy (const asntype& obj)
{
  const VDServiceRequest* object = asnSCast(const VDServiceRequest*,&obj);
  optionalField[0] = object->optionalField[0];
 {
    if(object->header != (RequestHeader *)asnBNULL)
    {
      header = (RequestHeader*)object->header->__create();
      header->__copy(*object->header);
    }
    else
    {
      header = (RequestHeader *) 0;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_body) != asnFALSE)
    {
      if(object->body != (RequestBody *)asnBNULL)
      {
        body = (RequestBody*)object->body->__create();
        body->__copy(*object->body);
      }
      else
      {
        body = (RequestBody *) 0;
      }
    }
    else
    {
      this->body = (RequestBody*) asnBNULL;
    }
 }
}

/**
 *    TypeAssignment : AssignmentData
 *    Class constructor
 */
AssignmentData::AssignmentData(const AssignmentData& object)
  : asntype()  ,installationOrderId()
  ,timestamp()
  ,urls()

{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : AssignmentData
 * Copy method
 */
void AssignmentData::__copy (const asntype& obj)
{
  const AssignmentData* object = asnSCast(const AssignmentData*,&obj);
 {
    this->installationOrderId.__copy (object->installationOrderId);
 }
 {
    this->timestamp.__copy (object->timestamp);
 }
 {
    asncurlss *elt_asncurlss;
    elt_asncurlss = (asncurlss*) object->urls.firstElement;
    for (asnMAXUINT counturls=0; counturls<object->urls.count; counturls++)
    {
      urls.addElement(new asncurlss(*elt_asncurlss));
      elt_asncurlss = (asncurlss*) elt_asncurlss->nextElement;
    }
 }
}

/**
 *    TypeAssignment : AssignmentFileInfo
 *    Class constructor
 */
AssignmentFileInfo::AssignmentFileInfo(const AssignmentFileInfo& object)
  : asntype()  ,partidentifier()
  ,softwarePartSignature()
  ,fileCheckSum()

{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : AssignmentFileInfo
 * Copy method
 */
void AssignmentFileInfo::__copy (const asntype& obj)
{
  const AssignmentFileInfo* object = asnSCast(const AssignmentFileInfo*,&obj);
 {
    this->partidentifier.__copy (object->partidentifier);
 }
 {
    this->softwarePartSignature.__copy (object->softwarePartSignature);
 }
 {
    this->fileCheckSum.__copy (object->fileCheckSum);
 }
}

/**
 *    TypeAssignment : AssignmentValidation
 *    Class constructor
 */
AssignmentValidation::AssignmentValidation(const AssignmentValidation& object)
  : asntype()  ,validationType()
  ,ecuAddress()
  ,validationkey()
  ,partidentifiers()

{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : AssignmentValidation
 * Copy method
 */
void AssignmentValidation::__copy (const asntype& obj)
{
  const AssignmentValidation* object = asnSCast(const AssignmentValidation*,&obj);
 {
    this->validationType.__copy (object->validationType);
 }
 {
    this->ecuAddress.__copy (object->ecuAddress);
 }
 {
    this->validationkey.__copy (object->validationkey);
 }
 {
    asncpartidentifierss *elt_asncpartidentifierss;
    elt_asncpartidentifierss = (asncpartidentifierss*) object->partidentifiers.firstElement;
    for (asnMAXUINT countpartidentifiers=0; countpartidentifiers<object->partidentifiers.count; countpartidentifiers++)
    {
      partidentifiers.addElement(new asncpartidentifierss(*elt_asncpartidentifierss));
      elt_asncpartidentifierss = (asncpartidentifierss*) elt_asncpartidentifierss->nextElement;
    }
 }
}

/**
 *    TypeAssignment : AuthorizationStatus
 *    Class constructor
 */
AuthorizationStatus::AuthorizationStatus(const AuthorizationStatus& object)
  : asntype()  ,optional(object.optional.length, optionalField)
  ,dataCollection()
  ,remoteDiagnostics()

{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : AuthorizationStatus
 * Copy method
 */
void AuthorizationStatus::__copy (const asntype& obj)
{
  const AuthorizationStatus* object = asnSCast(const AuthorizationStatus*,&obj);
  optionalField[0] = object->optionalField[0];
 {
    if(asnGetPresence(object->optionalField,asn_dataCollection) != asnFALSE)
    {
      dataCollection = object->dataCollection;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_remoteDiagnostics) != asnFALSE)
    {
      remoteDiagnostics = object->remoteDiagnostics;
    }
 }
}

/**
 *    TypeAssignment : AvailableAssignment
 *    Class constructor
 */
AvailableAssignment::AvailableAssignment(const AvailableAssignment& object)
  : asntype()  ,optional(object.optional.length, optionalField)
  ,installationOrderId()
  ,timestamp()
  ,workshopInstallation()
  ,downloadsize()
  ,totalinstallationTime()
  ,newstatus()
  ,reason()
  ,name()
  ,shortDescription()
  ,longDescription()

{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : AvailableAssignment
 * Copy method
 */
void AvailableAssignment::__copy (const asntype& obj)
{
  const AvailableAssignment* object = asnSCast(const AvailableAssignment*,&obj);
  optionalField[0] = object->optionalField[0];
 {
    this->installationOrderId.__copy (object->installationOrderId);
 }
 {
    this->timestamp.__copy (object->timestamp);
 }
 {
    workshopInstallation = object->workshopInstallation;
 }
 {
    downloadsize = object->downloadsize;
 }
 {
    totalinstallationTime = object->totalinstallationTime;
 }
 {
    this->newstatus.__copy (object->newstatus);
 }
 {
    if(asnGetPresence(object->optionalField,asn_AvailableAssignment__reason) != asnFALSE)
    {
      this->reason.__copy (object->reason);
    }
 }
 {
    this->name.__copy (object->name);
 }
 {
    this->shortDescription.__copy (object->shortDescription);
 }
 {
    if(asnGetPresence(object->optionalField,asn_longDescription) != asnFALSE)
    {
      this->longDescription.__copy (object->longDescription);
    }
 }
}

/**
 *    TypeAssignment : AvailableAssignmentRequest
 *    Class constructor
 */
AvailableAssignmentRequest::AvailableAssignmentRequest(const AvailableAssignmentRequest& object)
  : asntype()  ,languageSetting()

{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : AvailableAssignmentRequest
 * Copy method
 */
void AvailableAssignmentRequest::__copy (const asntype& obj)
{
  const AvailableAssignmentRequest* object = asnSCast(const AvailableAssignmentRequest*,&obj);
 {
    if(object->languageSetting != (LanguageSetting *)asnBNULL)
    {
      languageSetting = (LanguageSetting*)object->languageSetting->__create();
      languageSetting->__copy(*object->languageSetting);
    }
    else
    {
      languageSetting = (LanguageSetting *) 0;
    }
 }
}

/**
 *    TypeAssignment : ClientConfSyncRequest
 *    Class constructor
 */
ClientConfSyncRequest::ClientConfSyncRequest(const ClientConfSyncRequest& object)
  : asntype()  ,optional(object.optional.length, optionalField)
  ,timestamp()
  ,clientVersion()
  ,ecuInventory()

{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : ClientConfSyncRequest
 * Copy method
 */
void ClientConfSyncRequest::__copy (const asntype& obj)
{
  const ClientConfSyncRequest* object = asnSCast(const ClientConfSyncRequest*,&obj);
  optionalField[0] = object->optionalField[0];
 {
    this->timestamp.__copy (object->timestamp);
 }
 {
    this->clientVersion.__copy (object->clientVersion);
 }
 {
    if(asnGetPresence(object->optionalField,asn_ecuInventory) != asnFALSE)
    {
      asncecuInventorys *elt_asncecuInventorys;
      elt_asncecuInventorys = (asncecuInventorys*) object->ecuInventory.firstElement;
      for (asnMAXUINT countecuInventory=0; countecuInventory<object->ecuInventory.count; countecuInventory++)
      {
        ecuInventory.addElement(new asncecuInventorys(*elt_asncecuInventorys));
        elt_asncecuInventorys = (asncecuInventorys*) elt_asncecuInventorys->nextElement;
      }
    }
 }
}

/**
 *    TypeAssignment : ClientHmiVehicleSettings
 *    Class constructor
 */
ClientHmiVehicleSettings::ClientHmiVehicleSettings(const ClientHmiVehicleSettings& object)
  : asntype()  ,otaSetting()
  ,autoSync()
  ,autoDownload()
  ,autoInstallation()

{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : ClientHmiVehicleSettings
 * Copy method
 */
void ClientHmiVehicleSettings::__copy (const asntype& obj)
{
  const ClientHmiVehicleSettings* object = asnSCast(const ClientHmiVehicleSettings*,&obj);
 {
    otaSetting = object->otaSetting;
 }
 {
    autoSync = object->autoSync;
 }
 {
    autoDownload = object->autoDownload;
 }
 {
    autoInstallation = object->autoInstallation;
 }
}

/**
 *    TypeAssignment : DiagnosticCommand
 *    Class constructor
 */
DiagnosticCommand::DiagnosticCommand(const DiagnosticCommand& object)
  : asntype()  ,optional(object.optional.length, optionalField)
  ,ecuAddress()
  ,serviceId()
  ,input()
  ,compareType()
  ,compareValue()
  ,delayUntilNextTriggerCommand()

{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : DiagnosticCommand
 * Copy method
 */
void DiagnosticCommand::__copy (const asntype& obj)
{
  const DiagnosticCommand* object = asnSCast(const DiagnosticCommand*,&obj);
  optionalField[0] = object->optionalField[0];
 {
    this->ecuAddress.__copy (object->ecuAddress);
 }
 {
    this->serviceId.__copy (object->serviceId);
 }
 {
    this->input.__copy (object->input);
 }
 {
    if(asnGetPresence(object->optionalField,asn_compareType) != asnFALSE)
    {
      compareType = object->compareType;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_compareValue) != asnFALSE)
    {
      this->compareValue.__copy (object->compareValue);
    }
 }
 {
    delayUntilNextTriggerCommand = object->delayUntilNextTriggerCommand;
 }
}

/**
 *    TypeAssignment : EcuExceptionReport
 *    Class constructor
 */
EcuExceptionReport::EcuExceptionReport(const EcuExceptionReport& object)
  : asntype()  ,exceptionReportMsgRemaining()
  ,exceptionReports()

{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : EcuExceptionReport
 * Copy method
 */
void EcuExceptionReport::__copy (const asntype& obj)
{
  const EcuExceptionReport* object = asnSCast(const EcuExceptionReport*,&obj);
 {
    exceptionReportMsgRemaining = object->exceptionReportMsgRemaining;
 }
 {
    asncexceptionReportss *elt_asncexceptionReportss;
    elt_asncexceptionReportss = (asncexceptionReportss*) object->exceptionReports.firstElement;
    for (asnMAXUINT countexceptionReports=0; countexceptionReports<object->exceptionReports.count; countexceptionReports++)
    {
      exceptionReports.addElement(new asncexceptionReportss(*elt_asncexceptionReportss));
      elt_asncexceptionReportss = (asncexceptionReportss*) elt_asncexceptionReportss->nextElement;
    }
 }
}

/**
 *    TypeAssignment : EcuInstruction
 *    Class constructor
 */
EcuInstruction::EcuInstruction(const EcuInstruction& object)
  : asntype()  ,ecuAddress()
  ,queuedRequest()
  ,securityKey()
  ,softwarePartInstallationInstructions()

{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : EcuInstruction
 * Copy method
 */
void EcuInstruction::__copy (const asntype& obj)
{
  const EcuInstruction* object = asnSCast(const EcuInstruction*,&obj);
 {
    this->ecuAddress.__copy (object->ecuAddress);
 }
 {
    queuedRequest = object->queuedRequest;
 }
 {
    this->securityKey.__copy (object->securityKey);
 }
 {
    asncsoftwarePartInstallationInstructionss *elt_asncsoftwarePartInstallationInstructionss;
    elt_asncsoftwarePartInstallationInstructionss = (asncsoftwarePartInstallationInstructionss*) object->softwarePartInstallationInstructions.firstElement;
    for (asnMAXUINT countsoftwarePartInstallationInstructions=0; countsoftwarePartInstallationInstructions<object->softwarePartInstallationInstructions.count; countsoftwarePartInstallationInstructions++)
    {
      softwarePartInstallationInstructions.addElement(new asncsoftwarePartInstallationInstructionss(*elt_asncsoftwarePartInstallationInstructionss));
      elt_asncsoftwarePartInstallationInstructionss = (asncsoftwarePartInstallationInstructionss*) elt_asncsoftwarePartInstallationInstructionss->nextElement;
    }
 }
}

/**
 *    TypeAssignment : EcuInventory
 *    Class constructor
 */
EcuInventory::EcuInventory(const EcuInventory& object)
  : asntype()  ,optional(object.optional.length, optionalField)
  ,ecuAddress()
  ,validationKeys()
  ,exceptionMessage()

{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : EcuInventory
 * Copy method
 */
void EcuInventory::__copy (const asntype& obj)
{
  const EcuInventory* object = asnSCast(const EcuInventory*,&obj);
  optionalField[0] = object->optionalField[0];
 {
    this->ecuAddress.__copy (object->ecuAddress);
 }
 {
    asncvalidationKeyss *elt_asncvalidationKeyss;
    elt_asncvalidationKeyss = (asncvalidationKeyss*) object->validationKeys.firstElement;
    for (asnMAXUINT countvalidationKeys=0; countvalidationKeys<object->validationKeys.count; countvalidationKeys++)
    {
      validationKeys.addElement(new asncvalidationKeyss(*elt_asncvalidationKeyss));
      elt_asncvalidationKeyss = (asncvalidationKeyss*) elt_asncvalidationKeyss->nextElement;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_exceptionMessage) != asnFALSE)
    {
      this->exceptionMessage.__copy (object->exceptionMessage);
    }
 }
}

/**
 *    TypeAssignment : EcuSummary
 *    Class constructor
 */
EcuSummary::EcuSummary(const EcuSummary& object)
  : asntype()  ,ecuAddress()
  ,ecuRetries()
  ,ecuStatus()
  ,softwarePartSummarys()

{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : EcuSummary
 * Copy method
 */
void EcuSummary::__copy (const asntype& obj)
{
  const EcuSummary* object = asnSCast(const EcuSummary*,&obj);
 {
    this->ecuAddress.__copy (object->ecuAddress);
 }
 {
    ecuRetries = object->ecuRetries;
 }
 {
    this->ecuStatus.__copy (object->ecuStatus);
 }
 {
    asncsoftwarePartSummaryss *elt_asncsoftwarePartSummaryss;
    elt_asncsoftwarePartSummaryss = (asncsoftwarePartSummaryss*) object->softwarePartSummarys.firstElement;
    for (asnMAXUINT countsoftwarePartSummarys=0; countsoftwarePartSummarys<object->softwarePartSummarys.count; countsoftwarePartSummarys++)
    {
      softwarePartSummarys.addElement(new asncsoftwarePartSummaryss(*elt_asncsoftwarePartSummaryss));
      elt_asncsoftwarePartSummaryss = (asncsoftwarePartSummaryss*) elt_asncsoftwarePartSummaryss->nextElement;
    }
 }
}

/**
 *    TypeAssignment : EcusAndPartNumber
 *    Class constructor
 */
EcusAndPartNumber::EcusAndPartNumber(const EcusAndPartNumber& object)
  : asntype()  ,ecuAddress()
  ,diagnosticPartNumber()

{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : EcusAndPartNumber
 * Copy method
 */
void EcusAndPartNumber::__copy (const asntype& obj)
{
  const EcusAndPartNumber* object = asnSCast(const EcusAndPartNumber*,&obj);
 {
    this->ecuAddress.__copy (object->ecuAddress);
 }
 {
    this->diagnosticPartNumber.__copy (object->diagnosticPartNumber);
 }
}

/**
 *    TypeAssignment : ExceptionMessage
 *    Class constructor
 */
ExceptionMessage::ExceptionMessage(const ExceptionMessage& object)
  : asntype()  ,activity()
  ,action()
  ,exception()

{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : ExceptionMessage
 * Copy method
 */
void ExceptionMessage::__copy (const asntype& obj)
{
  const ExceptionMessage* object = asnSCast(const ExceptionMessage*,&obj);
 {
    this->activity.__copy (object->activity);
 }
 {
    this->action.__copy (object->action);
 }
 {
    this->exception.__copy (object->exception);
 }
}

/**
 *    TypeAssignment : ExceptionReport
 *    Class constructor
 */
ExceptionReport::ExceptionReport(const ExceptionReport& object)
  : asntype()  ,optional(object.optional.length, optionalField)
  ,installationOrderId()
  ,timestamp()
  ,issuerId()
  ,clientConfigurationId()
  ,dataFileName()
  ,ecuAddress()
  ,validationKey()
  ,partIdentifier()
  ,dataBlockNumber()
  ,exceptionMessage()

{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : ExceptionReport
 * Copy method
 */
void ExceptionReport::__copy (const asntype& obj)
{
  const ExceptionReport* object = asnSCast(const ExceptionReport*,&obj);
  optionalField[0] = object->optionalField[0];
 {
    if(asnGetPresence(object->optionalField,asn_ExceptionReport__installationOrderId) != asnFALSE)
    {
      this->installationOrderId.__copy (object->installationOrderId);
    }
 }
 {
    this->timestamp.__copy (object->timestamp);
 }
 {
    this->issuerId.__copy (object->issuerId);
 }
 {
    if(asnGetPresence(object->optionalField,asn_clientConfigurationId) != asnFALSE)
    {
      this->clientConfigurationId.__copy (object->clientConfigurationId);
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_dataFileName) != asnFALSE)
    {
      this->dataFileName.__copy (object->dataFileName);
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_ecuAddress) != asnFALSE)
    {
      this->ecuAddress.__copy (object->ecuAddress);
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_validationKey) != asnFALSE)
    {
      this->validationKey.__copy (object->validationKey);
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_partIdentifier) != asnFALSE)
    {
      this->partIdentifier.__copy (object->partIdentifier);
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_dataBlockNumber) != asnFALSE)
    {
      dataBlockNumber = object->dataBlockNumber;
    }
 }
 {
    if(object->exceptionMessage != (ExceptionMessage *)asnBNULL)
    {
      exceptionMessage = (ExceptionMessage*)object->exceptionMessage->__create();
      exceptionMessage->__copy(*object->exceptionMessage);
    }
    else
    {
      exceptionMessage = (ExceptionMessage *) 0;
    }
 }
}

/**
 *    TypeAssignment : ExecutionTrigger
 *    Class constructor
 */
ExecutionTrigger::ExecutionTrigger(const ExecutionTrigger& object)
  : asntype()  ,optional(object.optional.length, optionalField)
  ,push()
  ,uds()
  ,time()
  ,drivingCycle()

{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : ExecutionTrigger
 * Copy method
 */
void ExecutionTrigger::__copy (const asntype& obj)
{
  const ExecutionTrigger* object = asnSCast(const ExecutionTrigger*,&obj);
  optionalField[0] = object->optionalField[0];
 {
    push = object->push;
 }
 {
    if(asnGetPresence(object->optionalField,asn_uds) != asnFALSE)
    {
      if(object->uds != (UDS *)asnBNULL)
      {
        uds = (UDS*)object->uds->__create();
        uds->__copy(*object->uds);
      }
      else
      {
        uds = (UDS *) 0;
      }
    }
    else
    {
      this->uds = (UDS*) asnBNULL;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_ExecutionTrigger__time) != asnFALSE)
    {
      if(object->time != (Trigger *)asnBNULL)
      {
        time = (Trigger*)object->time->__create();
        time->__copy(*object->time);
      }
      else
      {
        time = (Trigger *) 0;
      }
    }
    else
    {
      this->time = (Trigger*) asnBNULL;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_drivingCycle) != asnFALSE)
    {
      if(object->drivingCycle != (Trigger *)asnBNULL)
      {
        drivingCycle = (Trigger*)object->drivingCycle->__create();
        drivingCycle->__copy(*object->drivingCycle);
      }
      else
      {
        drivingCycle = (Trigger *) 0;
      }
    }
    else
    {
      this->drivingCycle = (Trigger*) asnBNULL;
    }
 }
}

/**
 *    TypeAssignment : FOTA
 *    Class constructor
 */
FOTA::FOTA(const FOTA& object)
  : asntype()  ,optional(object.optional.length, optionalField)
  ,appId()
  ,vin()
  ,dataType()
  ,clientConfSyncRequest()
  ,inventoryInstruction()
  ,availableAssignmentRequest()
  ,availableAssignment()
  ,installationInstruction()
  ,installationSummary()
  ,ecuExceptionReport()
  ,clientHmiVehicleSettings()
  ,assignmentData()
  ,assignmentNotification()
  ,otaAssignmentFileInfo()

{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : FOTA
 * Copy method
 */
void FOTA::__copy (const asntype& obj)
{
  const FOTA* object = asnSCast(const FOTA*,&obj);
  optionalField[0] = object->optionalField[0];
  optionalField[1] = object->optionalField[1];
 {
    appId = object->appId;
 }
 {
    this->vin.__copy (object->vin);
 }
 {
    dataType = object->dataType;
 }
 {
    if(asnGetPresence(object->optionalField,asn_FOTA__clientConfSyncRequest) != asnFALSE)
    {
      if(object->clientConfSyncRequest != (ClientConfSyncRequest *)asnBNULL)
      {
        clientConfSyncRequest = (ClientConfSyncRequest*)object->clientConfSyncRequest->__create();
        clientConfSyncRequest->__copy(*object->clientConfSyncRequest);
      }
      else
      {
        clientConfSyncRequest = (ClientConfSyncRequest *) 0;
      }
    }
    else
    {
      this->clientConfSyncRequest = (ClientConfSyncRequest*) asnBNULL;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_FOTA__inventoryInstruction) != asnFALSE)
    {
      if(object->inventoryInstruction != (InventoryInstruction *)asnBNULL)
      {
        inventoryInstruction = (InventoryInstruction*)object->inventoryInstruction->__create();
        inventoryInstruction->__copy(*object->inventoryInstruction);
      }
      else
      {
        inventoryInstruction = (InventoryInstruction *) 0;
      }
    }
    else
    {
      this->inventoryInstruction = (InventoryInstruction*) asnBNULL;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_FOTA__availableAssignmentRequest) != asnFALSE)
    {
      if(object->availableAssignmentRequest != (AvailableAssignmentRequest *)asnBNULL)
      {
        availableAssignmentRequest = (AvailableAssignmentRequest*)object->availableAssignmentRequest->__create();
        availableAssignmentRequest->__copy(*object->availableAssignmentRequest);
      }
      else
      {
        availableAssignmentRequest = (AvailableAssignmentRequest *) 0;
      }
    }
    else
    {
      this->availableAssignmentRequest = (AvailableAssignmentRequest*) asnBNULL;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_FOTA__availableAssignment) != asnFALSE)
    {
      if(object->availableAssignment != (AvailableAssignment *)asnBNULL)
      {
        availableAssignment = (AvailableAssignment*)object->availableAssignment->__create();
        availableAssignment->__copy(*object->availableAssignment);
      }
      else
      {
        availableAssignment = (AvailableAssignment *) 0;
      }
    }
    else
    {
      this->availableAssignment = (AvailableAssignment*) asnBNULL;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_FOTA__installationInstruction) != asnFALSE)
    {
      if(object->installationInstruction != (InstallationInstruction *)asnBNULL)
      {
        installationInstruction = (InstallationInstruction*)object->installationInstruction->__create();
        installationInstruction->__copy(*object->installationInstruction);
      }
      else
      {
        installationInstruction = (InstallationInstruction *) 0;
      }
    }
    else
    {
      this->installationInstruction = (InstallationInstruction*) asnBNULL;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_FOTA__installationSummary) != asnFALSE)
    {
      if(object->installationSummary != (InstallationSummary *)asnBNULL)
      {
        installationSummary = (InstallationSummary*)object->installationSummary->__create();
        installationSummary->__copy(*object->installationSummary);
      }
      else
      {
        installationSummary = (InstallationSummary *) 0;
      }
    }
    else
    {
      this->installationSummary = (InstallationSummary*) asnBNULL;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_FOTA__ecuExceptionReport) != asnFALSE)
    {
      if(object->ecuExceptionReport != (EcuExceptionReport *)asnBNULL)
      {
        ecuExceptionReport = (EcuExceptionReport*)object->ecuExceptionReport->__create();
        ecuExceptionReport->__copy(*object->ecuExceptionReport);
      }
      else
      {
        ecuExceptionReport = (EcuExceptionReport *) 0;
      }
    }
    else
    {
      this->ecuExceptionReport = (EcuExceptionReport*) asnBNULL;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_FOTA__clientHmiVehicleSettings) != asnFALSE)
    {
      if(object->clientHmiVehicleSettings != (ClientHmiVehicleSettings *)asnBNULL)
      {
        clientHmiVehicleSettings = (ClientHmiVehicleSettings*)object->clientHmiVehicleSettings->__create();
        clientHmiVehicleSettings->__copy(*object->clientHmiVehicleSettings);
      }
      else
      {
        clientHmiVehicleSettings = (ClientHmiVehicleSettings *) 0;
      }
    }
    else
    {
      this->clientHmiVehicleSettings = (ClientHmiVehicleSettings*) asnBNULL;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_FOTA__assignmentData) != asnFALSE)
    {
      if(object->assignmentData != (AssignmentData *)asnBNULL)
      {
        assignmentData = (AssignmentData*)object->assignmentData->__create();
        assignmentData->__copy(*object->assignmentData);
      }
      else
      {
        assignmentData = (AssignmentData *) 0;
      }
    }
    else
    {
      this->assignmentData = (AssignmentData*) asnBNULL;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_FOTA__assignmentNotification) != asnFALSE)
    {
      if(object->assignmentNotification != (FotaAssignmentNotification *)asnBNULL)
      {
        assignmentNotification = (FotaAssignmentNotification*)object->assignmentNotification->__create();
        assignmentNotification->__copy(*object->assignmentNotification);
      }
      else
      {
        assignmentNotification = (FotaAssignmentNotification *) 0;
      }
    }
    else
    {
      this->assignmentNotification = (FotaAssignmentNotification*) asnBNULL;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_FOTA__otaAssignmentFileInfo) != asnFALSE)
    {
      if(object->otaAssignmentFileInfo != (OtaAssignmentFileInfo *)asnBNULL)
      {
        otaAssignmentFileInfo = (OtaAssignmentFileInfo*)object->otaAssignmentFileInfo->__create();
        otaAssignmentFileInfo->__copy(*object->otaAssignmentFileInfo);
      }
      else
      {
        otaAssignmentFileInfo = (OtaAssignmentFileInfo *) 0;
      }
    }
    else
    {
      this->otaAssignmentFileInfo = (OtaAssignmentFileInfo*) asnBNULL;
    }
 }
}

/**
 *    TypeAssignment : FotaAssignmentNotification
 *    Class constructor
 */
FotaAssignmentNotification::FotaAssignmentNotification(const FotaAssignmentNotification& object)
  : asntype()  ,optional(object.optional.length, optionalField)
  ,installationOrderId()
  ,timestamp()
  ,newStatus()
  ,reason()
  ,deltaTime()
  ,serviceParams()

{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : FotaAssignmentNotification
 * Copy method
 */
void FotaAssignmentNotification::__copy (const asntype& obj)
{
  const FotaAssignmentNotification* object = asnSCast(const FotaAssignmentNotification*,&obj);
  optionalField[0] = object->optionalField[0];
 {
    if(asnGetPresence(object->optionalField,asn_FotaAssignmentNotification__installationOrderId) != asnFALSE)
    {
      this->installationOrderId.__copy (object->installationOrderId);
    }
 }
 {
    this->timestamp.__copy (object->timestamp);
 }
 {
    this->newStatus.__copy (object->newStatus);
 }
 {
    if(asnGetPresence(object->optionalField,asn_FotaAssignmentNotification__reason) != asnFALSE)
    {
      this->reason.__copy (object->reason);
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_deltaTime) != asnFALSE)
    {
      deltaTime = object->deltaTime;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_serviceParams) != asnFALSE)
    {
      asncserviceParamss *elt_asncserviceParamss;
      elt_asncserviceParamss = (asncserviceParamss*) object->serviceParams.firstElement;
      for (asnMAXUINT countserviceParams=0; countserviceParams<object->serviceParams.count; countserviceParams++)
      {
        serviceParams.addElement(new asncserviceParamss(*elt_asncserviceParamss));
        elt_asncserviceParamss = (asncserviceParamss*) elt_asncserviceParamss->nextElement;
      }
    }
 }
}

/**
 *    TypeAssignment : InstallationInstruction
 *    Class constructor
 */
InstallationInstruction::InstallationInstruction(const InstallationInstruction& object)
  : asntype()  ,installationOrderId()
  ,instructions()

{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : InstallationInstruction
 * Copy method
 */
void InstallationInstruction::__copy (const asntype& obj)
{
  const InstallationInstruction* object = asnSCast(const InstallationInstruction*,&obj);
 {
    this->installationOrderId.__copy (object->installationOrderId);
 }
 {
    asncinstructionss *elt_asncinstructionss;
    elt_asncinstructionss = (asncinstructionss*) object->instructions.firstElement;
    for (asnMAXUINT countinstructions=0; countinstructions<object->instructions.count; countinstructions++)
    {
      instructions.addElement(new asncinstructionss(*elt_asncinstructionss));
      elt_asncinstructionss = (asncinstructionss*) elt_asncinstructionss->nextElement;
    }
 }
}

/**
 *    TypeAssignment : InstallationSummary
 *    Class constructor
 */
InstallationSummary::InstallationSummary(const InstallationSummary& object)
  : asntype()  ,installationOrderId()
  ,timestamp()
  ,repeatresets()
  ,totalInstallationTime()
  ,ecuSummarys()

{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : InstallationSummary
 * Copy method
 */
void InstallationSummary::__copy (const asntype& obj)
{
  const InstallationSummary* object = asnSCast(const InstallationSummary*,&obj);
 {
    this->installationOrderId.__copy (object->installationOrderId);
 }
 {
    this->timestamp.__copy (object->timestamp);
 }
 {
    repeatresets = object->repeatresets;
 }
 {
    totalInstallationTime = object->totalInstallationTime;
 }
 {
    asncecuSummaryss *elt_asncecuSummaryss;
    elt_asncecuSummaryss = (asncecuSummaryss*) object->ecuSummarys.firstElement;
    for (asnMAXUINT countecuSummarys=0; countecuSummarys<object->ecuSummarys.count; countecuSummarys++)
    {
      ecuSummarys.addElement(new asncecuSummaryss(*elt_asncecuSummaryss));
      elt_asncecuSummaryss = (asncecuSummaryss*) elt_asncecuSummaryss->nextElement;
    }
 }
}

/**
 *    TypeAssignment : Instruction
 *    Class constructor
 */
Instruction::Instruction(const Instruction& object)
  : asntype()  ,ecuRemaining()
  ,installationInstructionSversion()
  ,requiredPreparationTime()
  ,expectedInstallationTime()
  ,area1112SecurityCode()
  ,ecuInstructions()
  ,assignmentValidations()

{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : Instruction
 * Copy method
 */
void Instruction::__copy (const asntype& obj)
{
  const Instruction* object = asnSCast(const Instruction*,&obj);
 {
    ecuRemaining = object->ecuRemaining;
 }
 {
    this->installationInstructionSversion.__copy (object->installationInstructionSversion);
 }
 {
    requiredPreparationTime = object->requiredPreparationTime;
 }
 {
    expectedInstallationTime = object->expectedInstallationTime;
 }
 {
    this->area1112SecurityCode.__copy (object->area1112SecurityCode);
 }
 {
    asncInstruction__ecuInstructionss *elt_asncInstruction__ecuInstructionss;
    elt_asncInstruction__ecuInstructionss = (asncInstruction__ecuInstructionss*) object->ecuInstructions.firstElement;
    for (asnMAXUINT countecuInstructions=0; countecuInstructions<object->ecuInstructions.count; countecuInstructions++)
    {
      ecuInstructions.addElement(new asncInstruction__ecuInstructionss(*elt_asncInstruction__ecuInstructionss));
      elt_asncInstruction__ecuInstructionss = (asncInstruction__ecuInstructionss*) elt_asncInstruction__ecuInstructionss->nextElement;
    }
 }
 {
    asncassignmentValidationss *elt_asncassignmentValidationss;
    elt_asncassignmentValidationss = (asncassignmentValidationss*) object->assignmentValidations.firstElement;
    for (asnMAXUINT countassignmentValidations=0; countassignmentValidations<object->assignmentValidations.count; countassignmentValidations++)
    {
      assignmentValidations.addElement(new asncassignmentValidationss(*elt_asncassignmentValidationss));
      elt_asncassignmentValidationss = (asncassignmentValidationss*) elt_asncassignmentValidationss->nextElement;
    }
 }
}

/**
 *    TypeAssignment : InventoryInstruction
 *    Class constructor
 */
InventoryInstruction::InventoryInstruction(const InventoryInstruction& object)
  : asntype()  ,inventoryInstructionVersion()
  ,ecuInstructions()

{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : InventoryInstruction
 * Copy method
 */
void InventoryInstruction::__copy (const asntype& obj)
{
  const InventoryInstruction* object = asnSCast(const InventoryInstruction*,&obj);
 {
    this->inventoryInstructionVersion.__copy (object->inventoryInstructionVersion);
 }
 {
    asncInventoryInstruction__ecuInstructionss *elt_asncInventoryInstruction__ecuInstructionss;
    elt_asncInventoryInstruction__ecuInstructionss = (asncInventoryInstruction__ecuInstructionss*) object->ecuInstructions.firstElement;
    for (asnMAXUINT countecuInstructions=0; countecuInstructions<object->ecuInstructions.count; countecuInstructions++)
    {
      ecuInstructions.addElement(new asncInventoryInstruction__ecuInstructionss(*elt_asncInventoryInstruction__ecuInstructionss));
      elt_asncInventoryInstruction__ecuInstructionss = (asncInventoryInstruction__ecuInstructionss*) elt_asncInventoryInstruction__ecuInstructionss->nextElement;
    }
 }
}

/**
 *    TypeAssignment : LanguageSetting
 *    Class constructor
 */
LanguageSetting::LanguageSetting(const LanguageSetting& object)
  : asntype()  ,language()

{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : LanguageSetting
 * Copy method
 */
void LanguageSetting::__copy (const asntype& obj)
{
  const LanguageSetting* object = asnSCast(const LanguageSetting*,&obj);
 {
    language = object->language;
 }
}

/**
 *    TypeAssignment : Ma
 *    Class constructor
 */
Ma::Ma(const Ma& object)
  : asntype()  ,maId()
  ,maVersion()

{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : Ma
 * Copy method
 */
void Ma::__copy (const asntype& obj)
{
  const Ma* object = asnSCast(const Ma*,&obj);
 {
    maId = object->maId;
 }
 {
    maVersion = object->maVersion;
 }
}

/**
 *    TypeAssignment : MaSetting
 *    Class constructor
 */
MaSetting::MaSetting(const MaSetting& object)
  : asntype()  ,collectFunction()
  ,authorizationStatus()

{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : MaSetting
 * Copy method
 */
void MaSetting::__copy (const asntype& obj)
{
  const MaSetting* object = asnSCast(const MaSetting*,&obj);
 {
    collectFunction = object->collectFunction;
 }
 {
    if(object->authorizationStatus != (AuthorizationStatus *)asnBNULL)
    {
      authorizationStatus = (AuthorizationStatus*)object->authorizationStatus->__create();
      authorizationStatus->__copy(*object->authorizationStatus);
    }
    else
    {
      authorizationStatus = (AuthorizationStatus *) 0;
    }
 }
}

/**
 *    TypeAssignment : MaSynchronization
 *    Class constructor
 */
MaSynchronization::MaSynchronization(const MaSynchronization& object)
  : asntype()  ,optional(object.optional.length, optionalField)
  ,removeMas()
  ,newMas()
  ,serviceParameters()

{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : MaSynchronization
 * Copy method
 */
void MaSynchronization::__copy (const asntype& obj)
{
  const MaSynchronization* object = asnSCast(const MaSynchronization*,&obj);
  optionalField[0] = object->optionalField[0];
 {
    if(asnGetPresence(object->optionalField,asn_removeMas) != asnFALSE)
    {
      asncremoveMass *elt_asncremoveMass;
      elt_asncremoveMass = (asncremoveMass*) object->removeMas.firstElement;
      for (asnMAXUINT countremoveMas=0; countremoveMas<object->removeMas.count; countremoveMas++)
      {
        removeMas.addElement(new asncremoveMass(*elt_asncremoveMass));
        elt_asncremoveMass = (asncremoveMass*) elt_asncremoveMass->nextElement;
      }
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_newMas) != asnFALSE)
    {
      asncnewMass *elt_asncnewMass;
      elt_asncnewMass = (asncnewMass*) object->newMas.firstElement;
      for (asnMAXUINT countnewMas=0; countnewMas<object->newMas.count; countnewMas++)
      {
        newMas.addElement(new asncnewMass(*elt_asncnewMass));
        elt_asncnewMass = (asncnewMass*) elt_asncnewMass->nextElement;
      }
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_MaSynchronization__serviceParameters) != asnFALSE)
    {
      asncMaSynchronization__serviceParameterss *elt_asncMaSynchronization__serviceParameterss;
      elt_asncMaSynchronization__serviceParameterss = (asncMaSynchronization__serviceParameterss*) object->serviceParameters.firstElement;
      for (asnMAXUINT countserviceParameters=0; countserviceParameters<object->serviceParameters.count; countserviceParameters++)
      {
        serviceParameters.addElement(new asncMaSynchronization__serviceParameterss(*elt_asncMaSynchronization__serviceParameterss));
        elt_asncMaSynchronization__serviceParameterss = (asncMaSynchronization__serviceParameterss*) elt_asncMaSynchronization__serviceParameterss->nextElement;
      }
    }
 }
}

/**
 *    TypeAssignment : MaSynchronizationReq
 *    Class constructor
 */
MaSynchronizationReq::MaSynchronizationReq(const MaSynchronizationReq& object)
  : asntype()  ,optional(object.optional.length, optionalField)
  ,storageQuota()
  ,maFormatVersion()
  ,installedMa()
  ,serviceParameters()

{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : MaSynchronizationReq
 * Copy method
 */
void MaSynchronizationReq::__copy (const asntype& obj)
{
  const MaSynchronizationReq* object = asnSCast(const MaSynchronizationReq*,&obj);
  optionalField[0] = object->optionalField[0];
 {
    storageQuota = object->storageQuota;
 }
 {
    maFormatVersion = object->maFormatVersion;
 }
 {
    if(asnGetPresence(object->optionalField,asn_installedMa) != asnFALSE)
    {
      asncinstalledMas *elt_asncinstalledMas;
      elt_asncinstalledMas = (asncinstalledMas*) object->installedMa.firstElement;
      for (asnMAXUINT countinstalledMa=0; countinstalledMa<object->installedMa.count; countinstalledMa++)
      {
        installedMa.addElement(new asncinstalledMas(*elt_asncinstalledMas));
        elt_asncinstalledMas = (asncinstalledMas*) elt_asncinstalledMas->nextElement;
      }
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_MaSynchronizationReq__serviceParameters) != asnFALSE)
    {
      asncMaSynchronizationReq__serviceParameterss *elt_asncMaSynchronizationReq__serviceParameterss;
      elt_asncMaSynchronizationReq__serviceParameterss = (asncMaSynchronizationReq__serviceParameterss*) object->serviceParameters.firstElement;
      for (asnMAXUINT countserviceParameters=0; countserviceParameters<object->serviceParameters.count; countserviceParameters++)
      {
        serviceParameters.addElement(new asncMaSynchronizationReq__serviceParameterss(*elt_asncMaSynchronizationReq__serviceParameterss));
        elt_asncMaSynchronizationReq__serviceParameterss = (asncMaSynchronizationReq__serviceParameterss*) elt_asncMaSynchronizationReq__serviceParameterss->nextElement;
      }
    }
 }
}

/**
 *    TypeAssignment : Mdp
 *    Class constructor
 */
Mdp::Mdp(const Mdp& object)
  : asntype()  ,optional(object.optional.length, optionalField)
  ,mdpFormatVersion()
  ,vin()
  ,ma()
  ,sequenceNumber()
  ,timestampReadOutStart()
  ,udsTriggerId()
  ,diagnosticResponse()

{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : Mdp
 * Copy method
 */
void Mdp::__copy (const asntype& obj)
{
  const Mdp* object = asnSCast(const Mdp*,&obj);
  optionalField[0] = object->optionalField[0];
 {
    mdpFormatVersion = object->mdpFormatVersion;
 }
 {
    this->vin.__copy (object->vin);
 }
 {
    if(object->ma != (Ma *)asnBNULL)
    {
      ma = (Ma*)object->ma->__create();
      ma->__copy(*object->ma);
    }
    else
    {
      ma = (Ma *) 0;
    }
 }
 {
    sequenceNumber = object->sequenceNumber;
 }
 {
    this->timestampReadOutStart.__copy (object->timestampReadOutStart);
 }
 {
    if(asnGetPresence(object->optionalField,asn_udsTriggerId) != asnFALSE)
    {
      this->udsTriggerId.__copy (object->udsTriggerId);
    }
 }
 {
    this->diagnosticResponse.__copy (object->diagnosticResponse);
 }
}

/**
 *    TypeAssignment : MeasurementAssignment
 *    Class constructor
 */
MeasurementAssignment::MeasurementAssignment(const MeasurementAssignment& object)
  : asntype()  ,optional(object.optional.length, optionalField)
  ,maId()
  ,maVersion()
  ,vin()
  ,maFormatVersion()
  ,maExecutionPriority()
  ,telematicsParameters()
  ,usageModesAllowed()
  ,startCondition()
  ,stopCondition()
  ,retentiondate()
  ,authorizationStatus()
  ,executionTrigger()
  ,ecusAndPartNumbers()
  ,diagnosticCommand()
  ,dataIntegrityCheck()
  ,serviceParameters()

{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : MeasurementAssignment
 * Copy method
 */
void MeasurementAssignment::__copy (const asntype& obj)
{
  const MeasurementAssignment* object = asnSCast(const MeasurementAssignment*,&obj);
  optionalField[0] = object->optionalField[0];
 {
    maId = object->maId;
 }
 {
    maVersion = object->maVersion;
 }
 {
    this->vin.__copy (object->vin);
 }
 {
    maFormatVersion = object->maFormatVersion;
 }
 {
    maExecutionPriority = object->maExecutionPriority;
 }
 {
    if(object->telematicsParameters != (TelematicsParameters *)asnBNULL)
    {
      telematicsParameters = (TelematicsParameters*)object->telematicsParameters->__create();
      telematicsParameters->__copy(*object->telematicsParameters);
    }
    else
    {
      telematicsParameters = (TelematicsParameters *) 0;
    }
 }
 {
    usageModesAllowed = object->usageModesAllowed;
 }
 {
    this->startCondition.__copy (object->startCondition);
 }
 {
    if(object->stopCondition != (StopCondition *)asnBNULL)
    {
      stopCondition = (StopCondition*)object->stopCondition->__create();
      stopCondition->__copy(*object->stopCondition);
    }
    else
    {
      stopCondition = (StopCondition *) 0;
    }
 }
 {
    this->retentiondate.__copy (object->retentiondate);
 }
 {
    if(object->authorizationStatus != (AuthorizationStatus *)asnBNULL)
    {
      authorizationStatus = (AuthorizationStatus*)object->authorizationStatus->__create();
      authorizationStatus->__copy(*object->authorizationStatus);
    }
    else
    {
      authorizationStatus = (AuthorizationStatus *) 0;
    }
 }
 {
    if(object->executionTrigger != (ExecutionTrigger *)asnBNULL)
    {
      executionTrigger = (ExecutionTrigger*)object->executionTrigger->__create();
      executionTrigger->__copy(*object->executionTrigger);
    }
    else
    {
      executionTrigger = (ExecutionTrigger *) 0;
    }
 }
 {
    asncecusAndPartNumberss *elt_asncecusAndPartNumberss;
    elt_asncecusAndPartNumberss = (asncecusAndPartNumberss*) object->ecusAndPartNumbers.firstElement;
    for (asnMAXUINT countecusAndPartNumbers=0; countecusAndPartNumbers<object->ecusAndPartNumbers.count; countecusAndPartNumbers++)
    {
      ecusAndPartNumbers.addElement(new asncecusAndPartNumberss(*elt_asncecusAndPartNumberss));
      elt_asncecusAndPartNumberss = (asncecusAndPartNumberss*) elt_asncecusAndPartNumberss->nextElement;
    }
 }
 {
    asncdiagnosticCommands *elt_asncdiagnosticCommands;
    elt_asncdiagnosticCommands = (asncdiagnosticCommands*) object->diagnosticCommand.firstElement;
    for (asnMAXUINT countdiagnosticCommand=0; countdiagnosticCommand<object->diagnosticCommand.count; countdiagnosticCommand++)
    {
      diagnosticCommand.addElement(new asncdiagnosticCommands(*elt_asncdiagnosticCommands));
      elt_asncdiagnosticCommands = (asncdiagnosticCommands*) elt_asncdiagnosticCommands->nextElement;
    }
 }
 {
    this->dataIntegrityCheck.__copy (object->dataIntegrityCheck);
 }
 {
    if(asnGetPresence(object->optionalField,asn_MeasurementAssignment__serviceParameters) != asnFALSE)
    {
      asncMeasurementAssignment__serviceParameterss *elt_asncMeasurementAssignment__serviceParameterss;
      elt_asncMeasurementAssignment__serviceParameterss = (asncMeasurementAssignment__serviceParameterss*) object->serviceParameters.firstElement;
      for (asnMAXUINT countserviceParameters=0; countserviceParameters<object->serviceParameters.count; countserviceParameters++)
      {
        serviceParameters.addElement(new asncMeasurementAssignment__serviceParameterss(*elt_asncMeasurementAssignment__serviceParameterss));
        elt_asncMeasurementAssignment__serviceParameterss = (asncMeasurementAssignment__serviceParameterss*) elt_asncMeasurementAssignment__serviceParameterss->nextElement;
      }
    }
 }
}

/**
 *    TypeAssignment : MeasurementDataPackage
 *    Class constructor
 */
MeasurementDataPackage::MeasurementDataPackage(const MeasurementDataPackage& object)
  : asntype()  ,optional(object.optional.length, optionalField)
  ,telematicsParameters()
  ,serviceParameters()
  ,mdp()

{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : MeasurementDataPackage
 * Copy method
 */
void MeasurementDataPackage::__copy (const asntype& obj)
{
  const MeasurementDataPackage* object = asnSCast(const MeasurementDataPackage*,&obj);
  optionalField[0] = object->optionalField[0];
 {
    if(object->telematicsParameters != (TelematicsParameters *)asnBNULL)
    {
      telematicsParameters = (TelematicsParameters*)object->telematicsParameters->__create();
      telematicsParameters->__copy(*object->telematicsParameters);
    }
    else
    {
      telematicsParameters = (TelematicsParameters *) 0;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_MeasurementDataPackage__serviceParameters) != asnFALSE)
    {
      asncMeasurementDataPackage__serviceParameterss *elt_asncMeasurementDataPackage__serviceParameterss;
      elt_asncMeasurementDataPackage__serviceParameterss = (asncMeasurementDataPackage__serviceParameterss*) object->serviceParameters.firstElement;
      for (asnMAXUINT countserviceParameters=0; countserviceParameters<object->serviceParameters.count; countserviceParameters++)
      {
        serviceParameters.addElement(new asncMeasurementDataPackage__serviceParameterss(*elt_asncMeasurementDataPackage__serviceParameterss));
        elt_asncMeasurementDataPackage__serviceParameterss = (asncMeasurementDataPackage__serviceParameterss*) elt_asncMeasurementDataPackage__serviceParameterss->nextElement;
      }
    }
 }
 {
    if(object->mdp != (Mdp *)asnBNULL)
    {
      mdp = (Mdp*)object->mdp->__create();
      mdp->__copy(*object->mdp);
    }
    else
    {
      mdp = (Mdp *) 0;
    }
 }
}

/**
 *    TypeAssignment : OtaAssignmentFileInfo
 *    Class constructor
 */
OtaAssignmentFileInfo::OtaAssignmentFileInfo(const OtaAssignmentFileInfo& object)
  : asntype()  ,installationOrderId()
  ,assignFileInfos()

{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : OtaAssignmentFileInfo
 * Copy method
 */
void OtaAssignmentFileInfo::__copy (const asntype& obj)
{
  const OtaAssignmentFileInfo* object = asnSCast(const OtaAssignmentFileInfo*,&obj);
 {
    this->installationOrderId.__copy (object->installationOrderId);
 }
 {
    asncassignFileInfoss *elt_asncassignFileInfoss;
    elt_asncassignFileInfoss = (asncassignFileInfoss*) object->assignFileInfos.firstElement;
    for (asnMAXUINT countassignFileInfos=0; countassignFileInfos<object->assignFileInfos.count; countassignFileInfos++)
    {
      assignFileInfos.addElement(new asncassignFileInfoss(*elt_asncassignFileInfoss));
      elt_asncassignFileInfoss = (asncassignFileInfoss*) elt_asncassignFileInfoss->nextElement;
    }
 }
}

/**
 *    TypeAssignment : RVDC
 *    Class constructor
 */
RVDC::RVDC(const RVDC& object)
  : asntype()  ,optional(object.optional.length, optionalField)
  ,appId()
  ,maOrderId()
  ,timestamp()
  ,vin()
  ,maBusinessType()
  ,rvdcSetting()
  ,assignmentNotification()
  ,maSynchronizationReq()
  ,maSynchronization()
  ,exceptionHandling()
  ,measurementDataPackage()

{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : RVDC
 * Copy method
 */
void RVDC::__copy (const asntype& obj)
{
  const RVDC* object = asnSCast(const RVDC*,&obj);
  optionalField[0] = object->optionalField[0];
 {
    appId = object->appId;
 }
 {
    this->maOrderId.__copy (object->maOrderId);
 }
 {
    this->timestamp.__copy (object->timestamp);
 }
 {
    this->vin.__copy (object->vin);
 }
 {
    maBusinessType = object->maBusinessType;
 }
 {
    if(asnGetPresence(object->optionalField,asn_RVDC__rvdcSetting) != asnFALSE)
    {
      if(object->rvdcSetting != (RvdcSetting *)asnBNULL)
      {
        rvdcSetting = (RvdcSetting*)object->rvdcSetting->__create();
        rvdcSetting->__copy(*object->rvdcSetting);
      }
      else
      {
        rvdcSetting = (RvdcSetting *) 0;
      }
    }
    else
    {
      this->rvdcSetting = (RvdcSetting*) asnBNULL;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_RVDC__assignmentNotification) != asnFALSE)
    {
      if(object->assignmentNotification != (RvdcAssignmentNotification *)asnBNULL)
      {
        assignmentNotification = (RvdcAssignmentNotification*)object->assignmentNotification->__create();
        assignmentNotification->__copy(*object->assignmentNotification);
      }
      else
      {
        assignmentNotification = (RvdcAssignmentNotification *) 0;
      }
    }
    else
    {
      this->assignmentNotification = (RvdcAssignmentNotification*) asnBNULL;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_RVDC__maSynchronizationReq) != asnFALSE)
    {
      if(object->maSynchronizationReq != (MaSynchronizationReq *)asnBNULL)
      {
        maSynchronizationReq = (MaSynchronizationReq*)object->maSynchronizationReq->__create();
        maSynchronizationReq->__copy(*object->maSynchronizationReq);
      }
      else
      {
        maSynchronizationReq = (MaSynchronizationReq *) 0;
      }
    }
    else
    {
      this->maSynchronizationReq = (MaSynchronizationReq*) asnBNULL;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_RVDC__maSynchronization) != asnFALSE)
    {
      if(object->maSynchronization != (MaSynchronization *)asnBNULL)
      {
        maSynchronization = (MaSynchronization*)object->maSynchronization->__create();
        maSynchronization->__copy(*object->maSynchronization);
      }
      else
      {
        maSynchronization = (MaSynchronization *) 0;
      }
    }
    else
    {
      this->maSynchronization = (MaSynchronization*) asnBNULL;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_RVDC__exceptionHandling) != asnFALSE)
    {
      if(object->exceptionHandling != (RvdcExceptionHandling *)asnBNULL)
      {
        exceptionHandling = (RvdcExceptionHandling*)object->exceptionHandling->__create();
        exceptionHandling->__copy(*object->exceptionHandling);
      }
      else
      {
        exceptionHandling = (RvdcExceptionHandling *) 0;
      }
    }
    else
    {
      this->exceptionHandling = (RvdcExceptionHandling*) asnBNULL;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_RVDC__measurementDataPackage) != asnFALSE)
    {
      if(object->measurementDataPackage != (MeasurementDataPackage *)asnBNULL)
      {
        measurementDataPackage = (MeasurementDataPackage*)object->measurementDataPackage->__create();
        measurementDataPackage->__copy(*object->measurementDataPackage);
      }
      else
      {
        measurementDataPackage = (MeasurementDataPackage *) 0;
      }
    }
    else
    {
      this->measurementDataPackage = (MeasurementDataPackage*) asnBNULL;
    }
 }
}

/**
 *    TypeAssignment : RvdcAssignmentNotification
 *    Class constructor
 */
RvdcAssignmentNotification::RvdcAssignmentNotification(const RvdcAssignmentNotification& object)
  : asntype()  ,optional(object.optional.length, optionalField)
  ,maCarId()
  ,maVersion()
  ,newStatus()
  ,timestamp()
  ,reason()

{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : RvdcAssignmentNotification
 * Copy method
 */
void RvdcAssignmentNotification::__copy (const asntype& obj)
{
  const RvdcAssignmentNotification* object = asnSCast(const RvdcAssignmentNotification*,&obj);
  optionalField[0] = object->optionalField[0];
 {
    if(asnGetPresence(object->optionalField,asn_maCarId) != asnFALSE)
    {
      maCarId = object->maCarId;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_maVersion) != asnFALSE)
    {
      maVersion = object->maVersion;
    }
 }
 {
    this->newStatus.__copy (object->newStatus);
 }
 {
    this->timestamp.__copy (object->timestamp);
 }
 {
    if(asnGetPresence(object->optionalField,asn_RvdcAssignmentNotification__reason) != asnFALSE)
    {
      this->reason.__copy (object->reason);
    }
 }
}

/**
 *    TypeAssignment : RvdcExceptionHandling
 *    Class constructor
 */
RvdcExceptionHandling::RvdcExceptionHandling(const RvdcExceptionHandling& object)
  : asntype()  ,optional(object.optional.length, optionalField)
  ,exceptionName()
  ,description()
  ,publisher()
  ,severity()
  ,impact()
  ,action()

{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : RvdcExceptionHandling
 * Copy method
 */
void RvdcExceptionHandling::__copy (const asntype& obj)
{
  const RvdcExceptionHandling* object = asnSCast(const RvdcExceptionHandling*,&obj);
  optionalField[0] = object->optionalField[0];
 {
    this->exceptionName.__copy (object->exceptionName);
 }
 {
    this->description.__copy (object->description);
 }
 {
    this->publisher.__copy (object->publisher);
 }
 {
    if(asnGetPresence(object->optionalField,asn_severity) != asnFALSE)
    {
      this->severity.__copy (object->severity);
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_impact) != asnFALSE)
    {
      this->impact.__copy (object->impact);
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_RvdcExceptionHandling__action) != asnFALSE)
    {
      this->action.__copy (object->action);
    }
 }
}

/**
 *    TypeAssignment : RvdcForcedSetting
 *    Class constructor
 */
RvdcForcedSetting::RvdcForcedSetting(const RvdcForcedSetting& object)
  : asntype()  ,visibility()
  ,suppress()
  ,lock()

{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : RvdcForcedSetting
 * Copy method
 */
void RvdcForcedSetting::__copy (const asntype& obj)
{
  const RvdcForcedSetting* object = asnSCast(const RvdcForcedSetting*,&obj);
 {
    visibility = object->visibility;
 }
 {
    suppress = object->suppress;
 }
 {
    lock = object->lock;
 }
}

/**
 *    TypeAssignment : RvdcSetting
 *    Class constructor
 */
RvdcSetting::RvdcSetting(const RvdcSetting& object)
  : asntype()  ,optional(object.optional.length, optionalField)
  ,maSetting()
  ,vehicleSetting()
  ,languageSetting()
  ,forcedSetting()
  ,serviceParameters()

{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : RvdcSetting
 * Copy method
 */
void RvdcSetting::__copy (const asntype& obj)
{
  const RvdcSetting* object = asnSCast(const RvdcSetting*,&obj);
  optionalField[0] = object->optionalField[0];
 {
    if(asnGetPresence(object->optionalField,asn_maSetting) != asnFALSE)
    {
      if(object->maSetting != (MaSetting *)asnBNULL)
      {
        maSetting = (MaSetting*)object->maSetting->__create();
        maSetting->__copy(*object->maSetting);
      }
      else
      {
        maSetting = (MaSetting *) 0;
      }
    }
    else
    {
      this->maSetting = (MaSetting*) asnBNULL;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_vehicleSetting) != asnFALSE)
    {
      if(object->vehicleSetting != (RvdcVehicleSetting *)asnBNULL)
      {
        vehicleSetting = (RvdcVehicleSetting*)object->vehicleSetting->__create();
        vehicleSetting->__copy(*object->vehicleSetting);
      }
      else
      {
        vehicleSetting = (RvdcVehicleSetting *) 0;
      }
    }
    else
    {
      this->vehicleSetting = (RvdcVehicleSetting*) asnBNULL;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_languageSetting) != asnFALSE)
    {
      if(object->languageSetting != (LanguageSetting *)asnBNULL)
      {
        languageSetting = (LanguageSetting*)object->languageSetting->__create();
        languageSetting->__copy(*object->languageSetting);
      }
      else
      {
        languageSetting = (LanguageSetting *) 0;
      }
    }
    else
    {
      this->languageSetting = (LanguageSetting*) asnBNULL;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_forcedSetting) != asnFALSE)
    {
      if(object->forcedSetting != (RvdcForcedSetting *)asnBNULL)
      {
        forcedSetting = (RvdcForcedSetting*)object->forcedSetting->__create();
        forcedSetting->__copy(*object->forcedSetting);
      }
      else
      {
        forcedSetting = (RvdcForcedSetting *) 0;
      }
    }
    else
    {
      this->forcedSetting = (RvdcForcedSetting*) asnBNULL;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_RvdcSetting__serviceParameters) != asnFALSE)
    {
      asncRvdcSetting__serviceParameterss *elt_asncRvdcSetting__serviceParameterss;
      elt_asncRvdcSetting__serviceParameterss = (asncRvdcSetting__serviceParameterss*) object->serviceParameters.firstElement;
      for (asnMAXUINT countserviceParameters=0; countserviceParameters<object->serviceParameters.count; countserviceParameters++)
      {
        serviceParameters.addElement(new asncRvdcSetting__serviceParameterss(*elt_asncRvdcSetting__serviceParameterss));
        elt_asncRvdcSetting__serviceParameterss = (asncRvdcSetting__serviceParameterss*) elt_asncRvdcSetting__serviceParameterss->nextElement;
      }
    }
 }
}

/**
 *    TypeAssignment : RvdcVehicleSetting
 *    Class constructor
 */
RvdcVehicleSetting::RvdcVehicleSetting(const RvdcVehicleSetting& object)
  : asntype()  ,rvdcFunction()
  ,collectOffSetTime()

{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : RvdcVehicleSetting
 * Copy method
 */
void RvdcVehicleSetting::__copy (const asntype& obj)
{
  const RvdcVehicleSetting* object = asnSCast(const RvdcVehicleSetting*,&obj);
 {
    rvdcFunction = object->rvdcFunction;
 }
 {
    collectOffSetTime = object->collectOffSetTime;
 }
}

/**
 *    TypeAssignment : SoftwarePartInstallationInstruction
 *    Class constructor
 */
SoftwarePartInstallationInstruction::SoftwarePartInstallationInstruction(const SoftwarePartInstallationInstruction& object)
  : asntype()  ,partidentifier()
  ,estimatedInstallationtime()

{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : SoftwarePartInstallationInstruction
 * Copy method
 */
void SoftwarePartInstallationInstruction::__copy (const asntype& obj)
{
  const SoftwarePartInstallationInstruction* object = asnSCast(const SoftwarePartInstallationInstruction*,&obj);
 {
    this->partidentifier.__copy (object->partidentifier);
 }
 {
    estimatedInstallationtime = object->estimatedInstallationtime;
 }
}

/**
 *    TypeAssignment : SoftwarePartSummary
 *    Class constructor
 */
SoftwarePartSummary::SoftwarePartSummary(const SoftwarePartSummary& object)
  : asntype()  ,partIdentifier()
  ,partRetries()
  ,measuredInstallationTime()
  ,softwarePartStatus()

{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : SoftwarePartSummary
 * Copy method
 */
void SoftwarePartSummary::__copy (const asntype& obj)
{
  const SoftwarePartSummary* object = asnSCast(const SoftwarePartSummary*,&obj);
 {
    this->partIdentifier.__copy (object->partIdentifier);
 }
 {
    partRetries = object->partRetries;
 }
 {
    measuredInstallationTime = object->measuredInstallationTime;
 }
 {
    this->softwarePartStatus.__copy (object->softwarePartStatus);
 }
}

/**
 *    TypeAssignment : StopCondition
 *    Class constructor
 */
StopCondition::StopCondition(const StopCondition& object)
  : asntype()  ,optional(object.optional.length, optionalField)
  ,period()
  ,amount()
  ,time()

{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : StopCondition
 * Copy method
 */
void StopCondition::__copy (const asntype& obj)
{
  const StopCondition* object = asnSCast(const StopCondition*,&obj);
  optionalField[0] = object->optionalField[0];
 {
    if(asnGetPresence(object->optionalField,asn_period) != asnFALSE)
    {
      period = object->period;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_amount) != asnFALSE)
    {
      amount = object->amount;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_StopCondition__time) != asnFALSE)
    {
      this->time.__copy (object->time);
    }
 }
}

/**
 *    TypeAssignment : TelematicsParameters
 *    Class constructor
 */
TelematicsParameters::TelematicsParameters(const TelematicsParameters& object)
  : asntype()  ,timeToLive()
  ,uploadPriority()

{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : TelematicsParameters
 * Copy method
 */
void TelematicsParameters::__copy (const asntype& obj)
{
  const TelematicsParameters* object = asnSCast(const TelematicsParameters*,&obj);
 {
    timeToLive = object->timeToLive;
 }
 {
    uploadPriority = object->uploadPriority;
 }
}

/**
 *    TypeAssignment : Trigger
 *    Class constructor
 */
Trigger::Trigger(const Trigger& object)
  : asntype()  ,trigger()
  ,interval()

{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : Trigger
 * Copy method
 */
void Trigger::__copy (const asntype& obj)
{
  const Trigger* object = asnSCast(const Trigger*,&obj);
 {
    trigger = object->trigger;
 }
 {
    interval = object->interval;
 }
}

/**
 *    TypeAssignment : UDS
 *    Class constructor
 */
UDS::UDS(const UDS& object)
  : asntype()  ,a__operator()
  ,delayForNextTriggerCheck()
  ,delayAfterCollection()
  ,diagnosticCommands()

{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : UDS
 * Copy method
 */
void UDS::__copy (const asntype& obj)
{
  const UDS* object = asnSCast(const UDS*,&obj);
 {
    a__operator = object->a__operator;
 }
 {
    delayForNextTriggerCheck = object->delayForNextTriggerCheck;
 }
 {
    delayAfterCollection = object->delayAfterCollection;
 }
 {
    asncdiagnosticCommandss *elt_asncdiagnosticCommandss;
    elt_asncdiagnosticCommandss = (asncdiagnosticCommandss*) object->diagnosticCommands.firstElement;
    for (asnMAXUINT countdiagnosticCommands=0; countdiagnosticCommands<object->diagnosticCommands.count; countdiagnosticCommands++)
    {
      diagnosticCommands.addElement(new asncdiagnosticCommandss(*elt_asncdiagnosticCommandss));
      elt_asncdiagnosticCommandss = (asncdiagnosticCommandss*) elt_asncdiagnosticCommandss->nextElement;
    }
 }
}

/**
 *    TypeAssignment : ValidationKey
 *    Class constructor
 */
ValidationKey::ValidationKey(const ValidationKey& object)
  : asntype()  ,optional(object.optional.length, optionalField)
  ,validationKey()
  ,partIdentifiers()

{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : ValidationKey
 * Copy method
 */
void ValidationKey::__copy (const asntype& obj)
{
  const ValidationKey* object = asnSCast(const ValidationKey*,&obj);
  optionalField[0] = object->optionalField[0];
 {
    this->validationKey.__copy (object->validationKey);
 }
 {
    if(asnGetPresence(object->optionalField,asn_partIdentifiers) != asnFALSE)
    {
      asncpartIdentifierss *elt_asncpartIdentifierss;
      elt_asncpartIdentifierss = (asncpartIdentifierss*) object->partIdentifiers.firstElement;
      for (asnMAXUINT countpartIdentifiers=0; countpartIdentifiers<object->partIdentifiers.count; countpartIdentifiers++)
      {
        partIdentifiers.addElement(new asncpartIdentifierss(*elt_asncpartIdentifierss));
        elt_asncpartIdentifierss = (asncpartIdentifierss*) elt_asncpartIdentifierss->nextElement;
      }
    }
 }
}

/**
 *    TypeAssignment : DIDData
 *    Class constructor
 */
DIDData::DIDData(const DIDData& object)
  : asntype()  ,id()
  ,data()

{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : DIDData
 * Copy method
 */
void DIDData::__copy (const asntype& obj)
{
  const DIDData* object = asnSCast(const DIDData*,&obj);
 {
    id = object->id;
 }
 {
    this->data.__copy(object->data);
 }
}

/**
 *    TypeAssignment : DTCData
 *    Class constructor
 */
DTCData::DTCData(const DTCData& object)
  : asntype()  ,id()
  ,data()

{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : DTCData
 * Copy method
 */
void DTCData::__copy (const asntype& obj)
{
  const DTCData* object = asnSCast(const DTCData*,&obj);
 {
    id = object->id;
 }
 {
    this->data.__copy(object->data);
 }
}

/**
 *    TypeAssignment : ECUData
 *    Class constructor
 */
ECUData::ECUData(const ECUData& object)
  : asntype()  ,ecu()
  ,diagnosticNumber()
  ,didData()
  ,dtcData()

{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : ECUData
 * Copy method
 */
void ECUData::__copy (const asntype& obj)
{
  const ECUData* object = asnSCast(const ECUData*,&obj);
 {
    ecu = object->ecu;
 }
 {
    this->diagnosticNumber.__copy (object->diagnosticNumber);
 }
 {
    asncdidDatas *elt_asncdidDatas;
    elt_asncdidDatas = (asncdidDatas*) object->didData.firstElement;
    for (asnMAXUINT countdidData=0; countdidData<object->didData.count; countdidData++)
    {
      didData.addElement(new asncdidDatas(*elt_asncdidDatas));
      elt_asncdidDatas = (asncdidDatas*) elt_asncdidDatas->nextElement;
    }
 }
 {
    asncdtcDatas *elt_asncdtcDatas;
    elt_asncdtcDatas = (asncdtcDatas*) object->dtcData.firstElement;
    for (asnMAXUINT countdtcData=0; countdtcData<object->dtcData.count; countdtcData++)
    {
      dtcData.addElement(new asncdtcDatas(*elt_asncdtcDatas));
      elt_asncdtcDatas = (asncdtcDatas*) elt_asncdtcDatas->nextElement;
    }
 }
}

/**
 *    TypeAssignment : EcuData__C
 *    Class constructor
 */
asncnoDiagData::asncnoDiagData(const asncnoDiagData& object)
  :EcuData__C(object.alternative),noDiagData()
{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : EcuData__C
 * Copy method
 */
void asncnoDiagData::__copy (const asntype& obj)
{
  const asncnoDiagData* object = asnSCast(const asncnoDiagData*,&obj);
  asnDUMMY(object);
}
/**
 *    TypeAssignment : EcuData__C
 *    Class constructor
 */
asncEcuData__data::asncEcuData__data(const asncEcuData__data& object)
  :EcuData__C(object.alternative),data()
{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : EcuData__C
 * Copy method
 */
void asncEcuData__data::__copy (const asntype& obj)
{
  const asncEcuData__data* object = asnSCast(const asncEcuData__data*,&obj);
  asncdatas *elt_asncdatas;
  elt_asncdatas = (asncdatas*) object->data.firstElement;
  for (asnMAXUINT countdata=0; countdata<object->data.count; countdata++)
  {
    data.addElement(new asncdatas(*elt_asncdatas));
    elt_asncdatas = (asncdatas*) elt_asncdatas->nextElement;
  }
}
/**
 *    TypeAssignment : EcuData
 *    Class constructor
 */
EcuData::EcuData(const EcuData& object)
  : asntype(),value(){
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : EcuData
 * Copy method
 */
void EcuData::__copy (const asntype& obj)
{
  const EcuData* object = asnSCast(const EcuData*,&obj);
  if(object->value != (EcuData__C *)asnBNULL)
  {
    switch(object->value->alternative)
    {
      case asn_noDiagData:
        this->value = new asncnoDiagData(*(asncnoDiagData*) object->value);
        break;
      case asn_EcuData__data:
        this->value = new asncEcuData__data(*(asncEcuData__data*) object->value);
        break;
      default: this->value = (EcuData__C *) 0;
    }
  }
  else
  {
    this->value = (EcuData__C *) 0;
  }
}

/**
 *    TypeAssignment : NEVCoordinatesLongLat
 *    Class constructor
 */
NEVCoordinatesLongLat::NEVCoordinatesLongLat(const NEVCoordinatesLongLat& object)
  : asntype()  ,longitude()
  ,latitude()

{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : NEVCoordinatesLongLat
 * Copy method
 */
void NEVCoordinatesLongLat::__copy (const asntype& obj)
{
  const NEVCoordinatesLongLat* object = asnSCast(const NEVCoordinatesLongLat*,&obj);
 {
    longitude = object->longitude;
 }
 {
    latitude = object->latitude;
 }
}

/**
 *    TypeAssignment : NEVDRPositionData
 *    Class constructor
 */
NEVDRPositionData::NEVDRPositionData(const NEVDRPositionData& object)
  : asntype()  ,longLat()
  ,heading()
  ,speedKmph()
  ,hdopX10()
  ,numSat()
  ,fixTime()
  ,fixType()
  ,drType()
  ,drDistance()

{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : NEVDRPositionData
 * Copy method
 */
void NEVDRPositionData::__copy (const asntype& obj)
{
  const NEVDRPositionData* object = asnSCast(const NEVDRPositionData*,&obj);
 {
    if(object->longLat != (NEVCoordinatesLongLat *)asnBNULL)
    {
      longLat = (NEVCoordinatesLongLat*)object->longLat->__create();
      longLat->__copy(*object->longLat);
    }
    else
    {
      longLat = (NEVCoordinatesLongLat *) 0;
    }
 }
 {
    heading = object->heading;
 }
 {
    speedKmph = object->speedKmph;
 }
 {
    hdopX10 = object->hdopX10;
 }
 {
    numSat = object->numSat;
 }
 {
    if(object->fixTime != (NEVDateTime *)asnBNULL)
    {
      fixTime = (NEVDateTime*)object->fixTime->__create();
      fixTime->__copy(*object->fixTime);
    }
    else
    {
      fixTime = (NEVDateTime *) 0;
    }
 }
 {
    fixType = object->fixType;
 }
 {
    drType = object->drType;
 }
 {
    drDistance = object->drDistance;
 }
}

/**
 *    TypeAssignment : NEVDRVehiclePosition__C
 *    Class constructor
 */
asncnoValidData::asncnoValidData(const asncnoValidData& object)
  :NEVDRVehiclePosition__C(object.alternative),noValidData()
{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : NEVDRVehiclePosition__C
 * Copy method
 */
void asncnoValidData::__copy (const asntype& obj)
{
  const asncnoValidData* object = asnSCast(const asncnoValidData*,&obj);
  asnDUMMY(object);
}
/**
 *    TypeAssignment : NEVDRVehiclePosition__C
 *    Class constructor
 */
asncdrPosition::asncdrPosition(const asncdrPosition& object)
  :NEVDRVehiclePosition__C(object.alternative)  ,longLat()
  ,heading()
  ,speedKmph()
  ,hdopX10()
  ,numSat()
  ,fixTime()
  ,fixType()
  ,drType()
  ,drDistance()

{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : NEVDRVehiclePosition__C
 * Copy method
 */
void asncdrPosition::__copy (const asntype& obj)
{
  const asncdrPosition* object = asnSCast(const asncdrPosition*,&obj);
 {
    if(object->longLat != (NEVCoordinatesLongLat *)asnBNULL)
    {
      longLat = (NEVCoordinatesLongLat*)object->longLat->__create();
      longLat->__copy(*object->longLat);
    }
    else
    {
      longLat = (NEVCoordinatesLongLat *) 0;
    }
 }
 {
    heading = object->heading;
 }
 {
    speedKmph = object->speedKmph;
 }
 {
    hdopX10 = object->hdopX10;
 }
 {
    numSat = object->numSat;
 }
 {
    if(object->fixTime != (NEVDateTime *)asnBNULL)
    {
      fixTime = (NEVDateTime*)object->fixTime->__create();
      fixTime->__copy(*object->fixTime);
    }
    else
    {
      fixTime = (NEVDateTime *) 0;
    }
 }
 {
    fixType = object->fixType;
 }
 {
    drType = object->drType;
 }
 {
    drDistance = object->drDistance;
 }
}
/**
 *    TypeAssignment : NEVDRVehiclePosition
 *    Class constructor
 */
NEVDRVehiclePosition::NEVDRVehiclePosition(const NEVDRVehiclePosition& object)
  : asntype(),value(){
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : NEVDRVehiclePosition
 * Copy method
 */
void NEVDRVehiclePosition::__copy (const asntype& obj)
{
  const NEVDRVehiclePosition* object = asnSCast(const NEVDRVehiclePosition*,&obj);
  if(object->value != (NEVDRVehiclePosition__C *)asnBNULL)
  {
    switch(object->value->alternative)
    {
      case asn_noValidData:
        this->value = new asncnoValidData(*(asncnoValidData*) object->value);
        break;
      case asn_drPosition:
        this->value = new asncdrPosition(*(asncdrPosition*) object->value);
        break;
      default: this->value = (NEVDRVehiclePosition__C *) 0;
    }
  }
  else
  {
    this->value = (NEVDRVehiclePosition__C *) 0;
  }
}

/**
 *    TypeAssignment : NEVDateTime
 *    Class constructor
 */
NEVDateTime::NEVDateTime(const NEVDateTime& object)
  : asntype()  ,year()
  ,month()
  ,day()
  ,hour()
  ,minute()
  ,second()

{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : NEVDateTime
 * Copy method
 */
void NEVDateTime::__copy (const asntype& obj)
{
  const NEVDateTime* object = asnSCast(const NEVDateTime*,&obj);
 {
    year = object->year;
 }
 {
    month = object->month;
 }
 {
    day = object->day;
 }
 {
    hour = object->hour;
 }
 {
    minute = object->minute;
 }
 {
    second = object->second;
 }
}

/**
 *    TypeAssignment : NEVServiceData
 *    Class constructor
 */
NEVServiceData::NEVServiceData(const NEVServiceData& object)
  : asntype()  ,vehicleVin()
  ,testVehicle()
  ,rvdcTriggerCondition()
  ,mdpID()
  ,maID()
  ,position()
  ,ecuData()

{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : NEVServiceData
 * Copy method
 */
void NEVServiceData::__copy (const asntype& obj)
{
  const NEVServiceData* object = asnSCast(const NEVServiceData*,&obj);
 {
    this->vehicleVin.__copy (object->vehicleVin);
 }
 {
    testVehicle = object->testVehicle;
 }
 {
    rvdcTriggerCondition = object->rvdcTriggerCondition;
 }
 {
    mdpID = object->mdpID;
 }
 {
    this->maID.__copy (object->maID);
 }
 {
    if(object->position != (NEVDRVehiclePosition__C *)asnBNULL)
    {
      switch(object->position->alternative)
      {
        case asn_noValidData:
          this->position = new asncnoValidData(*(asncnoValidData*) object->position);
          break;
        case asn_drPosition:
          this->position = new asncdrPosition(*(asncdrPosition*) object->position);
          break;
        default: this->position = (NEVDRVehiclePosition__C *) 0;
      }
    }
    else
    {
      this->position = (NEVDRVehiclePosition__C *) 0;
    }
 }
 {
    if(object->ecuData != (EcuData__C *)asnBNULL)
    {
      switch(object->ecuData->alternative)
      {
        case asn_noDiagData:
          this->ecuData = new asncnoDiagData(*(asncnoDiagData*) object->ecuData);
          break;
        case asn_EcuData__data:
          this->ecuData = new asncEcuData__data(*(asncEcuData__data*) object->ecuData);
          break;
        default: this->ecuData = (EcuData__C *) 0;
      }
    }
    else
    {
      this->ecuData = (EcuData__C *) 0;
    }
 }
}

/**
 *    TypeAssignment : Configuration
 *    Class constructor
 */
Configuration::Configuration(const Configuration& object)
  : asntype()  ,version()
  ,items()

{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : Configuration
 * Copy method
 */
void Configuration::__copy (const asntype& obj)
{
  const Configuration* object = asnSCast(const Configuration*,&obj);
 {
    this->version.__copy (object->version);
 }
 {
    asncConfiguration__itemss *elt_asncConfiguration__itemss;
    elt_asncConfiguration__itemss = (asncConfiguration__itemss*) object->items.firstElement;
    for (asnMAXUINT countitems=0; countitems<object->items.count; countitems++)
    {
      items.addElement(new asncConfiguration__itemss(*elt_asncConfiguration__itemss));
      elt_asncConfiguration__itemss = (asncConfiguration__itemss*) elt_asncConfiguration__itemss->nextElement;
    }
 }
}

/**
 *    TypeAssignment : ConfigurationItem
 *    Class constructor
 */
ConfigurationItem::ConfigurationItem(const ConfigurationItem& object)
  : asntype()  ,name()
  ,parameters()

{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : ConfigurationItem
 * Copy method
 */
void ConfigurationItem::__copy (const asntype& obj)
{
  const ConfigurationItem* object = asnSCast(const ConfigurationItem*,&obj);
 {
    this->name.__copy (object->name);
 }
 {
    asncConfigurationItem__parameterss *elt_asncConfigurationItem__parameterss;
    elt_asncConfigurationItem__parameterss = (asncConfigurationItem__parameterss*) object->parameters.firstElement;
    for (asnMAXUINT countparameters=0; countparameters<object->parameters.count; countparameters++)
    {
      parameters.addElement(new asncConfigurationItem__parameterss(*elt_asncConfigurationItem__parameterss));
      elt_asncConfigurationItem__parameterss = (asncConfigurationItem__parameterss*) elt_asncConfigurationItem__parameterss->nextElement;
    }
 }
}

/**
 *    TypeAssignment : ContactInfo
 *    Class constructor
 */
ContactInfo::ContactInfo(const ContactInfo& object)
  : asntype()  ,optional(object.optional.length, optionalField)
  ,email()
  ,address()
  ,phone1()
  ,phone2()

{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : ContactInfo
 * Copy method
 */
void ContactInfo::__copy (const asntype& obj)
{
  const ContactInfo* object = asnSCast(const ContactInfo*,&obj);
  optionalField[0] = object->optionalField[0];
 {
    if(asnGetPresence(object->optionalField,asn_email) != asnFALSE)
    {
      this->email.__copy (object->email);
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_address) != asnFALSE)
    {
      if(object->address != (PostAddress *)asnBNULL)
      {
        address = (PostAddress*)object->address->__create();
        address->__copy(*object->address);
      }
      else
      {
        address = (PostAddress *) 0;
      }
    }
    else
    {
      this->address = (PostAddress*) asnBNULL;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_phone1) != asnFALSE)
    {
      this->phone1.__copy (object->phone1);
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_phone2) != asnFALSE)
    {
      this->phone2.__copy (object->phone2);
    }
 }
}

/**
 *    TypeAssignment : Error
 *    Class constructor
 */
Error::Error(const Error& object)
  : asntype()  ,optional(object.optional.length, optionalField)
  ,code()
  ,vehicleErrorCode()
  ,message()

{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : Error
 * Copy method
 */
void Error::__copy (const asntype& obj)
{
  const Error* object = asnSCast(const Error*,&obj);
  optionalField[0] = object->optionalField[0];
 {
    code = object->code;
 }
 {
    if(asnGetPresence(object->optionalField,asn_vehicleErrorCode) != asnFALSE)
    {
      vehicleErrorCode = object->vehicleErrorCode;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_Error__message) != asnFALSE)
    {
      this->message.__copy (object->message);
    }
 }
}

/**
 *    TypeAssignment : EventAction
 *    Class constructor
 */
EventAction::EventAction(const EventAction& object)
  : asntype()  ,optional(object.optional.length, optionalField)
  ,triggerTimes()
  ,notifyInterval()

{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : EventAction
 * Copy method
 */
void EventAction::__copy (const asntype& obj)
{
  const EventAction* object = asnSCast(const EventAction*,&obj);
  optionalField[0] = object->optionalField[0];
 {
    if(asnGetPresence(object->optionalField,asn_triggerTimes) != asnFALSE)
    {
      triggerTimes = object->triggerTimes;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_notifyInterval) != asnFALSE)
    {
      notifyInterval = object->notifyInterval;
    }
 }
}

/**
 *    TypeAssignment : EventRule
 *    Class constructor
 */
EventRule::EventRule(const EventRule& object)
  : asntype()  ,optional(object.optional.length, optionalField)
  ,ruleId()
  ,startTime()
  ,endTime()
  ,conditions()
  ,interval()
  ,action()

{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : EventRule
 * Copy method
 */
void EventRule::__copy (const asntype& obj)
{
  const EventRule* object = asnSCast(const EventRule*,&obj);
  optionalField[0] = object->optionalField[0];
 {
    ruleId = object->ruleId;
 }
 {
    if(asnGetPresence(object->optionalField,asn_startTime) != asnFALSE)
    {
      if(object->startTime != (TimeStamp *)asnBNULL)
      {
        startTime = (TimeStamp*)object->startTime->__create();
        startTime->__copy(*object->startTime);
      }
      else
      {
        startTime = (TimeStamp *) 0;
      }
    }
    else
    {
      this->startTime = (TimeStamp*) asnBNULL;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_EventRule__endTime) != asnFALSE)
    {
      if(object->endTime != (TimeStamp *)asnBNULL)
      {
        endTime = (TimeStamp*)object->endTime->__create();
        endTime->__copy(*object->endTime);
      }
      else
      {
        endTime = (TimeStamp *) 0;
      }
    }
    else
    {
      this->endTime = (TimeStamp*) asnBNULL;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_conditions) != asnFALSE)
    {
      asncconditionss *elt_asncconditionss;
      elt_asncconditionss = (asncconditionss*) object->conditions.firstElement;
      for (asnMAXUINT countconditions=0; countconditions<object->conditions.count; countconditions++)
      {
        conditions.addElement(new asncconditionss(*elt_asncconditionss));
        elt_asncconditionss = (asncconditionss*) elt_asncconditionss->nextElement;
      }
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_EventRule__interval) != asnFALSE)
    {
      interval = object->interval;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_EventRule__action) != asnFALSE)
    {
      if(object->action != (EventAction *)asnBNULL)
      {
        action = (EventAction*)object->action->__create();
        action->__copy(*object->action);
      }
      else
      {
        action = (EventAction *) 0;
      }
    }
    else
    {
      this->action = (EventAction*) asnBNULL;
    }
 }
}

/**
 *    TypeAssignment : GeneralMessage__C
 *    Class constructor
 */
asncGeneralMessage__message::asncGeneralMessage__message(const asncGeneralMessage__message& object)
  :GeneralMessage__C(object.alternative),message()
{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : GeneralMessage__C
 * Copy method
 */
void asncGeneralMessage__message::__copy (const asntype& obj)
{
  const asncGeneralMessage__message* object = asnSCast(const asncGeneralMessage__message*,&obj);
  this->message.__copy(object->message);
}
/**
 *    TypeAssignment : GeneralMessage__C
 *    Class constructor
 */
asncocetMessage::asncocetMessage(const asncocetMessage& object)
  :GeneralMessage__C(object.alternative),ocetMessage()
{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : GeneralMessage__C
 * Copy method
 */
void asncocetMessage::__copy (const asntype& obj)
{
  const asncocetMessage* object = asnSCast(const asncocetMessage*,&obj);
  this->ocetMessage.__copy(object->ocetMessage);
}
/**
 *    TypeAssignment : GeneralMessage
 *    Class constructor
 */
GeneralMessage::GeneralMessage(const GeneralMessage& object)
  : asntype(),value(){
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : GeneralMessage
 * Copy method
 */
void GeneralMessage::__copy (const asntype& obj)
{
  const GeneralMessage* object = asnSCast(const GeneralMessage*,&obj);
  if(object->value != (GeneralMessage__C *)asnBNULL)
  {
    switch(object->value->alternative)
    {
      case asn_GeneralMessage__message:
        this->value = new asncGeneralMessage__message(*(asncGeneralMessage__message*) object->value);
        break;
      case asn_ocetMessage:
        this->value = new asncocetMessage(*(asncocetMessage*) object->value);
        break;
      default: this->value = (GeneralMessage__C *) 0;
    }
  }
  else
  {
    this->value = (GeneralMessage__C *) 0;
  }
}

/**
 *    TypeAssignment : Notification
 *    Class constructor
 */
Notification::Notification(const Notification& object)
  : asntype()  ,optional(object.optional.length, optionalField)
  ,reason()
  ,time()
  ,code()
  ,parameters()

{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : Notification
 * Copy method
 */
void Notification::__copy (const asntype& obj)
{
  const Notification* object = asnSCast(const Notification*,&obj);
  optionalField[0] = object->optionalField[0];
 {
    reason = object->reason;
 }
 {
    if(object->time != (TimeStamp *)asnBNULL)
    {
      time = (TimeStamp*)object->time->__create();
      time->__copy(*object->time);
    }
    else
    {
      time = (TimeStamp *) 0;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_Notification__code) != asnFALSE)
    {
      this->code.__copy (object->code);
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_parameters) != asnFALSE)
    {
      asncNotification__parameterss *elt_asncNotification__parameterss;
      elt_asncNotification__parameterss = (asncNotification__parameterss*) object->parameters.firstElement;
      for (asnMAXUINT countparameters=0; countparameters<object->parameters.count; countparameters++)
      {
        parameters.addElement(new asncNotification__parameterss(*elt_asncNotification__parameterss));
        elt_asncNotification__parameterss = (asncNotification__parameterss*) elt_asncNotification__parameterss->nextElement;
      }
    }
 }
}

/**
 *    TypeAssignment : OTA
 *    Class constructor
 */
OTA::OTA(const OTA& object)
  : asntype()  ,optional(object.optional.length, optionalField)
  ,swModel()
  ,swVersion()
  ,downloadUrl()
  ,verificationCode()

{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : OTA
 * Copy method
 */
void OTA::__copy (const asntype& obj)
{
  const OTA* object = asnSCast(const OTA*,&obj);
  optionalField[0] = object->optionalField[0];
 {
    if(asnGetPresence(object->optionalField,asn_swModel) != asnFALSE)
    {
      this->swModel.__copy (object->swModel);
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_OTA__swVersion) != asnFALSE)
    {
      this->swVersion.__copy (object->swVersion);
    }
 }
 {
    this->downloadUrl.__copy (object->downloadUrl);
 }
 {
    if(asnGetPresence(object->optionalField,asn_verificationCode) != asnFALSE)
    {
      this->verificationCode.__copy (object->verificationCode);
    }
 }
}

/**
 *    TypeAssignment : PointOfInterest
 *    Class constructor
 */
PointOfInterest::PointOfInterest(const PointOfInterest& object)
  : asntype()  ,optional(object.optional.length, optionalField)
  ,name()
  ,position()
  ,type()
  ,contactInfo()
  ,url()
  ,attributes()

{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : PointOfInterest
 * Copy method
 */
void PointOfInterest::__copy (const asntype& obj)
{
  const PointOfInterest* object = asnSCast(const PointOfInterest*,&obj);
  optionalField[0] = object->optionalField[0];
 {
    this->name.__copy (object->name);
 }
 {
    if(asnGetPresence(object->optionalField,asn_PointOfInterest__position) != asnFALSE)
    {
      if(object->position != (Position *)asnBNULL)
      {
        position = (Position*)object->position->__create();
        position->__copy(*object->position);
      }
      else
      {
        position = (Position *) 0;
      }
    }
    else
    {
      this->position = (Position*) asnBNULL;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_type) != asnFALSE)
    {
      this->type.__copy (object->type);
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_contactInfo) != asnFALSE)
    {
      if(object->contactInfo != (ContactInfo *)asnBNULL)
      {
        contactInfo = (ContactInfo*)object->contactInfo->__create();
        contactInfo->__copy(*object->contactInfo);
      }
      else
      {
        contactInfo = (ContactInfo *) 0;
      }
    }
    else
    {
      this->contactInfo = (ContactInfo*) asnBNULL;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_url) != asnFALSE)
    {
      this->url.__copy (object->url);
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_attributes) != asnFALSE)
    {
      asncattributess *elt_asncattributess;
      elt_asncattributess = (asncattributess*) object->attributes.firstElement;
      for (asnMAXUINT countattributes=0; countattributes<object->attributes.count; countattributes++)
      {
        attributes.addElement(new asncattributess(*elt_asncattributess));
        elt_asncattributess = (asncattributess*) elt_asncattributess->nextElement;
      }
    }
 }
}

/**
 *    TypeAssignment : Position
 *    Class constructor
 */
Position::Position(const Position& object)
  : asntype()  ,optional(object.optional.length, optionalField)
  ,latitude()
  ,longitude()
  ,altitude()
  ,posCanBeTrusted()
  ,carLocatorStatUploadEn()
  ,marsCoordinates()

{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : Position
 * Copy method
 */
void Position::__copy (const asntype& obj)
{
  const Position* object = asnSCast(const Position*,&obj);
  optionalField[0] = object->optionalField[0];
 {
    if(asnGetPresence(object->optionalField,asn_latitude) != asnFALSE)
    {
      latitude = object->latitude;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_longitude) != asnFALSE)
    {
      longitude = object->longitude;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_altitude) != asnFALSE)
    {
      altitude = object->altitude;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_posCanBeTrusted) != asnFALSE)
    {
      posCanBeTrusted = object->posCanBeTrusted;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_carLocatorStatUploadEn) != asnFALSE)
    {
      carLocatorStatUploadEn = object->carLocatorStatUploadEn;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_marsCoordinates) != asnFALSE)
    {
      marsCoordinates = object->marsCoordinates;
    }
 }
}

/**
 *    TypeAssignment : PostAddress
 *    Class constructor
 */
PostAddress::PostAddress(const PostAddress& object)
  : asntype()  ,optional(object.optional.length, optionalField)
  ,street()
  ,houseNumber()
  ,city()
  ,region()
  ,postcode()
  ,country()

{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : PostAddress
 * Copy method
 */
void PostAddress::__copy (const asntype& obj)
{
  const PostAddress* object = asnSCast(const PostAddress*,&obj);
  optionalField[0] = object->optionalField[0];
 {
    if(asnGetPresence(object->optionalField,asn_street) != asnFALSE)
    {
      this->street.__copy (object->street);
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_houseNumber) != asnFALSE)
    {
      this->houseNumber.__copy (object->houseNumber);
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_city) != asnFALSE)
    {
      this->city.__copy (object->city);
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_region) != asnFALSE)
    {
      this->region.__copy (object->region);
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_postcode) != asnFALSE)
    {
      this->postcode.__copy (object->postcode);
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_country) != asnFALSE)
    {
      this->country.__copy (object->country);
    }
 }
}

/**
 *    TypeAssignment : RuleCondition
 *    Class constructor
 */
RuleCondition::RuleCondition(const RuleCondition& object)
  : asntype()  ,condition()

{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : RuleCondition
 * Copy method
 */
void RuleCondition::__copy (const asntype& obj)
{
  const RuleCondition* object = asnSCast(const RuleCondition*,&obj);
 {
    this->condition.__copy (object->condition);
 }
}

/**
 *    TypeAssignment : ServiceData
 *    Class constructor
 */
ServiceData::ServiceData(const ServiceData& object)
  : asntype()  ,optional(object.optional.length, optionalField)
  ,serviceTrigger()
  ,serviceParameters()
  ,serviceCommand()
  ,serviceResult()
  ,serviceStatus()
  ,message()
  ,pois()
  ,configuration()
  ,vehicleStatus()
  ,ota()
  ,fota()
  ,rvdc()
  ,trip()
  ,tripFragments()
  ,trackPoints()
  ,nevServiceData()
  ,eventRule()
  ,timerData()

{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : ServiceData
 * Copy method
 */
void ServiceData::__copy (const asntype& obj)
{
  const ServiceData* object = asnSCast(const ServiceData*,&obj);
  optionalField[0] = object->optionalField[0];
  optionalField[1] = object->optionalField[1];
  optionalField[2] = object->optionalField[2];
 {
    if(asnGetPresence(object->optionalField,asn_serviceTrigger) != asnFALSE)
    {
      if(object->serviceTrigger != (ServiceTrigger *)asnBNULL)
      {
        serviceTrigger = (ServiceTrigger*)object->serviceTrigger->__create();
        serviceTrigger->__copy(*object->serviceTrigger);
      }
      else
      {
        serviceTrigger = (ServiceTrigger *) 0;
      }
    }
    else
    {
      this->serviceTrigger = (ServiceTrigger*) asnBNULL;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_ServiceData__serviceParameters) != asnFALSE)
    {
      asncServiceData__serviceParameterss *elt_asncServiceData__serviceParameterss;
      elt_asncServiceData__serviceParameterss = (asncServiceData__serviceParameterss*) object->serviceParameters.firstElement;
      for (asnMAXUINT countserviceParameters=0; countserviceParameters<object->serviceParameters.count; countserviceParameters++)
      {
        serviceParameters.addElement(new asncServiceData__serviceParameterss(*elt_asncServiceData__serviceParameterss));
        elt_asncServiceData__serviceParameterss = (asncServiceData__serviceParameterss*) elt_asncServiceData__serviceParameterss->nextElement;
      }
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_serviceCommand) != asnFALSE)
    {
      serviceCommand = object->serviceCommand;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_serviceResult) != asnFALSE)
    {
      if(object->serviceResult != (ServiceResult *)asnBNULL)
      {
        serviceResult = (ServiceResult*)object->serviceResult->__create();
        serviceResult->__copy(*object->serviceResult);
      }
      else
      {
        serviceResult = (ServiceResult *) 0;
      }
    }
    else
    {
      this->serviceResult = (ServiceResult*) asnBNULL;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_serviceStatus) != asnFALSE)
    {
      if(object->serviceStatus != (ServiceStatus *)asnBNULL)
      {
        serviceStatus = (ServiceStatus*)object->serviceStatus->__create();
        serviceStatus->__copy(*object->serviceStatus);
      }
      else
      {
        serviceStatus = (ServiceStatus *) 0;
      }
    }
    else
    {
      this->serviceStatus = (ServiceStatus*) asnBNULL;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_ServiceData__message) != asnFALSE)
    {
      if(object->message != (GeneralMessage__C *)asnBNULL)
      {
        switch(object->message->alternative)
        {
          case asn_GeneralMessage__message:
            this->message = new asncGeneralMessage__message(*(asncGeneralMessage__message*) object->message);
            break;
          case asn_ocetMessage:
            this->message = new asncocetMessage(*(asncocetMessage*) object->message);
            break;
          default: this->message = (GeneralMessage__C *) 0;
        }
      }
      else
      {
        this->message = (GeneralMessage__C *) 0;
      }
    }
    else
    {
      this->message = (GeneralMessage__C*) asnBNULL;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_pois) != asnFALSE)
    {
      asncpoiss *elt_asncpoiss;
      elt_asncpoiss = (asncpoiss*) object->pois.firstElement;
      for (asnMAXUINT countpois=0; countpois<object->pois.count; countpois++)
      {
        pois.addElement(new asncpoiss(*elt_asncpoiss));
        elt_asncpoiss = (asncpoiss*) elt_asncpoiss->nextElement;
      }
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_configuration) != asnFALSE)
    {
      if(object->configuration != (Configuration *)asnBNULL)
      {
        configuration = (Configuration*)object->configuration->__create();
        configuration->__copy(*object->configuration);
      }
      else
      {
        configuration = (Configuration *) 0;
      }
    }
    else
    {
      this->configuration = (Configuration*) asnBNULL;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_vehicleStatus) != asnFALSE)
    {
      if(object->vehicleStatus != (VehicleStatus *)asnBNULL)
      {
        vehicleStatus = (VehicleStatus*)object->vehicleStatus->__create();
        vehicleStatus->__copy(*object->vehicleStatus);
      }
      else
      {
        vehicleStatus = (VehicleStatus *) 0;
      }
    }
    else
    {
      this->vehicleStatus = (VehicleStatus*) asnBNULL;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_ServiceData__ota) != asnFALSE)
    {
      if(object->ota != (OTA *)asnBNULL)
      {
        ota = (OTA*)object->ota->__create();
        ota->__copy(*object->ota);
      }
      else
      {
        ota = (OTA *) 0;
      }
    }
    else
    {
      this->ota = (OTA*) asnBNULL;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_ServiceData__fota) != asnFALSE)
    {
      if(object->fota != (FOTA *)asnBNULL)
      {
        fota = (FOTA*)object->fota->__create();
        fota->__copy(*object->fota);
      }
      else
      {
        fota = (FOTA *) 0;
      }
    }
    else
    {
      this->fota = (FOTA*) asnBNULL;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_rvdc) != asnFALSE)
    {
      if(object->rvdc != (RVDC *)asnBNULL)
      {
        rvdc = (RVDC*)object->rvdc->__create();
        rvdc->__copy(*object->rvdc);
      }
      else
      {
        rvdc = (RVDC *) 0;
      }
    }
    else
    {
      this->rvdc = (RVDC*) asnBNULL;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_trip) != asnFALSE)
    {
      if(object->trip != (Trip *)asnBNULL)
      {
        trip = (Trip*)object->trip->__create();
        trip->__copy(*object->trip);
      }
      else
      {
        trip = (Trip *) 0;
      }
    }
    else
    {
      this->trip = (Trip*) asnBNULL;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_tripFragments) != asnFALSE)
    {
      asnctripFragmentss *elt_asnctripFragmentss;
      elt_asnctripFragmentss = (asnctripFragmentss*) object->tripFragments.firstElement;
      for (asnMAXUINT counttripFragments=0; counttripFragments<object->tripFragments.count; counttripFragments++)
      {
        tripFragments.addElement(new asnctripFragmentss(*elt_asnctripFragmentss));
        elt_asnctripFragmentss = (asnctripFragmentss*) elt_asnctripFragmentss->nextElement;
      }
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_trackPoints) != asnFALSE)
    {
      asnctrackPointss *elt_asnctrackPointss;
      elt_asnctrackPointss = (asnctrackPointss*) object->trackPoints.firstElement;
      for (asnMAXUINT counttrackPoints=0; counttrackPoints<object->trackPoints.count; counttrackPoints++)
      {
        trackPoints.addElement(new asnctrackPointss(*elt_asnctrackPointss));
        elt_asnctrackPointss = (asnctrackPointss*) elt_asnctrackPointss->nextElement;
      }
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_nevServiceData) != asnFALSE)
    {
      if(object->nevServiceData != (NEVServiceData *)asnBNULL)
      {
        nevServiceData = (NEVServiceData*)object->nevServiceData->__create();
        nevServiceData->__copy(*object->nevServiceData);
      }
      else
      {
        nevServiceData = (NEVServiceData *) 0;
      }
    }
    else
    {
      this->nevServiceData = (NEVServiceData*) asnBNULL;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_eventRule) != asnFALSE)
    {
      if(object->eventRule != (EventRule *)asnBNULL)
      {
        eventRule = (EventRule*)object->eventRule->__create();
        eventRule->__copy(*object->eventRule);
      }
      else
      {
        eventRule = (EventRule *) 0;
      }
    }
    else
    {
      this->eventRule = (EventRule*) asnBNULL;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_timerData) != asnFALSE)
    {
      if(object->timerData != (TimerData *)asnBNULL)
      {
        timerData = (TimerData*)object->timerData->__create();
        timerData->__copy(*object->timerData);
      }
      else
      {
        timerData = (TimerData *) 0;
      }
    }
    else
    {
      this->timerData = (TimerData*) asnBNULL;
    }
 }
}

/**
 *    TypeAssignment : ServiceParameter
 *    Class constructor
 */
ServiceParameter::ServiceParameter(const ServiceParameter& object)
  : asntype()  ,optional(object.optional.length, optionalField)
  ,key()
  ,intVal()
  ,stringVal()
  ,boolVal()
  ,timestampVal()
  ,dataVal()

{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : ServiceParameter
 * Copy method
 */
void ServiceParameter::__copy (const asntype& obj)
{
  const ServiceParameter* object = asnSCast(const ServiceParameter*,&obj);
  optionalField[0] = object->optionalField[0];
 {
    this->key.__copy (object->key);
 }
 {
    if(asnGetPresence(object->optionalField,asn_intVal) != asnFALSE)
    {
      intVal = object->intVal;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_ServiceParameter__stringVal) != asnFALSE)
    {
      this->stringVal.__copy (object->stringVal);
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_ServiceParameter__boolVal) != asnFALSE)
    {
      boolVal = object->boolVal;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_ServiceParameter__timestampVal) != asnFALSE)
    {
      if(object->timestampVal != (TimeStamp *)asnBNULL)
      {
        timestampVal = (TimeStamp*)object->timestampVal->__create();
        timestampVal->__copy(*object->timestampVal);
      }
      else
      {
        timestampVal = (TimeStamp *) 0;
      }
    }
    else
    {
      this->timestampVal = (TimeStamp*) asnBNULL;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_ServiceParameter__dataVal) != asnFALSE)
    {
      this->dataVal.__copy(object->dataVal);
    }
 }
}

/**
 *    TypeAssignment : ServiceResult
 *    Class constructor
 */
ServiceResult::ServiceResult(const ServiceResult& object)
  : asntype()  ,optional(object.optional.length, optionalField)
  ,operationSucceeded()
  ,error()
  ,operationType()

{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : ServiceResult
 * Copy method
 */
void ServiceResult::__copy (const asntype& obj)
{
  const ServiceResult* object = asnSCast(const ServiceResult*,&obj);
  optionalField[0] = object->optionalField[0];
 {
    operationSucceeded = object->operationSucceeded;
 }
 {
    if(asnGetPresence(object->optionalField,asn_error) != asnFALSE)
    {
      if(object->error != (Error *)asnBNULL)
      {
        error = (Error*)object->error->__create();
        error->__copy(*object->error);
      }
      else
      {
        error = (Error *) 0;
      }
    }
    else
    {
      this->error = (Error*) asnBNULL;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_operationType) != asnFALSE)
    {
      this->operationType.__copy (object->operationType);
    }
 }
}

/**
 *    TypeAssignment : ServiceStatus
 *    Class constructor
 */
ServiceStatus::ServiceStatus(const ServiceStatus& object)
  : asntype()  ,remoteControlInhibited()

{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : ServiceStatus
 * Copy method
 */
void ServiceStatus::__copy (const asntype& obj)
{
  const ServiceStatus* object = asnSCast(const ServiceStatus*,&obj);
 {
    remoteControlInhibited = object->remoteControlInhibited;
 }
}

/**
 *    TypeAssignment : ServiceTrigger
 *    Class constructor
 */
ServiceTrigger::ServiceTrigger(const ServiceTrigger& object)
  : asntype()  ,optional(object.optional.length, optionalField)
  ,scheduledTime()
  ,recurrentOperation()
  ,duration()
  ,interval()
  ,occurs()
  ,endTime()
  ,startTimeofDay()

{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : ServiceTrigger
 * Copy method
 */
void ServiceTrigger::__copy (const asntype& obj)
{
  const ServiceTrigger* object = asnSCast(const ServiceTrigger*,&obj);
  optionalField[0] = object->optionalField[0];
 {
    if(asnGetPresence(object->optionalField,asn_scheduledTime) != asnFALSE)
    {
      if(object->scheduledTime != (TimeStamp *)asnBNULL)
      {
        scheduledTime = (TimeStamp*)object->scheduledTime->__create();
        scheduledTime->__copy(*object->scheduledTime);
      }
      else
      {
        scheduledTime = (TimeStamp *) 0;
      }
    }
    else
    {
      this->scheduledTime = (TimeStamp*) asnBNULL;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_recurrentOperation) != asnFALSE)
    {
      recurrentOperation = object->recurrentOperation;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_ServiceTrigger__duration) != asnFALSE)
    {
      duration = object->duration;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_ServiceTrigger__interval) != asnFALSE)
    {
      interval = object->interval;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_occurs) != asnFALSE)
    {
      occurs = object->occurs;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_ServiceTrigger__endTime) != asnFALSE)
    {
      if(object->endTime != (TimeStamp *)asnBNULL)
      {
        endTime = (TimeStamp*)object->endTime->__create();
        endTime->__copy(*object->endTime);
      }
      else
      {
        endTime = (TimeStamp *) 0;
      }
    }
    else
    {
      this->endTime = (TimeStamp*) asnBNULL;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_ServiceTrigger__startTimeofDay) != asnFALSE)
    {
      startTimeofDay = object->startTimeofDay;
    }
 }
}

/**
 *    TypeAssignment : TimerData
 *    Class constructor
 */
TimerData::TimerData(const TimerData& object)
  : asntype()  ,optional(object.optional.length, optionalField)
  ,timerId()
  ,timers()

{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : TimerData
 * Copy method
 */
void TimerData::__copy (const asntype& obj)
{
  const TimerData* object = asnSCast(const TimerData*,&obj);
  optionalField[0] = object->optionalField[0];
 {
    timerId = object->timerId;
 }
 {
    if(asnGetPresence(object->optionalField,asn_timers) != asnFALSE)
    {
      asnctimerss *elt_asnctimerss;
      elt_asnctimerss = (asnctimerss*) object->timers.firstElement;
      for (asnMAXUINT counttimers=0; counttimers<object->timers.count; counttimers++)
      {
        timers.addElement(new asnctimerss(*elt_asnctimerss));
        elt_asnctimerss = (asnctimerss*) elt_asnctimerss->nextElement;
      }
    }
 }
}

/**
 *    TypeAssignment : TimerInfo
 *    Class constructor
 */
TimerInfo::TimerInfo(const TimerInfo& object)
  : asntype()  ,optional(object.optional.length, optionalField)
  ,timerActivation()
  ,duration()
  ,dayofWeek()
  ,startTimeofDay()
  ,endtimeofDay()

{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : TimerInfo
 * Copy method
 */
void TimerInfo::__copy (const asntype& obj)
{
  const TimerInfo* object = asnSCast(const TimerInfo*,&obj);
  optionalField[0] = object->optionalField[0];
 {
    timerActivation = object->timerActivation;
 }
 {
    if(asnGetPresence(object->optionalField,asn_TimerInfo__duration) != asnFALSE)
    {
      duration = object->duration;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_dayofWeek) != asnFALSE)
    {
      this->dayofWeek.__copy(object->dayofWeek);
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_TimerInfo__startTimeofDay) != asnFALSE)
    {
      this->startTimeofDay.__copy(object->startTimeofDay);
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_endtimeofDay) != asnFALSE)
    {
      this->endtimeofDay.__copy(object->endtimeofDay);
    }
 }
}

/**
 *    TypeAssignment : TrackPoint
 *    Class constructor
 */
TrackPoint::TrackPoint(const TrackPoint& object)
  : asntype()  ,optional(object.optional.length, optionalField)
  ,systemTime()
  ,position()
  ,speed()
  ,direction()
  ,isSVT()
  ,odometer()
  ,travelDistanceSinceLastWaypoint()
  ,fuelConsumptionSinceLastWaypoint()
  ,electricConsumptionSinceLastSample()
  ,electricRegenerationSinceLastSample()

{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : TrackPoint
 * Copy method
 */
void TrackPoint::__copy (const asntype& obj)
{
  const TrackPoint* object = asnSCast(const TrackPoint*,&obj);
  optionalField[0] = object->optionalField[0];
 {
    if(object->systemTime != (TimeStamp *)asnBNULL)
    {
      systemTime = (TimeStamp*)object->systemTime->__create();
      systemTime->__copy(*object->systemTime);
    }
    else
    {
      systemTime = (TimeStamp *) 0;
    }
 }
 {
    if(object->position != (Position *)asnBNULL)
    {
      position = (Position*)object->position->__create();
      position->__copy(*object->position);
    }
    else
    {
      position = (Position *) 0;
    }
 }
 {
    speed = object->speed;
 }
 {
    if(asnGetPresence(object->optionalField,asn_TrackPoint__direction) != asnFALSE)
    {
      direction = object->direction;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_isSVT) != asnFALSE)
    {
      isSVT = object->isSVT;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_TrackPoint__odometer) != asnFALSE)
    {
      odometer = object->odometer;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_travelDistanceSinceLastWaypoint) != asnFALSE)
    {
      travelDistanceSinceLastWaypoint = object->travelDistanceSinceLastWaypoint;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_fuelConsumptionSinceLastWaypoint) != asnFALSE)
    {
      fuelConsumptionSinceLastWaypoint = object->fuelConsumptionSinceLastWaypoint;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_electricConsumptionSinceLastSample) != asnFALSE)
    {
      electricConsumptionSinceLastSample = object->electricConsumptionSinceLastSample;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_electricRegenerationSinceLastSample) != asnFALSE)
    {
      electricRegenerationSinceLastSample = object->electricRegenerationSinceLastSample;
    }
 }
}

/**
 *    TypeAssignment : Trip
 *    Class constructor
 */
Trip::Trip(const Trip& object)
  : asntype()  ,optional(object.optional.length, optionalField)
  ,tripId()
  ,startTime()
  ,startOdometer()
  ,fuelConsumption()
  ,traveledDistance()
  ,trackpoints()
  ,waypoints()
  ,avgSpeed()
  ,endTime()
  ,endOdometer()
  ,electricConsumption()
  ,electricRegeneration()

{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : Trip
 * Copy method
 */
void Trip::__copy (const asntype& obj)
{
  const Trip* object = asnSCast(const Trip*,&obj);
  optionalField[0] = object->optionalField[0];
 {
    tripId = object->tripId;
 }
 {
    if(object->startTime != (TimeStamp *)asnBNULL)
    {
      startTime = (TimeStamp*)object->startTime->__create();
      startTime->__copy(*object->startTime);
    }
    else
    {
      startTime = (TimeStamp *) 0;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_Trip__startOdometer) != asnFALSE)
    {
      startOdometer = object->startOdometer;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_fuelConsumption) != asnFALSE)
    {
      fuelConsumption = object->fuelConsumption;
    }
 }
 {
    traveledDistance = object->traveledDistance;
 }
 {
    asnctrackpointss *elt_asnctrackpointss;
    elt_asnctrackpointss = (asnctrackpointss*) object->trackpoints.firstElement;
    for (asnMAXUINT counttrackpoints=0; counttrackpoints<object->trackpoints.count; counttrackpoints++)
    {
      trackpoints.addElement(new asnctrackpointss(*elt_asnctrackpointss));
      elt_asnctrackpointss = (asnctrackpointss*) elt_asnctrackpointss->nextElement;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_waypoints) != asnFALSE)
    {
      asncwaypointss *elt_asncwaypointss;
      elt_asncwaypointss = (asncwaypointss*) object->waypoints.firstElement;
      for (asnMAXUINT countwaypoints=0; countwaypoints<object->waypoints.count; countwaypoints++)
      {
        waypoints.addElement(new asncwaypointss(*elt_asncwaypointss));
        elt_asncwaypointss = (asncwaypointss*) elt_asncwaypointss->nextElement;
      }
    }
 }
 {
    avgSpeed = object->avgSpeed;
 }
 {
    if(object->endTime != (TimeStamp *)asnBNULL)
    {
      endTime = (TimeStamp*)object->endTime->__create();
      endTime->__copy(*object->endTime);
    }
    else
    {
      endTime = (TimeStamp *) 0;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_Trip__endOdometer) != asnFALSE)
    {
      endOdometer = object->endOdometer;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_electricConsumption) != asnFALSE)
    {
      electricConsumption = object->electricConsumption;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_electricRegeneration) != asnFALSE)
    {
      electricRegeneration = object->electricRegeneration;
    }
 }
}

/**
 *    TypeAssignment : TripFragment
 *    Class constructor
 */
TripFragment::TripFragment(const TripFragment& object)
  : asntype()  ,optional(object.optional.length, optionalField)
  ,startTime()
  ,startPosition()
  ,startOdometer()
  ,startFuelLevel()
  ,startElectricConsumption()
  ,startElectricRegeneration()
  ,endTime()
  ,endPosition()
  ,endOdometer()
  ,endFuelLevel()
  ,endElectricConsumption()
  ,endElectricRegeneration()

{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : TripFragment
 * Copy method
 */
void TripFragment::__copy (const asntype& obj)
{
  const TripFragment* object = asnSCast(const TripFragment*,&obj);
  optionalField[0] = object->optionalField[0];
  optionalField[1] = object->optionalField[1];
 {
    if(object->startTime != (TimeStamp *)asnBNULL)
    {
      startTime = (TimeStamp*)object->startTime->__create();
      startTime->__copy(*object->startTime);
    }
    else
    {
      startTime = (TimeStamp *) 0;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_startPosition) != asnFALSE)
    {
      if(object->startPosition != (Position *)asnBNULL)
      {
        startPosition = (Position*)object->startPosition->__create();
        startPosition->__copy(*object->startPosition);
      }
      else
      {
        startPosition = (Position *) 0;
      }
    }
    else
    {
      this->startPosition = (Position*) asnBNULL;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_TripFragment__startOdometer) != asnFALSE)
    {
      startOdometer = object->startOdometer;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_startFuelLevel) != asnFALSE)
    {
      startFuelLevel = object->startFuelLevel;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_startElectricConsumption) != asnFALSE)
    {
      startElectricConsumption = object->startElectricConsumption;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_startElectricRegeneration) != asnFALSE)
    {
      startElectricRegeneration = object->startElectricRegeneration;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_TripFragment__endTime) != asnFALSE)
    {
      if(object->endTime != (TimeStamp *)asnBNULL)
      {
        endTime = (TimeStamp*)object->endTime->__create();
        endTime->__copy(*object->endTime);
      }
      else
      {
        endTime = (TimeStamp *) 0;
      }
    }
    else
    {
      this->endTime = (TimeStamp*) asnBNULL;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_endPosition) != asnFALSE)
    {
      if(object->endPosition != (Position *)asnBNULL)
      {
        endPosition = (Position*)object->endPosition->__create();
        endPosition->__copy(*object->endPosition);
      }
      else
      {
        endPosition = (Position *) 0;
      }
    }
    else
    {
      this->endPosition = (Position*) asnBNULL;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_TripFragment__endOdometer) != asnFALSE)
    {
      endOdometer = object->endOdometer;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_endFuelLevel) != asnFALSE)
    {
      endFuelLevel = object->endFuelLevel;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_endElectricConsumption) != asnFALSE)
    {
      endElectricConsumption = object->endElectricConsumption;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_endElectricRegeneration) != asnFALSE)
    {
      endElectricRegeneration = object->endElectricRegeneration;
    }
 }
}

/**
 *    TypeAssignment : AdditionalStatus
 *    Class constructor
 */
AdditionalStatus::AdditionalStatus(const AdditionalStatus& object)
  : asntype()  ,optional(object.optional.length, optionalField)
  ,confAndId()
  ,ecuWarningMessages()
  ,towStatus()
  ,signals()
  ,data()

{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : AdditionalStatus
 * Copy method
 */
void AdditionalStatus::__copy (const asntype& obj)
{
  const AdditionalStatus* object = asnSCast(const AdditionalStatus*,&obj);
  optionalField[0] = object->optionalField[0];
 {
    if(asnGetPresence(object->optionalField,asn_confAndId) != asnFALSE)
    {
      if(object->confAndId != (ConfigurationAndIdentity *)asnBNULL)
      {
        confAndId = (ConfigurationAndIdentity*)object->confAndId->__create();
        confAndId->__copy(*object->confAndId);
      }
      else
      {
        confAndId = (ConfigurationAndIdentity *) 0;
      }
    }
    else
    {
      this->confAndId = (ConfigurationAndIdentity*) asnBNULL;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_ecuWarningMessages) != asnFALSE)
    {
      asncEcuWarningMessagess *elt_asncEcuWarningMessagess;
      elt_asncEcuWarningMessagess = (asncEcuWarningMessagess*) object->ecuWarningMessages.firstElement;
      for (asnMAXUINT countecuWarningMessages=0; countecuWarningMessages<object->ecuWarningMessages.count; countecuWarningMessages++)
      {
        ecuWarningMessages.addElement(new asncEcuWarningMessagess(*elt_asncEcuWarningMessagess));
        elt_asncEcuWarningMessagess = (asncEcuWarningMessagess*) elt_asncEcuWarningMessagess->nextElement;
      }
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_towStatus) != asnFALSE)
    {
      if(object->towStatus != (TowStatus *)asnBNULL)
      {
        towStatus = (TowStatus*)object->towStatus->__create();
        towStatus->__copy(*object->towStatus);
      }
      else
      {
        towStatus = (TowStatus *) 0;
      }
    }
    else
    {
      this->towStatus = (TowStatus*) asnBNULL;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_AdditionalStatus__signals) != asnFALSE)
    {
      asncAdditionalStatus__signalss *elt_asncAdditionalStatus__signalss;
      elt_asncAdditionalStatus__signalss = (asncAdditionalStatus__signalss*) object->signals.firstElement;
      for (asnMAXUINT countsignals=0; countsignals<object->signals.count; countsignals++)
      {
        signals.addElement(new asncAdditionalStatus__signalss(*elt_asncAdditionalStatus__signalss));
        elt_asncAdditionalStatus__signalss = (asncAdditionalStatus__signalss*) elt_asncAdditionalStatus__signalss->nextElement;
      }
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_AdditionalStatus__data) != asnFALSE)
    {
      this->data.__copy(object->data);
    }
 }
}

/**
 *    TypeAssignment : BasicVehicleStatus
 *    Class constructor
 */
BasicVehicleStatus::BasicVehicleStatus(const BasicVehicleStatus& object)
  : asntype()  ,optional(object.optional.length, optionalField)
  ,vin()
  ,position()
  ,speed()
  ,speedUnit()
  ,speedValidity()
  ,direction()
  ,engineStatus()
  ,keyStatus()
  ,usageMode()

{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : BasicVehicleStatus
 * Copy method
 */
void BasicVehicleStatus::__copy (const asntype& obj)
{
  const BasicVehicleStatus* object = asnSCast(const BasicVehicleStatus*,&obj);
  optionalField[0] = object->optionalField[0];
 {
    if(asnGetPresence(object->optionalField,asn_BasicVehicleStatus__vin) != asnFALSE)
    {
      this->vin.__copy (object->vin);
    }
 }
 {
    if(object->position != (Position *)asnBNULL)
    {
      position = (Position*)object->position->__create();
      position->__copy(*object->position);
    }
    else
    {
      position = (Position *) 0;
    }
 }
 {
    speed = object->speed;
 }
 {
    if(asnGetPresence(object->optionalField,asn_speedUnit) != asnFALSE)
    {
      this->speedUnit.__copy (object->speedUnit);
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_BasicVehicleStatus__speedValidity) != asnFALSE)
    {
      speedValidity = object->speedValidity;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_BasicVehicleStatus__direction) != asnFALSE)
    {
      direction = object->direction;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_engineStatus) != asnFALSE)
    {
      engineStatus = object->engineStatus;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_keyStatus) != asnFALSE)
    {
      keyStatus = object->keyStatus;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_usageMode) != asnFALSE)
    {
      usageMode = object->usageMode;
    }
 }
}

/**
 *    TypeAssignment : BatteryStatus
 *    Class constructor
 */
BatteryStatus::BatteryStatus(const BatteryStatus& object)
  : asntype()  ,optional(object.optional.length, optionalField)
  ,stateOfCharge()
  ,chargeLevel()
  ,stateOfHealth()
  ,powerLevel()
  ,energyLevel()
  ,voltage()

{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : BatteryStatus
 * Copy method
 */
void BatteryStatus::__copy (const asntype& obj)
{
  const BatteryStatus* object = asnSCast(const BatteryStatus*,&obj);
  optionalField[0] = object->optionalField[0];
 {
    if(asnGetPresence(object->optionalField,asn_BatteryStatus__stateOfCharge) != asnFALSE)
    {
      stateOfCharge = object->stateOfCharge;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_BatteryStatus__chargeLevel) != asnFALSE)
    {
      chargeLevel = object->chargeLevel;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_stateOfHealth) != asnFALSE)
    {
      stateOfHealth = object->stateOfHealth;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_powerLevel) != asnFALSE)
    {
      powerLevel = object->powerLevel;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_energyLevel) != asnFALSE)
    {
      energyLevel = object->energyLevel;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_voltage) != asnFALSE)
    {
      voltage = object->voltage;
    }
 }
}

/**
 *    TypeAssignment : CarConfig
 *    Class constructor
 */
CarConfig::CarConfig(const CarConfig& object)
  : asntype()  ,optional(object.optional.length, optionalField)
  ,heatedFrontSeats()
  ,parkingClimateLevel()
  ,heatedSteeringWheel()
  ,items()

{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : CarConfig
 * Copy method
 */
void CarConfig::__copy (const asntype& obj)
{
  const CarConfig* object = asnSCast(const CarConfig*,&obj);
  optionalField[0] = object->optionalField[0];
 {
    if(asnGetPresence(object->optionalField,asn_heatedFrontSeats) != asnFALSE)
    {
      heatedFrontSeats = object->heatedFrontSeats;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_parkingClimateLevel) != asnFALSE)
    {
      parkingClimateLevel = object->parkingClimateLevel;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_heatedSteeringWheel) != asnFALSE)
    {
      heatedSteeringWheel = object->heatedSteeringWheel;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_CarConfig__items) != asnFALSE)
    {
      asncCarConfig__itemss *elt_asncCarConfig__itemss;
      elt_asncCarConfig__itemss = (asncCarConfig__itemss*) object->items.firstElement;
      for (asnMAXUINT countitems=0; countitems<object->items.count; countitems++)
      {
        items.addElement(new asncCarConfig__itemss(*elt_asncCarConfig__itemss));
        elt_asncCarConfig__itemss = (asncCarConfig__itemss*) elt_asncCarConfig__itemss->nextElement;
      }
    }
 }
}

/**
 *    TypeAssignment : ClimateStatus
 *    Class constructor
 */
ClimateStatus::ClimateStatus(const ClimateStatus& object)
  : asntype()  ,optional(object.optional.length, optionalField)
  ,interiorTemp()
  ,exteriorTemp()
  ,preClimateActive()
  ,airCleanSts()
  ,drvHeatSts()
  ,passHeatingSts()
  ,rlHeatingSts()
  ,rrHeatingSts()
  ,drvVentSts()
  ,passVentSts()
  ,rrVentSts()
  ,rlVentSts()
  ,interCO2Warning()
  ,fragStrs()

{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : ClimateStatus
 * Copy method
 */
void ClimateStatus::__copy (const asntype& obj)
{
  const ClimateStatus* object = asnSCast(const ClimateStatus*,&obj);
  optionalField[0] = object->optionalField[0];
  optionalField[1] = object->optionalField[1];
 {
    if(asnGetPresence(object->optionalField,asn_interiorTemp) != asnFALSE)
    {
      interiorTemp = object->interiorTemp;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_exteriorTemp) != asnFALSE)
    {
      exteriorTemp = object->exteriorTemp;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_preClimateActive) != asnFALSE)
    {
      preClimateActive = object->preClimateActive;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_airCleanSts) != asnFALSE)
    {
      airCleanSts = object->airCleanSts;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_drvHeatSts) != asnFALSE)
    {
      drvHeatSts = object->drvHeatSts;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_passHeatingSts) != asnFALSE)
    {
      passHeatingSts = object->passHeatingSts;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_rlHeatingSts) != asnFALSE)
    {
      rlHeatingSts = object->rlHeatingSts;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_rrHeatingSts) != asnFALSE)
    {
      rrHeatingSts = object->rrHeatingSts;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_drvVentSts) != asnFALSE)
    {
      drvVentSts = object->drvVentSts;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_passVentSts) != asnFALSE)
    {
      passVentSts = object->passVentSts;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_rrVentSts) != asnFALSE)
    {
      rrVentSts = object->rrVentSts;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_rlVentSts) != asnFALSE)
    {
      rlVentSts = object->rlVentSts;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_interCO2Warning) != asnFALSE)
    {
      interCO2Warning = object->interCO2Warning;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_fragStrs) != asnFALSE)
    {
      if(object->fragStrs != (FragStrs *)asnBNULL)
      {
        fragStrs = (FragStrs*)object->fragStrs->__create();
        fragStrs->__copy(*object->fragStrs);
      }
      else
      {
        fragStrs = (FragStrs *) 0;
      }
    }
    else
    {
      this->fragStrs = (FragStrs*) asnBNULL;
    }
 }
}

/**
 *    TypeAssignment : ConfigurationAndIdentity
 *    Class constructor
 */
ConfigurationAndIdentity::ConfigurationAndIdentity(const ConfigurationAndIdentity& object)
  : asntype()  ,optional(object.optional.length, optionalField)
  ,vin()
  ,fuelType()

{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : ConfigurationAndIdentity
 * Copy method
 */
void ConfigurationAndIdentity::__copy (const asntype& obj)
{
  const ConfigurationAndIdentity* object = asnSCast(const ConfigurationAndIdentity*,&obj);
  optionalField[0] = object->optionalField[0];
 {
    if(asnGetPresence(object->optionalField,asn_ConfigurationAndIdentity__vin) != asnFALSE)
    {
      this->vin.__copy (object->vin);
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_fuelType) != asnFALSE)
    {
      fuelType = object->fuelType;
    }
 }
}

/**
 *    TypeAssignment : ConnectivityInfo
 *    Class constructor
 */
ConnectivityInfo::ConnectivityInfo(const ConnectivityInfo& object)
  : asntype()  ,optional(object.optional.length, optionalField)
  ,connectTime()
  ,connectPosition()
  ,connectType()
  ,numRetriesConnect()
  ,retryReason()

{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : ConnectivityInfo
 * Copy method
 */
void ConnectivityInfo::__copy (const asntype& obj)
{
  const ConnectivityInfo* object = asnSCast(const ConnectivityInfo*,&obj);
  optionalField[0] = object->optionalField[0];
 {
    if(asnGetPresence(object->optionalField,asn_ConnectivityInfo__connectTime) != asnFALSE)
    {
      if(object->connectTime != (TimeStamp *)asnBNULL)
      {
        connectTime = (TimeStamp*)object->connectTime->__create();
        connectTime->__copy(*object->connectTime);
      }
      else
      {
        connectTime = (TimeStamp *) 0;
      }
    }
    else
    {
      this->connectTime = (TimeStamp*) asnBNULL;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_ConnectivityInfo__connectPosition) != asnFALSE)
    {
      if(object->connectPosition != (Position *)asnBNULL)
      {
        connectPosition = (Position*)object->connectPosition->__create();
        connectPosition->__copy(*object->connectPosition);
      }
      else
      {
        connectPosition = (Position *) 0;
      }
    }
    else
    {
      this->connectPosition = (Position*) asnBNULL;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_ConnectivityInfo__connectType) != asnFALSE)
    {
      this->connectType.__copy (object->connectType);
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_ConnectivityInfo__numRetriesConnect) != asnFALSE)
    {
      numRetriesConnect = object->numRetriesConnect;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_retryReason) != asnFALSE)
    {
      this->retryReason.__copy (object->retryReason);
    }
 }
}

/**
 *    TypeAssignment : ConnectivityStatus
 *    Class constructor
 */
ConnectivityStatus::ConnectivityStatus(const ConnectivityStatus& object)
  : asntype()  ,optional(object.optional.length, optionalField)
  ,wakeupTimePosition()
  ,connectEstablishedList()
  ,connectTime()
  ,connectPosition()
  ,connectType()
  ,numRetriesConnect()
  ,retryReason()
  ,disconnectType()
  ,lostConnectionsList()
  ,sleeptimePosition()

{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : ConnectivityStatus
 * Copy method
 */
void ConnectivityStatus::__copy (const asntype& obj)
{
  const ConnectivityStatus* object = asnSCast(const ConnectivityStatus*,&obj);
  optionalField[0] = object->optionalField[0];
  optionalField[1] = object->optionalField[1];
 {
    if(asnGetPresence(object->optionalField,asn_wakeupTimePosition) != asnFALSE)
    {
      if(object->wakeupTimePosition != (TimePosition *)asnBNULL)
      {
        wakeupTimePosition = (TimePosition*)object->wakeupTimePosition->__create();
        wakeupTimePosition->__copy(*object->wakeupTimePosition);
      }
      else
      {
        wakeupTimePosition = (TimePosition *) 0;
      }
    }
    else
    {
      this->wakeupTimePosition = (TimePosition*) asnBNULL;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_connectEstablishedList) != asnFALSE)
    {
      asncconnectEstablishedLists *elt_asncconnectEstablishedLists;
      elt_asncconnectEstablishedLists = (asncconnectEstablishedLists*) object->connectEstablishedList.firstElement;
      for (asnMAXUINT countconnectEstablishedList=0; countconnectEstablishedList<object->connectEstablishedList.count; countconnectEstablishedList++)
      {
        connectEstablishedList.addElement(new asncconnectEstablishedLists(*elt_asncconnectEstablishedLists));
        elt_asncconnectEstablishedLists = (asncconnectEstablishedLists*) elt_asncconnectEstablishedLists->nextElement;
      }
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_ConnectivityStatus__connectTime) != asnFALSE)
    {
      if(object->connectTime != (TimeStamp *)asnBNULL)
      {
        connectTime = (TimeStamp*)object->connectTime->__create();
        connectTime->__copy(*object->connectTime);
      }
      else
      {
        connectTime = (TimeStamp *) 0;
      }
    }
    else
    {
      this->connectTime = (TimeStamp*) asnBNULL;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_ConnectivityStatus__connectPosition) != asnFALSE)
    {
      if(object->connectPosition != (Position *)asnBNULL)
      {
        connectPosition = (Position*)object->connectPosition->__create();
        connectPosition->__copy(*object->connectPosition);
      }
      else
      {
        connectPosition = (Position *) 0;
      }
    }
    else
    {
      this->connectPosition = (Position*) asnBNULL;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_ConnectivityStatus__connectType) != asnFALSE)
    {
      this->connectType.__copy (object->connectType);
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_ConnectivityStatus__numRetriesConnect) != asnFALSE)
    {
      numRetriesConnect = object->numRetriesConnect;
    }
 }
 {
    this->retryReason.__copy (object->retryReason);
 }
 {
    if(asnGetPresence(object->optionalField,asn_disconnectType) != asnFALSE)
    {
      disconnectType = object->disconnectType;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_lostConnectionsList) != asnFALSE)
    {
      asnclostConnectionsLists *elt_asnclostConnectionsLists;
      elt_asnclostConnectionsLists = (asnclostConnectionsLists*) object->lostConnectionsList.firstElement;
      for (asnMAXUINT countlostConnectionsList=0; countlostConnectionsList<object->lostConnectionsList.count; countlostConnectionsList++)
      {
        lostConnectionsList.addElement(new asnclostConnectionsLists(*elt_asnclostConnectionsLists));
        elt_asnclostConnectionsLists = (asnclostConnectionsLists*) elt_asnclostConnectionsLists->nextElement;
      }
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_sleeptimePosition) != asnFALSE)
    {
      if(object->sleeptimePosition != (TimePosition *)asnBNULL)
      {
        sleeptimePosition = (TimePosition*)object->sleeptimePosition->__create();
        sleeptimePosition->__copy(*object->sleeptimePosition);
      }
      else
      {
        sleeptimePosition = (TimePosition *) 0;
      }
    }
    else
    {
      this->sleeptimePosition = (TimePosition*) asnBNULL;
    }
 }
}

/**
 *    TypeAssignment : DiagnosticTroubleCode
 *    Class constructor
 */
DiagnosticTroubleCode::DiagnosticTroubleCode(const DiagnosticTroubleCode& object)
  : asntype()  ,optional(object.optional.length, optionalField)
  ,dtc()
  ,status()
  ,failureCount()
  ,lastFail()
  ,firtFail()
  ,firstFailureOdometer()
  ,firstFailureBatteryVoltage()
  ,firstFailureVehicleSpeed()

{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : DiagnosticTroubleCode
 * Copy method
 */
void DiagnosticTroubleCode::__copy (const asntype& obj)
{
  const DiagnosticTroubleCode* object = asnSCast(const DiagnosticTroubleCode*,&obj);
  optionalField[0] = object->optionalField[0];
 {
    this->dtc.__copy (object->dtc);
 }
 {
    this->status.__copy(object->status);
 }
 {
    if(asnGetPresence(object->optionalField,asn_failureCount) != asnFALSE)
    {
      failureCount = object->failureCount;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_lastFail) != asnFALSE)
    {
      if(object->lastFail != (TimeStamp *)asnBNULL)
      {
        lastFail = (TimeStamp*)object->lastFail->__create();
        lastFail->__copy(*object->lastFail);
      }
      else
      {
        lastFail = (TimeStamp *) 0;
      }
    }
    else
    {
      this->lastFail = (TimeStamp*) asnBNULL;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_firtFail) != asnFALSE)
    {
      if(object->firtFail != (TimeStamp *)asnBNULL)
      {
        firtFail = (TimeStamp*)object->firtFail->__create();
        firtFail->__copy(*object->firtFail);
      }
      else
      {
        firtFail = (TimeStamp *) 0;
      }
    }
    else
    {
      this->firtFail = (TimeStamp*) asnBNULL;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_firstFailureOdometer) != asnFALSE)
    {
      firstFailureOdometer = object->firstFailureOdometer;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_firstFailureBatteryVoltage) != asnFALSE)
    {
      firstFailureBatteryVoltage = object->firstFailureBatteryVoltage;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_firstFailureVehicleSpeed) != asnFALSE)
    {
      firstFailureVehicleSpeed = object->firstFailureVehicleSpeed;
    }
 }
}

/**
 *    TypeAssignment : ECUDiagnostic
 *    Class constructor
 */
ECUDiagnostic::ECUDiagnostic(const ECUDiagnostic& object)
  : asntype()  ,optional(object.optional.length, optionalField)
  ,ecuID()
  ,diagnosticResult()
  ,dtcs()
  ,exceptionCode()

{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : ECUDiagnostic
 * Copy method
 */
void ECUDiagnostic::__copy (const asntype& obj)
{
  const ECUDiagnostic* object = asnSCast(const ECUDiagnostic*,&obj);
  optionalField[0] = object->optionalField[0];
 {
    this->ecuID.__copy (object->ecuID);
 }
 {
    diagnosticResult = object->diagnosticResult;
 }
 {
    if(asnGetPresence(object->optionalField,asn_dtcs) != asnFALSE)
    {
      asncdtcss *elt_asncdtcss;
      elt_asncdtcss = (asncdtcss*) object->dtcs.firstElement;
      for (asnMAXUINT countdtcs=0; countdtcs<object->dtcs.count; countdtcs++)
      {
        dtcs.addElement(new asncdtcss(*elt_asncdtcss));
        elt_asncdtcss = (asncdtcss*) elt_asncdtcss->nextElement;
      }
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_exceptionCode) != asnFALSE)
    {
      exceptionCode = object->exceptionCode;
    }
 }
}

/**
 *    TypeAssignment : asncECUDiagnosticss
 *    Class constructor
 */
asncECUDiagnosticss::asncECUDiagnosticss(const asncECUDiagnosticss& object)
  : asnListElement()
  ,optional(object.optional.length, optionalField)
  ,ecuID()
  ,diagnosticResult()
  ,dtcs()
  ,exceptionCode()
{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : asncECUDiagnosticss
 * Copy method
 */
void asncECUDiagnosticss::__copy (const asntype& obj)
{
  const asncECUDiagnosticss* object = asnSCast(const asncECUDiagnosticss*,&obj);
  optionalField[0] = object->optionalField[0];
 {
    this->ecuID.__copy (object->ecuID);
 }
 {
    diagnosticResult = object->diagnosticResult;
 }
 {
    if(asnGetPresence(object->optionalField,asn_dtcs) != asnFALSE)
    {
      asncdtcss *elt_asncdtcss;
      elt_asncdtcss = (asncdtcss*) object->dtcs.firstElement;
      for (asnMAXUINT countdtcs=0; countdtcs<object->dtcs.count; countdtcs++)
      {
        dtcs.addElement(new asncdtcss(*elt_asncdtcss));
        elt_asncdtcss = (asncdtcss*) elt_asncdtcss->nextElement;
      }
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_exceptionCode) != asnFALSE)
    {
      exceptionCode = object->exceptionCode;
    }
 }
}
/**
 *    TypeAssignment : ECUDiagnostics
 *    Class constructor
 */
ECUDiagnostics::ECUDiagnostics(const ECUDiagnostics& object)
  : asntype(),value(){
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : ECUDiagnostics
 * Copy method
 */
void ECUDiagnostics::__copy (const asntype& obj)
{
  const ECUDiagnostics* object = asnSCast(const ECUDiagnostics*,&obj);
  asncECUDiagnosticss *elt_asncECUDiagnosticss;
  elt_asncECUDiagnosticss = (asncECUDiagnosticss*) object->value.firstElement;
  for (asnMAXUINT countvalue=0; countvalue<object->value.count; countvalue++)
  {
    value.addElement(new asncECUDiagnosticss(*elt_asncECUDiagnosticss));
    elt_asncECUDiagnosticss = (asncECUDiagnosticss*) elt_asncECUDiagnosticss->nextElement;
  }
}

/**
 *    TypeAssignment : asncEcuWarningMessagess
 *    Class constructor
 */
asncEcuWarningMessagess::asncEcuWarningMessagess(const asncEcuWarningMessagess& object)
  : asnListElement()
  ,optional(object.optional.length, optionalField)
  ,key()
  ,collectTime()
  ,value()
  ,stringVal()
  ,boolVal()
  ,timestampVal()
  ,dataVal()
{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : asncEcuWarningMessagess
 * Copy method
 */
void asncEcuWarningMessagess::__copy (const asntype& obj)
{
  const asncEcuWarningMessagess* object = asnSCast(const asncEcuWarningMessagess*,&obj);
  optionalField[0] = object->optionalField[0];
 {
    this->key.__copy (object->key);
 }
 {
    if(asnGetPresence(object->optionalField,asn_collectTime) != asnFALSE)
    {
      if(object->collectTime != (TimeStamp *)asnBNULL)
      {
        collectTime = (TimeStamp*)object->collectTime->__create();
        collectTime->__copy(*object->collectTime);
      }
      else
      {
        collectTime = (TimeStamp *) 0;
      }
    }
    else
    {
      this->collectTime = (TimeStamp*) asnBNULL;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_value) != asnFALSE)
    {
      value = object->value;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_GenericVehicleSignal__stringVal) != asnFALSE)
    {
      this->stringVal.__copy (object->stringVal);
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_GenericVehicleSignal__boolVal) != asnFALSE)
    {
      boolVal = object->boolVal;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_GenericVehicleSignal__timestampVal) != asnFALSE)
    {
      if(object->timestampVal != (TimeStamp *)asnBNULL)
      {
        timestampVal = (TimeStamp*)object->timestampVal->__create();
        timestampVal->__copy(*object->timestampVal);
      }
      else
      {
        timestampVal = (TimeStamp *) 0;
      }
    }
    else
    {
      this->timestampVal = (TimeStamp*) asnBNULL;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_GenericVehicleSignal__dataVal) != asnFALSE)
    {
      this->dataVal.__copy(object->dataVal);
    }
 }
}
/**
 *    TypeAssignment : EcuWarningMessages
 *    Class constructor
 */
EcuWarningMessages::EcuWarningMessages(const EcuWarningMessages& object)
  : asntype(),value(){
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : EcuWarningMessages
 * Copy method
 */
void EcuWarningMessages::__copy (const asntype& obj)
{
  const EcuWarningMessages* object = asnSCast(const EcuWarningMessages*,&obj);
  asncEcuWarningMessagess *elt_asncEcuWarningMessagess;
  elt_asncEcuWarningMessagess = (asncEcuWarningMessagess*) object->value.firstElement;
  for (asnMAXUINT countvalue=0; countvalue<object->value.count; countvalue++)
  {
    value.addElement(new asncEcuWarningMessagess(*elt_asncEcuWarningMessagess));
    elt_asncEcuWarningMessagess = (asncEcuWarningMessagess*) elt_asncEcuWarningMessagess->nextElement;
  }
}

/**
 *    TypeAssignment : ElectricStatus
 *    Class constructor
 */
ElectricStatus::ElectricStatus(const ElectricStatus& object)
  : asntype()  ,optional(object.optional.length, optionalField)
  ,isCharging()
  ,isPluggedIn()
  ,stateOfCharge()
  ,chargeLevel()
  ,timeToFullyCharged()
  ,statusOfChargerConnection()
  ,chargerState()
  ,distanceToEmptyOnBatteryOnly()
  ,ems48VSOC()
  ,ems48VDisSOC()
  ,emsHVRBSError()
  ,emsRBSModeDisplay()
  ,emsOVPActive()
  ,ems48vPackTemp1()
  ,ems48vPackTemp2()
  ,emsBMSLBuildSwVersion()
  ,emsCBRemainingLife()
  ,chargeHvSts()
  ,ptReady()
  ,averPowerConsumption()
  ,indPowerConsumption()
  ,dcDcActvd()
  ,dcDcConnectStatus()
  ,dcChargeIAct()
  ,dcChargeSts()
  ,wptObjt()
  ,wptFineAlignt()
  ,wptActived()
  ,wptChargeIAct()
  ,wptChargeUAct()
  ,wptChargeSts()
  ,chargeIAct()
  ,chargeUAct()
  ,chargeSts()
  ,disChargeConnectStatus()
  ,disChargeIAct()
  ,disChargeUAct()
  ,disChargeSts()

{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : ElectricStatus
 * Copy method
 */
void ElectricStatus::__copy (const asntype& obj)
{
  const ElectricStatus* object = asnSCast(const ElectricStatus*,&obj);
  optionalField[0] = object->optionalField[0];
  optionalField[1] = object->optionalField[1];
  optionalField[2] = object->optionalField[2];
  optionalField[3] = object->optionalField[3];
  optionalField[4] = object->optionalField[4];
 {
    if(asnGetPresence(object->optionalField,asn_isCharging) != asnFALSE)
    {
      isCharging = object->isCharging;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_isPluggedIn) != asnFALSE)
    {
      isPluggedIn = object->isPluggedIn;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_ElectricStatus__stateOfCharge) != asnFALSE)
    {
      stateOfCharge = object->stateOfCharge;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_ElectricStatus__chargeLevel) != asnFALSE)
    {
      chargeLevel = object->chargeLevel;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_timeToFullyCharged) != asnFALSE)
    {
      timeToFullyCharged = object->timeToFullyCharged;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_statusOfChargerConnection) != asnFALSE)
    {
      statusOfChargerConnection = object->statusOfChargerConnection;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_chargerState) != asnFALSE)
    {
      chargerState = object->chargerState;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_distanceToEmptyOnBatteryOnly) != asnFALSE)
    {
      distanceToEmptyOnBatteryOnly = object->distanceToEmptyOnBatteryOnly;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_ems48VSOC) != asnFALSE)
    {
      ems48VSOC = object->ems48VSOC;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_ems48VDisSOC) != asnFALSE)
    {
      ems48VDisSOC = object->ems48VDisSOC;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_emsHVRBSError) != asnFALSE)
    {
      emsHVRBSError = object->emsHVRBSError;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_emsRBSModeDisplay) != asnFALSE)
    {
      emsRBSModeDisplay = object->emsRBSModeDisplay;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_emsOVPActive) != asnFALSE)
    {
      emsOVPActive = object->emsOVPActive;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_ems48vPackTemp1) != asnFALSE)
    {
      ems48vPackTemp1 = object->ems48vPackTemp1;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_ems48vPackTemp2) != asnFALSE)
    {
      ems48vPackTemp2 = object->ems48vPackTemp2;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_emsBMSLBuildSwVersion) != asnFALSE)
    {
      this->emsBMSLBuildSwVersion.__copy (object->emsBMSLBuildSwVersion);
    }
 }
 {
    emsCBRemainingLife = object->emsCBRemainingLife;
 }
 {
    if(asnGetPresence(object->optionalField,asn_chargeHvSts) != asnFALSE)
    {
      chargeHvSts = object->chargeHvSts;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_ptReady) != asnFALSE)
    {
      ptReady = object->ptReady;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_averPowerConsumption) != asnFALSE)
    {
      averPowerConsumption = object->averPowerConsumption;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_indPowerConsumption) != asnFALSE)
    {
      indPowerConsumption = object->indPowerConsumption;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_dcDcActvd) != asnFALSE)
    {
      dcDcActvd = object->dcDcActvd;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_dcDcConnectStatus) != asnFALSE)
    {
      dcDcConnectStatus = object->dcDcConnectStatus;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_dcChargeIAct) != asnFALSE)
    {
      dcChargeIAct = object->dcChargeIAct;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_dcChargeSts) != asnFALSE)
    {
      dcChargeSts = object->dcChargeSts;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_wptObjt) != asnFALSE)
    {
      wptObjt = object->wptObjt;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_wptFineAlignt) != asnFALSE)
    {
      wptFineAlignt = object->wptFineAlignt;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_wptActived) != asnFALSE)
    {
      wptActived = object->wptActived;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_wptChargeIAct) != asnFALSE)
    {
      wptChargeIAct = object->wptChargeIAct;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_wptChargeUAct) != asnFALSE)
    {
      wptChargeUAct = object->wptChargeUAct;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_wptChargeSts) != asnFALSE)
    {
      wptChargeSts = object->wptChargeSts;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_chargeIAct) != asnFALSE)
    {
      chargeIAct = object->chargeIAct;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_chargeUAct) != asnFALSE)
    {
      chargeUAct = object->chargeUAct;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_chargeSts) != asnFALSE)
    {
      chargeSts = object->chargeSts;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_disChargeConnectStatus) != asnFALSE)
    {
      disChargeConnectStatus = object->disChargeConnectStatus;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_disChargeIAct) != asnFALSE)
    {
      disChargeIAct = object->disChargeIAct;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_disChargeUAct) != asnFALSE)
    {
      disChargeUAct = object->disChargeUAct;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_disChargeSts) != asnFALSE)
    {
      disChargeSts = object->disChargeSts;
    }
 }
}

/**
 *    TypeAssignment : FragItem
 *    Class constructor
 */
FragItem::FragItem(const FragItem& object)
  : asntype()  ,optional(object.optional.length, optionalField)
  ,id()
  ,activated()
  ,level()
  ,code()

{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : FragItem
 * Copy method
 */
void FragItem::__copy (const asntype& obj)
{
  const FragItem* object = asnSCast(const FragItem*,&obj);
  optionalField[0] = object->optionalField[0];
 {
    id = object->id;
 }
 {
    activated = object->activated;
 }
 {
    if(asnGetPresence(object->optionalField,asn_level) != asnFALSE)
    {
      level = object->level;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_FragItem__code) != asnFALSE)
    {
      this->code.__copy (object->code);
    }
 }
}

/**
 *    TypeAssignment : FragStrs
 *    Class constructor
 */
FragStrs::FragStrs(const FragStrs& object)
  : asntype()  ,optional(object.optional.length, optionalField)
  ,activated()
  ,number()
  ,items()

{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : FragStrs
 * Copy method
 */
void FragStrs::__copy (const asntype& obj)
{
  const FragStrs* object = asnSCast(const FragStrs*,&obj);
  optionalField[0] = object->optionalField[0];
 {
    activated = object->activated;
 }
 {
    if(asnGetPresence(object->optionalField,asn_number) != asnFALSE)
    {
      number = object->number;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_FragStrs__items) != asnFALSE)
    {
      asncFragStrs__itemss *elt_asncFragStrs__itemss;
      elt_asncFragStrs__itemss = (asncFragStrs__itemss*) object->items.firstElement;
      for (asnMAXUINT countitems=0; countitems<object->items.count; countitems++)
      {
        items.addElement(new asncFragStrs__itemss(*elt_asncFragStrs__itemss));
        elt_asncFragStrs__itemss = (asncFragStrs__itemss*) elt_asncFragStrs__itemss->nextElement;
      }
    }
 }
}

/**
 *    TypeAssignment : GenericVehicleSignal
 *    Class constructor
 */
GenericVehicleSignal::GenericVehicleSignal(const GenericVehicleSignal& object)
  : asntype()  ,optional(object.optional.length, optionalField)
  ,key()
  ,collectTime()
  ,value()
  ,stringVal()
  ,boolVal()
  ,timestampVal()
  ,dataVal()

{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : GenericVehicleSignal
 * Copy method
 */
void GenericVehicleSignal::__copy (const asntype& obj)
{
  const GenericVehicleSignal* object = asnSCast(const GenericVehicleSignal*,&obj);
  optionalField[0] = object->optionalField[0];
 {
    this->key.__copy (object->key);
 }
 {
    if(asnGetPresence(object->optionalField,asn_collectTime) != asnFALSE)
    {
      if(object->collectTime != (TimeStamp *)asnBNULL)
      {
        collectTime = (TimeStamp*)object->collectTime->__create();
        collectTime->__copy(*object->collectTime);
      }
      else
      {
        collectTime = (TimeStamp *) 0;
      }
    }
    else
    {
      this->collectTime = (TimeStamp*) asnBNULL;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_value) != asnFALSE)
    {
      value = object->value;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_GenericVehicleSignal__stringVal) != asnFALSE)
    {
      this->stringVal.__copy (object->stringVal);
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_GenericVehicleSignal__boolVal) != asnFALSE)
    {
      boolVal = object->boolVal;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_GenericVehicleSignal__timestampVal) != asnFALSE)
    {
      if(object->timestampVal != (TimeStamp *)asnBNULL)
      {
        timestampVal = (TimeStamp*)object->timestampVal->__create();
        timestampVal->__copy(*object->timestampVal);
      }
      else
      {
        timestampVal = (TimeStamp *) 0;
      }
    }
    else
    {
      this->timestampVal = (TimeStamp*) asnBNULL;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_GenericVehicleSignal__dataVal) != asnFALSE)
    {
      this->dataVal.__copy(object->dataVal);
    }
 }
}

/**
 *    TypeAssignment : LockStatus
 *    Class constructor
 */
LockStatus::LockStatus(const LockStatus& object)
  : asntype()  ,optional(object.optional.length, optionalField)
  ,winStatusDriver()
  ,winStatusPassenger()
  ,winStatusDriverRear()
  ,winStatusPassengerRear()
  ,winStatusDriverWarning()
  ,winStatusPassengerWarning()
  ,winStatusDriverRearWarning()
  ,winStatusPassengerRearWarning()
  ,winPosDriver()
  ,winPosPassenger()
  ,winPosDriverRear()
  ,winPosPassengerRear()
  ,sunroofOpenStatus()
  ,sunroofPos()
  ,sunroofOpenStatusWarning()
  ,curtainOpenStatus()
  ,curtainPos()
  ,curtainWarning()
  ,tankFlapStatus()
  ,chargeLidRearStatus()
  ,chargeLidFrontStatus()
  ,ventilateStatus()
  ,doorOpenStatusDriver()
  ,doorOpenStatusPassenger()
  ,doorOpenStatusDriverRear()
  ,doorOpenStatusPassengerRear()
  ,doorPosDriver()
  ,doorPosPassenger()
  ,doorPosDriverRear()
  ,doorPosPassengerRear()
  ,doorLockStatusDriver()
  ,doorLockStatusPassenger()
  ,doorLockStatusDriverRear()
  ,doorLockStatusPassengerRear()
  ,doorGripStatusDriver()
  ,doorGripStatusPassenger()
  ,doorGripStatusDriverRear()
  ,doorGripStatusPassengerRear()
  ,trunkOpenStatus()
  ,trunkLockStatus()
  ,engineHoodOpenStatus()
  ,engineHoodLockStatus()
  ,centralLockingStatus()
  ,centralLockingDisStatus()
  ,privateLockStatus()
  ,vehicleAlarm()
  ,winCloseReminder()
  ,handBrakeStatus()
  ,electricParkBrakeStatus()

{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : LockStatus
 * Copy method
 */
void LockStatus::__copy (const asntype& obj)
{
  const LockStatus* object = asnSCast(const LockStatus*,&obj);
  optionalField[0] = object->optionalField[0];
  optionalField[1] = object->optionalField[1];
  optionalField[2] = object->optionalField[2];
  optionalField[3] = object->optionalField[3];
  optionalField[4] = object->optionalField[4];
  optionalField[5] = object->optionalField[5];
  optionalField[6] = object->optionalField[6];
 {
    if(asnGetPresence(object->optionalField,asn_winStatusDriver) != asnFALSE)
    {
      winStatusDriver = object->winStatusDriver;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_winStatusPassenger) != asnFALSE)
    {
      winStatusPassenger = object->winStatusPassenger;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_winStatusDriverRear) != asnFALSE)
    {
      winStatusDriverRear = object->winStatusDriverRear;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_winStatusPassengerRear) != asnFALSE)
    {
      winStatusPassengerRear = object->winStatusPassengerRear;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_winStatusDriverWarning) != asnFALSE)
    {
      winStatusDriverWarning = object->winStatusDriverWarning;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_winStatusPassengerWarning) != asnFALSE)
    {
      winStatusPassengerWarning = object->winStatusPassengerWarning;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_winStatusDriverRearWarning) != asnFALSE)
    {
      winStatusDriverRearWarning = object->winStatusDriverRearWarning;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_winStatusPassengerRearWarning) != asnFALSE)
    {
      winStatusPassengerRearWarning = object->winStatusPassengerRearWarning;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_winPosDriver) != asnFALSE)
    {
      winPosDriver = object->winPosDriver;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_winPosPassenger) != asnFALSE)
    {
      winPosPassenger = object->winPosPassenger;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_winPosDriverRear) != asnFALSE)
    {
      winPosDriverRear = object->winPosDriverRear;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_winPosPassengerRear) != asnFALSE)
    {
      winPosPassengerRear = object->winPosPassengerRear;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_sunroofOpenStatus) != asnFALSE)
    {
      sunroofOpenStatus = object->sunroofOpenStatus;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_sunroofPos) != asnFALSE)
    {
      sunroofPos = object->sunroofPos;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_sunroofOpenStatusWarning) != asnFALSE)
    {
      sunroofOpenStatusWarning = object->sunroofOpenStatusWarning;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_curtainOpenStatus) != asnFALSE)
    {
      curtainOpenStatus = object->curtainOpenStatus;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_curtainPos) != asnFALSE)
    {
      curtainPos = object->curtainPos;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_curtainWarning) != asnFALSE)
    {
      curtainWarning = object->curtainWarning;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_tankFlapStatus) != asnFALSE)
    {
      tankFlapStatus = object->tankFlapStatus;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_chargeLidRearStatus) != asnFALSE)
    {
      chargeLidRearStatus = object->chargeLidRearStatus;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_chargeLidFrontStatus) != asnFALSE)
    {
      chargeLidFrontStatus = object->chargeLidFrontStatus;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_ventilateStatus) != asnFALSE)
    {
      ventilateStatus = object->ventilateStatus;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_doorOpenStatusDriver) != asnFALSE)
    {
      doorOpenStatusDriver = object->doorOpenStatusDriver;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_doorOpenStatusPassenger) != asnFALSE)
    {
      doorOpenStatusPassenger = object->doorOpenStatusPassenger;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_doorOpenStatusDriverRear) != asnFALSE)
    {
      doorOpenStatusDriverRear = object->doorOpenStatusDriverRear;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_doorOpenStatusPassengerRear) != asnFALSE)
    {
      doorOpenStatusPassengerRear = object->doorOpenStatusPassengerRear;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_doorPosDriver) != asnFALSE)
    {
      doorPosDriver = object->doorPosDriver;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_doorPosPassenger) != asnFALSE)
    {
      doorPosPassenger = object->doorPosPassenger;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_doorPosDriverRear) != asnFALSE)
    {
      doorPosDriverRear = object->doorPosDriverRear;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_doorPosPassengerRear) != asnFALSE)
    {
      doorPosPassengerRear = object->doorPosPassengerRear;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_doorLockStatusDriver) != asnFALSE)
    {
      doorLockStatusDriver = object->doorLockStatusDriver;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_doorLockStatusPassenger) != asnFALSE)
    {
      doorLockStatusPassenger = object->doorLockStatusPassenger;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_doorLockStatusDriverRear) != asnFALSE)
    {
      doorLockStatusDriverRear = object->doorLockStatusDriverRear;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_doorLockStatusPassengerRear) != asnFALSE)
    {
      doorLockStatusPassengerRear = object->doorLockStatusPassengerRear;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_doorGripStatusDriver) != asnFALSE)
    {
      doorGripStatusDriver = object->doorGripStatusDriver;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_doorGripStatusPassenger) != asnFALSE)
    {
      doorGripStatusPassenger = object->doorGripStatusPassenger;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_doorGripStatusDriverRear) != asnFALSE)
    {
      doorGripStatusDriverRear = object->doorGripStatusDriverRear;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_doorGripStatusPassengerRear) != asnFALSE)
    {
      doorGripStatusPassengerRear = object->doorGripStatusPassengerRear;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_trunkOpenStatus) != asnFALSE)
    {
      trunkOpenStatus = object->trunkOpenStatus;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_trunkLockStatus) != asnFALSE)
    {
      trunkLockStatus = object->trunkLockStatus;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_engineHoodOpenStatus) != asnFALSE)
    {
      engineHoodOpenStatus = object->engineHoodOpenStatus;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_engineHoodLockStatus) != asnFALSE)
    {
      engineHoodLockStatus = object->engineHoodLockStatus;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_centralLockingStatus) != asnFALSE)
    {
      centralLockingStatus = object->centralLockingStatus;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_centralLockingDisStatus) != asnFALSE)
    {
      centralLockingDisStatus = object->centralLockingDisStatus;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_privateLockStatus) != asnFALSE)
    {
      privateLockStatus = object->privateLockStatus;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_vehicleAlarm) != asnFALSE)
    {
      vehicleAlarm = object->vehicleAlarm;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_winCloseReminder) != asnFALSE)
    {
      winCloseReminder = object->winCloseReminder;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_handBrakeStatus) != asnFALSE)
    {
      handBrakeStatus = object->handBrakeStatus;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_electricParkBrakeStatus) != asnFALSE)
    {
      electricParkBrakeStatus = object->electricParkBrakeStatus;
    }
 }
}

/**
 *    TypeAssignment : MaintenanceStatus
 *    Class constructor
 */
MaintenanceStatus::MaintenanceStatus(const MaintenanceStatus& object)
  : asntype()  ,optional(object.optional.length, optionalField)
  ,mainBatteryStatus()
  ,tyreStatusDriver()
  ,tyreStatusPassenger()
  ,tyreStatusDriverRear()
  ,tyreStatusPassengerRear()
  ,tyreTempDriver()
  ,tyreTempPassenger()
  ,tyreTempDriverRear()
  ,tyreTempPassengerRear()
  ,engineHrsToService()
  ,distanceToService()
  ,daysToService()
  ,serviceWarningStatus()
  ,serviceWarningTrigger()
  ,engineOilLevelStatus()
  ,engineOilTemperature()
  ,engineOilPressureWarning()
  ,engineCoolantTemperature()
  ,engineCoolantLevelStatus()
  ,brakeFluidLevelStatus()
  ,washerFluidLevelStatus()
  ,indcrTurnLeWarning()
  ,indcrTurnRiWarning()
  ,indcrTurnOnPassSideWarning()
  ,indcrTurnOnDrvrSideWarning()
  ,indcrTurnLeFrntWarning()
  ,indcrTurnRiFrntWarning()
  ,fogLiReWarning()
  ,bulbStatus()

{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : MaintenanceStatus
 * Copy method
 */
void MaintenanceStatus::__copy (const asntype& obj)
{
  const MaintenanceStatus* object = asnSCast(const MaintenanceStatus*,&obj);
  optionalField[0] = object->optionalField[0];
  optionalField[1] = object->optionalField[1];
  optionalField[2] = object->optionalField[2];
  optionalField[3] = object->optionalField[3];
 {
    if(asnGetPresence(object->optionalField,asn_mainBatteryStatus) != asnFALSE)
    {
      if(object->mainBatteryStatus != (BatteryStatus *)asnBNULL)
      {
        mainBatteryStatus = (BatteryStatus*)object->mainBatteryStatus->__create();
        mainBatteryStatus->__copy(*object->mainBatteryStatus);
      }
      else
      {
        mainBatteryStatus = (BatteryStatus *) 0;
      }
    }
    else
    {
      this->mainBatteryStatus = (BatteryStatus*) asnBNULL;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_tyreStatusDriver) != asnFALSE)
    {
      tyreStatusDriver = object->tyreStatusDriver;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_tyreStatusPassenger) != asnFALSE)
    {
      tyreStatusPassenger = object->tyreStatusPassenger;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_tyreStatusDriverRear) != asnFALSE)
    {
      tyreStatusDriverRear = object->tyreStatusDriverRear;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_tyreStatusPassengerRear) != asnFALSE)
    {
      tyreStatusPassengerRear = object->tyreStatusPassengerRear;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_tyreTempDriver) != asnFALSE)
    {
      tyreTempDriver = object->tyreTempDriver;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_tyreTempPassenger) != asnFALSE)
    {
      tyreTempPassenger = object->tyreTempPassenger;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_tyreTempDriverRear) != asnFALSE)
    {
      tyreTempDriverRear = object->tyreTempDriverRear;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_tyreTempPassengerRear) != asnFALSE)
    {
      tyreTempPassengerRear = object->tyreTempPassengerRear;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_engineHrsToService) != asnFALSE)
    {
      engineHrsToService = object->engineHrsToService;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_distanceToService) != asnFALSE)
    {
      distanceToService = object->distanceToService;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_daysToService) != asnFALSE)
    {
      daysToService = object->daysToService;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_serviceWarningStatus) != asnFALSE)
    {
      serviceWarningStatus = object->serviceWarningStatus;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_serviceWarningTrigger) != asnFALSE)
    {
      serviceWarningTrigger = object->serviceWarningTrigger;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_engineOilLevelStatus) != asnFALSE)
    {
      engineOilLevelStatus = object->engineOilLevelStatus;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_engineOilTemperature) != asnFALSE)
    {
      engineOilTemperature = object->engineOilTemperature;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_engineOilPressureWarning) != asnFALSE)
    {
      engineOilPressureWarning = object->engineOilPressureWarning;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_engineCoolantTemperature) != asnFALSE)
    {
      engineCoolantTemperature = object->engineCoolantTemperature;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_engineCoolantLevelStatus) != asnFALSE)
    {
      engineCoolantLevelStatus = object->engineCoolantLevelStatus;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_brakeFluidLevelStatus) != asnFALSE)
    {
      brakeFluidLevelStatus = object->brakeFluidLevelStatus;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_washerFluidLevelStatus) != asnFALSE)
    {
      washerFluidLevelStatus = object->washerFluidLevelStatus;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_indcrTurnLeWarning) != asnFALSE)
    {
      indcrTurnLeWarning = object->indcrTurnLeWarning;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_indcrTurnRiWarning) != asnFALSE)
    {
      indcrTurnRiWarning = object->indcrTurnRiWarning;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_indcrTurnOnPassSideWarning) != asnFALSE)
    {
      indcrTurnOnPassSideWarning = object->indcrTurnOnPassSideWarning;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_indcrTurnOnDrvrSideWarning) != asnFALSE)
    {
      indcrTurnOnDrvrSideWarning = object->indcrTurnOnDrvrSideWarning;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_indcrTurnLeFrntWarning) != asnFALSE)
    {
      indcrTurnLeFrntWarning = object->indcrTurnLeFrntWarning;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_indcrTurnRiFrntWarning) != asnFALSE)
    {
      indcrTurnRiFrntWarning = object->indcrTurnRiFrntWarning;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_fogLiReWarning) != asnFALSE)
    {
      fogLiReWarning = object->fogLiReWarning;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_bulbStatus) != asnFALSE)
    {
      bulbStatus = object->bulbStatus;
    }
 }
}

/**
 *    TypeAssignment : NetworkAccessStatus
 *    Class constructor
 */
NetworkAccessStatus::NetworkAccessStatus(const NetworkAccessStatus& object)
  : asntype()  ,optional(object.optional.length, optionalField)
  ,simInfo()
  ,mobileNetwork()

{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : NetworkAccessStatus
 * Copy method
 */
void NetworkAccessStatus::__copy (const asntype& obj)
{
  const NetworkAccessStatus* object = asnSCast(const NetworkAccessStatus*,&obj);
  optionalField[0] = object->optionalField[0];
 {
    if(asnGetPresence(object->optionalField,asn_simInfo) != asnFALSE)
    {
      if(object->simInfo != (SIMInfo *)asnBNULL)
      {
        simInfo = (SIMInfo*)object->simInfo->__create();
        simInfo->__copy(*object->simInfo);
      }
      else
      {
        simInfo = (SIMInfo *) 0;
      }
    }
    else
    {
      this->simInfo = (SIMInfo*) asnBNULL;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_mobileNetwork) != asnFALSE)
    {
      this->mobileNetwork.__copy (object->mobileNetwork);
    }
 }
}

/**
 *    TypeAssignment : OEMMSD
 *    Class constructor
 */
OEMMSD::OEMMSD(const OEMMSD& object)
  : asntype()  ,optional(object.optional.length, optionalField)
  ,automaticActivation()
  ,testCall()
  ,position()
  ,vehicleType()
  ,vin()
  ,fuelType()
  ,direction()
  ,numberOfPassengers()
  ,recentPositions()
  ,speed()
  ,speedValidity()
  ,signals()

{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : OEMMSD
 * Copy method
 */
void OEMMSD::__copy (const asntype& obj)
{
  const OEMMSD* object = asnSCast(const OEMMSD*,&obj);
  optionalField[0] = object->optionalField[0];
 {
    automaticActivation = object->automaticActivation;
 }
 {
    testCall = object->testCall;
 }
 {
    if(object->position != (Position *)asnBNULL)
    {
      position = (Position*)object->position->__create();
      position->__copy(*object->position);
    }
    else
    {
      position = (Position *) 0;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_vehicleType) != asnFALSE)
    {
      vehicleType = object->vehicleType;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_OEMMSD__vin) != asnFALSE)
    {
      this->vin.__copy (object->vin);
    }
 }
 {
    fuelType = object->fuelType;
 }
 {
    direction = object->direction;
 }
 {
    if(asnGetPresence(object->optionalField,asn_numberOfPassengers) != asnFALSE)
    {
      numberOfPassengers = object->numberOfPassengers;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_recentPositions) != asnFALSE)
    {
      asncrecentPositionss *elt_asncrecentPositionss;
      elt_asncrecentPositionss = (asncrecentPositionss*) object->recentPositions.firstElement;
      for (asnMAXUINT countrecentPositions=0; countrecentPositions<object->recentPositions.count; countrecentPositions++)
      {
        recentPositions.addElement(new asncrecentPositionss(*elt_asncrecentPositionss));
        elt_asncrecentPositionss = (asncrecentPositionss*) elt_asncrecentPositionss->nextElement;
      }
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_speed) != asnFALSE)
    {
      speed = object->speed;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_OEMMSD__speedValidity) != asnFALSE)
    {
      speedValidity = object->speedValidity;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_OEMMSD__signals) != asnFALSE)
    {
      asncOEMMSD__signalss *elt_asncOEMMSD__signalss;
      elt_asncOEMMSD__signalss = (asncOEMMSD__signalss*) object->signals.firstElement;
      for (asnMAXUINT countsignals=0; countsignals<object->signals.count; countsignals++)
      {
        signals.addElement(new asncOEMMSD__signalss(*elt_asncOEMMSD__signalss));
        elt_asncOEMMSD__signalss = (asncOEMMSD__signalss*) elt_asncOEMMSD__signalss->nextElement;
      }
    }
 }
}

/**
 *    TypeAssignment : PollutionStatus
 *    Class constructor
 */
PollutionStatus::PollutionStatus(const PollutionStatus& object)
  : asntype()  ,optional(object.optional.length, optionalField)
  ,interiorPM25()
  ,exteriorPM25()
  ,interiorPM25Level()
  ,exteriorPM25Level()
  ,airQualityIndex()
  ,airParticleConcentration()

{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : PollutionStatus
 * Copy method
 */
void PollutionStatus::__copy (const asntype& obj)
{
  const PollutionStatus* object = asnSCast(const PollutionStatus*,&obj);
  optionalField[0] = object->optionalField[0];
 {
    if(asnGetPresence(object->optionalField,asn_interiorPM25) != asnFALSE)
    {
      interiorPM25 = object->interiorPM25;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_exteriorPM25) != asnFALSE)
    {
      exteriorPM25 = object->exteriorPM25;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_interiorPM25Level) != asnFALSE)
    {
      interiorPM25Level = object->interiorPM25Level;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_exteriorPM25Level) != asnFALSE)
    {
      exteriorPM25Level = object->exteriorPM25Level;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_airQualityIndex) != asnFALSE)
    {
      airQualityIndex = object->airQualityIndex;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_airParticleConcentration) != asnFALSE)
    {
      airParticleConcentration = object->airParticleConcentration;
    }
 }
}

/**
 *    TypeAssignment : RunningStatus
 *    Class constructor
 */
RunningStatus::RunningStatus(const RunningStatus& object)
  : asntype()  ,optional(object.optional.length, optionalField)
  ,srsStatus()
  ,srsCrashStatus()
  ,odometer()
  ,fuelLevel()
  ,fuelLevelStatus()
  ,fuelEnLevel()
  ,fuelEnCnsFild()
  ,fuelEnCns()
  ,fuelLow1WarningDriver()
  ,fuelLow2WarningDriver()
  ,distanceToEmpty()
  ,trvlDistance()
  ,aveFuelConsumption()
  ,aveFuelConsumptionInLatestDrivingCycle()
  ,avgSpeed()
  ,avgSpeedLatestDrivingCycle()
  ,aveFuelConsumptionUnit()
  ,indFuelConsumption()
  ,notifForEmgyCallStatus()
  ,tyrePreWarningDriver()
  ,tyrePreWarningPassenger()
  ,tyrePreWarningDriverRear()
  ,tyrePreWarningPassengerRear()
  ,tyreTempWarningDriver()
  ,tyreTempWarningPassenger()
  ,tyreTempWarningDriverRear()
  ,tyreTempWarningPassengerRear()
  ,seatBeltStatusDriver()
  ,seatBeltStatusPassenger()
  ,seatBeltStatusDriverRear()
  ,seatBeltStatusPassengerRear()
  ,seatBeltStatusMidRear()
  ,seatBeltStatusThDriverRear()
  ,seatBeltStatusThPassengerRear()
  ,seatBeltStatusThMidRear()
  ,brakePedalDepressed()
  ,gearManualStatus()
  ,gearAutoStatus()
  ,engineSpeed()
  ,transimissionGearPostion()
  ,cruiseControlStatus()
  ,engineBlockedStatus()
  ,tripMeter1()
  ,tripMeter2()

{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : RunningStatus
 * Copy method
 */
void RunningStatus::__copy (const asntype& obj)
{
  const RunningStatus* object = asnSCast(const RunningStatus*,&obj);
  optionalField[0] = object->optionalField[0];
  optionalField[1] = object->optionalField[1];
  optionalField[2] = object->optionalField[2];
  optionalField[3] = object->optionalField[3];
  optionalField[4] = object->optionalField[4];
  optionalField[5] = object->optionalField[5];
 {
    if(asnGetPresence(object->optionalField,asn_srsStatus) != asnFALSE)
    {
      srsStatus = object->srsStatus;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_srsCrashStatus) != asnFALSE)
    {
      srsCrashStatus = object->srsCrashStatus;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_RunningStatus__odometer) != asnFALSE)
    {
      odometer = object->odometer;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_fuelLevel) != asnFALSE)
    {
      fuelLevel = object->fuelLevel;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_fuelLevelStatus) != asnFALSE)
    {
      fuelLevelStatus = object->fuelLevelStatus;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_fuelEnLevel) != asnFALSE)
    {
      fuelEnLevel = object->fuelEnLevel;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_fuelEnCnsFild) != asnFALSE)
    {
      fuelEnCnsFild = object->fuelEnCnsFild;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_fuelEnCns) != asnFALSE)
    {
      fuelEnCns = object->fuelEnCns;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_fuelLow1WarningDriver) != asnFALSE)
    {
      fuelLow1WarningDriver = object->fuelLow1WarningDriver;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_fuelLow2WarningDriver) != asnFALSE)
    {
      fuelLow2WarningDriver = object->fuelLow2WarningDriver;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_distanceToEmpty) != asnFALSE)
    {
      distanceToEmpty = object->distanceToEmpty;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_trvlDistance) != asnFALSE)
    {
      trvlDistance = object->trvlDistance;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_aveFuelConsumption) != asnFALSE)
    {
      aveFuelConsumption = object->aveFuelConsumption;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_aveFuelConsumptionInLatestDrivingCycle) != asnFALSE)
    {
      aveFuelConsumptionInLatestDrivingCycle = object->aveFuelConsumptionInLatestDrivingCycle;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_avgSpeed) != asnFALSE)
    {
      avgSpeed = object->avgSpeed;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_avgSpeedLatestDrivingCycle) != asnFALSE)
    {
      avgSpeedLatestDrivingCycle = object->avgSpeedLatestDrivingCycle;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_aveFuelConsumptionUnit) != asnFALSE)
    {
      this->aveFuelConsumptionUnit.__copy (object->aveFuelConsumptionUnit);
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_indFuelConsumption) != asnFALSE)
    {
      indFuelConsumption = object->indFuelConsumption;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_notifForEmgyCallStatus) != asnFALSE)
    {
      notifForEmgyCallStatus = object->notifForEmgyCallStatus;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_tyrePreWarningDriver) != asnFALSE)
    {
      tyrePreWarningDriver = object->tyrePreWarningDriver;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_tyrePreWarningPassenger) != asnFALSE)
    {
      tyrePreWarningPassenger = object->tyrePreWarningPassenger;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_tyrePreWarningDriverRear) != asnFALSE)
    {
      tyrePreWarningDriverRear = object->tyrePreWarningDriverRear;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_tyrePreWarningPassengerRear) != asnFALSE)
    {
      tyrePreWarningPassengerRear = object->tyrePreWarningPassengerRear;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_tyreTempWarningDriver) != asnFALSE)
    {
      tyreTempWarningDriver = object->tyreTempWarningDriver;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_tyreTempWarningPassenger) != asnFALSE)
    {
      tyreTempWarningPassenger = object->tyreTempWarningPassenger;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_tyreTempWarningDriverRear) != asnFALSE)
    {
      tyreTempWarningDriverRear = object->tyreTempWarningDriverRear;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_tyreTempWarningPassengerRear) != asnFALSE)
    {
      tyreTempWarningPassengerRear = object->tyreTempWarningPassengerRear;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_seatBeltStatusDriver) != asnFALSE)
    {
      seatBeltStatusDriver = object->seatBeltStatusDriver;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_seatBeltStatusPassenger) != asnFALSE)
    {
      seatBeltStatusPassenger = object->seatBeltStatusPassenger;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_seatBeltStatusDriverRear) != asnFALSE)
    {
      seatBeltStatusDriverRear = object->seatBeltStatusDriverRear;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_seatBeltStatusPassengerRear) != asnFALSE)
    {
      seatBeltStatusPassengerRear = object->seatBeltStatusPassengerRear;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_seatBeltStatusMidRear) != asnFALSE)
    {
      seatBeltStatusMidRear = object->seatBeltStatusMidRear;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_seatBeltStatusThDriverRear) != asnFALSE)
    {
      seatBeltStatusThDriverRear = object->seatBeltStatusThDriverRear;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_seatBeltStatusThPassengerRear) != asnFALSE)
    {
      seatBeltStatusThPassengerRear = object->seatBeltStatusThPassengerRear;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_seatBeltStatusThMidRear) != asnFALSE)
    {
      seatBeltStatusThMidRear = object->seatBeltStatusThMidRear;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_brakePedalDepressed) != asnFALSE)
    {
      brakePedalDepressed = object->brakePedalDepressed;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_gearManualStatus) != asnFALSE)
    {
      gearManualStatus = object->gearManualStatus;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_gearAutoStatus) != asnFALSE)
    {
      gearAutoStatus = object->gearAutoStatus;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_engineSpeed) != asnFALSE)
    {
      engineSpeed = object->engineSpeed;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_transimissionGearPostion) != asnFALSE)
    {
      transimissionGearPostion = object->transimissionGearPostion;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_cruiseControlStatus) != asnFALSE)
    {
      cruiseControlStatus = object->cruiseControlStatus;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_engineBlockedStatus) != asnFALSE)
    {
      engineBlockedStatus = object->engineBlockedStatus;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_tripMeter1) != asnFALSE)
    {
      tripMeter1 = object->tripMeter1;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_tripMeter2) != asnFALSE)
    {
      tripMeter2 = object->tripMeter2;
    }
 }
}

/**
 *    TypeAssignment : SIMInfo
 *    Class constructor
 */
SIMInfo::SIMInfo(const SIMInfo& object)
  : asntype()  ,optional(object.optional.length, optionalField)
  ,msisdn()
  ,imsi()
  ,iccId()

{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : SIMInfo
 * Copy method
 */
void SIMInfo::__copy (const asntype& obj)
{
  const SIMInfo* object = asnSCast(const SIMInfo*,&obj);
  optionalField[0] = object->optionalField[0];
 {
    if(asnGetPresence(object->optionalField,asn_msisdn) != asnFALSE)
    {
      this->msisdn.__copy (object->msisdn);
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_imsi) != asnFALSE)
    {
      this->imsi.__copy (object->imsi);
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_iccId) != asnFALSE)
    {
      this->iccId.__copy (object->iccId);
    }
 }
}

/**
 *    TypeAssignment : TEMStatus
 *    Class constructor
 */
TEMStatus::TEMStatus(const TEMStatus& object)
  : asntype()  ,optional(object.optional.length, optionalField)
  ,vin()
  ,powerSource()
  ,powerMode()
  ,state()
  ,serviceProvisoned()
  ,healthStatus()
  ,diagnostics()
  ,backupBattery()
  ,sleepCycleNextWakeupTime()
  ,serialNumber()
  ,completeECUPartNumbers()
  ,networkAccessStatus()
  ,imei()
  ,connectivityStatus()
  ,hwVersion()
  ,swVersion()
  ,mpuVersion()
  ,mcuVersion()

{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : TEMStatus
 * Copy method
 */
void TEMStatus::__copy (const asntype& obj)
{
  const TEMStatus* object = asnSCast(const TEMStatus*,&obj);
  optionalField[0] = object->optionalField[0];
  optionalField[1] = object->optionalField[1];
 {
    if(asnGetPresence(object->optionalField,asn_TEMStatus__vin) != asnFALSE)
    {
      this->vin.__copy (object->vin);
    }
 }
 {
    powerSource = object->powerSource;
 }
 {
    powerMode = object->powerMode;
 }
 {
    if(asnGetPresence(object->optionalField,asn_state) != asnFALSE)
    {
      state = object->state;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_serviceProvisoned) != asnFALSE)
    {
      serviceProvisoned = object->serviceProvisoned;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_healthStatus) != asnFALSE)
    {
      healthStatus = object->healthStatus;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_TEMStatus__diagnostics) != asnFALSE)
    {
      if(object->diagnostics != (ECUDiagnostic *)asnBNULL)
      {
        diagnostics = (ECUDiagnostic*)object->diagnostics->__create();
        diagnostics->__copy(*object->diagnostics);
      }
      else
      {
        diagnostics = (ECUDiagnostic *) 0;
      }
    }
    else
    {
      this->diagnostics = (ECUDiagnostic*) asnBNULL;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_TEMStatus__backupBattery) != asnFALSE)
    {
      if(object->backupBattery != (BatteryStatus *)asnBNULL)
      {
        backupBattery = (BatteryStatus*)object->backupBattery->__create();
        backupBattery->__copy(*object->backupBattery);
      }
      else
      {
        backupBattery = (BatteryStatus *) 0;
      }
    }
    else
    {
      this->backupBattery = (BatteryStatus*) asnBNULL;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_sleepCycleNextWakeupTime) != asnFALSE)
    {
      if(object->sleepCycleNextWakeupTime != (TimeStamp *)asnBNULL)
      {
        sleepCycleNextWakeupTime = (TimeStamp*)object->sleepCycleNextWakeupTime->__create();
        sleepCycleNextWakeupTime->__copy(*object->sleepCycleNextWakeupTime);
      }
      else
      {
        sleepCycleNextWakeupTime = (TimeStamp *) 0;
      }
    }
    else
    {
      this->sleepCycleNextWakeupTime = (TimeStamp*) asnBNULL;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_serialNumber) != asnFALSE)
    {
      this->serialNumber.__copy (object->serialNumber);
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_completeECUPartNumbers) != asnFALSE)
    {
      this->completeECUPartNumbers.__copy (object->completeECUPartNumbers);
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_networkAccessStatus) != asnFALSE)
    {
      if(object->networkAccessStatus != (NetworkAccessStatus *)asnBNULL)
      {
        networkAccessStatus = (NetworkAccessStatus*)object->networkAccessStatus->__create();
        networkAccessStatus->__copy(*object->networkAccessStatus);
      }
      else
      {
        networkAccessStatus = (NetworkAccessStatus *) 0;
      }
    }
    else
    {
      this->networkAccessStatus = (NetworkAccessStatus*) asnBNULL;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_imei) != asnFALSE)
    {
      this->imei.__copy (object->imei);
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_connectivityStatus) != asnFALSE)
    {
      if(object->connectivityStatus != (ConnectivityStatus *)asnBNULL)
      {
        connectivityStatus = (ConnectivityStatus*)object->connectivityStatus->__create();
        connectivityStatus->__copy(*object->connectivityStatus);
      }
      else
      {
        connectivityStatus = (ConnectivityStatus *) 0;
      }
    }
    else
    {
      this->connectivityStatus = (ConnectivityStatus*) asnBNULL;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_hwVersion) != asnFALSE)
    {
      this->hwVersion.__copy (object->hwVersion);
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_TEMStatus__swVersion) != asnFALSE)
    {
      this->swVersion.__copy (object->swVersion);
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_mpuVersion) != asnFALSE)
    {
      this->mpuVersion.__copy (object->mpuVersion);
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_mcuVersion) != asnFALSE)
    {
      this->mcuVersion.__copy (object->mcuVersion);
    }
 }
}

/**
 *    TypeAssignment : TheftNotification
 *    Class constructor
 */
TheftNotification::TheftNotification(const TheftNotification& object)
  : asntype()  ,time()
  ,activated()

{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : TheftNotification
 * Copy method
 */
void TheftNotification::__copy (const asntype& obj)
{
  const TheftNotification* object = asnSCast(const TheftNotification*,&obj);
 {
    if(object->time != (TimeStamp *)asnBNULL)
    {
      time = (TimeStamp*)object->time->__create();
      time->__copy(*object->time);
    }
    else
    {
      time = (TimeStamp *) 0;
    }
 }
 {
    activated = object->activated;
 }
}

/**
 *    TypeAssignment : TimePosition
 *    Class constructor
 */
TimePosition::TimePosition(const TimePosition& object)
  : asntype()  ,optional(object.optional.length, optionalField)
  ,time()
  ,position()

{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : TimePosition
 * Copy method
 */
void TimePosition::__copy (const asntype& obj)
{
  const TimePosition* object = asnSCast(const TimePosition*,&obj);
  optionalField[0] = object->optionalField[0];
 {
    if(asnGetPresence(object->optionalField,asn_TimePosition__time) != asnFALSE)
    {
      if(object->time != (TimeStamp *)asnBNULL)
      {
        time = (TimeStamp*)object->time->__create();
        time->__copy(*object->time);
      }
      else
      {
        time = (TimeStamp *) 0;
      }
    }
    else
    {
      this->time = (TimeStamp*) asnBNULL;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_TimePosition__position) != asnFALSE)
    {
      if(object->position != (Position *)asnBNULL)
      {
        position = (Position*)object->position->__create();
        position->__copy(*object->position);
      }
      else
      {
        position = (Position *) 0;
      }
    }
    else
    {
      this->position = (Position*) asnBNULL;
    }
 }
}

/**
 *    TypeAssignment : TowStatus
 *    Class constructor
 */
TowStatus::TowStatus(const TowStatus& object)
  : asntype()  ,optional(object.optional.length, optionalField)
  ,trailerLampActiveChk()
  ,trailerLampCheckSts()
  ,trailerBreakLampSts()
  ,trailerFogLampSts()
  ,trailerPosLampSts()
  ,trailerTurningLampSts()
  ,trailerReversingLampSts()

{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : TowStatus
 * Copy method
 */
void TowStatus::__copy (const asntype& obj)
{
  const TowStatus* object = asnSCast(const TowStatus*,&obj);
  optionalField[0] = object->optionalField[0];
 {
    if(asnGetPresence(object->optionalField,asn_trailerLampActiveChk) != asnFALSE)
    {
      trailerLampActiveChk = object->trailerLampActiveChk;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_trailerLampCheckSts) != asnFALSE)
    {
      trailerLampCheckSts = object->trailerLampCheckSts;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_trailerBreakLampSts) != asnFALSE)
    {
      trailerBreakLampSts = object->trailerBreakLampSts;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_trailerFogLampSts) != asnFALSE)
    {
      trailerFogLampSts = object->trailerFogLampSts;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_trailerPosLampSts) != asnFALSE)
    {
      trailerPosLampSts = object->trailerPosLampSts;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_trailerTurningLampSts) != asnFALSE)
    {
      trailerTurningLampSts = object->trailerTurningLampSts;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_trailerReversingLampSts) != asnFALSE)
    {
      trailerReversingLampSts = object->trailerReversingLampSts;
    }
 }
}

/**
 *    TypeAssignment : VehicleStatus
 *    Class constructor
 */
VehicleStatus::VehicleStatus(const VehicleStatus& object)
  : asntype()  ,optional(object.optional.length, optionalField)
  ,basicVehicleStatus()
  ,lockStatus()
  ,maintenanceStatus()
  ,runningStatus()
  ,climateStatus()
  ,electricStatus()
  ,pollutionStatus()
  ,temStatus()
  ,carConfig()
  ,additionalStatus()
  ,msd()
  ,diagnostics()
  ,theftNotification()
  ,notification()

{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : VehicleStatus
 * Copy method
 */
void VehicleStatus::__copy (const asntype& obj)
{
  const VehicleStatus* object = asnSCast(const VehicleStatus*,&obj);
  optionalField[0] = object->optionalField[0];
  optionalField[1] = object->optionalField[1];
 {
    if(asnGetPresence(object->optionalField,asn_basicVehicleStatus) != asnFALSE)
    {
      if(object->basicVehicleStatus != (BasicVehicleStatus *)asnBNULL)
      {
        basicVehicleStatus = (BasicVehicleStatus*)object->basicVehicleStatus->__create();
        basicVehicleStatus->__copy(*object->basicVehicleStatus);
      }
      else
      {
        basicVehicleStatus = (BasicVehicleStatus *) 0;
      }
    }
    else
    {
      this->basicVehicleStatus = (BasicVehicleStatus*) asnBNULL;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_lockStatus) != asnFALSE)
    {
      if(object->lockStatus != (LockStatus *)asnBNULL)
      {
        lockStatus = (LockStatus*)object->lockStatus->__create();
        lockStatus->__copy(*object->lockStatus);
      }
      else
      {
        lockStatus = (LockStatus *) 0;
      }
    }
    else
    {
      this->lockStatus = (LockStatus*) asnBNULL;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_maintenanceStatus) != asnFALSE)
    {
      if(object->maintenanceStatus != (MaintenanceStatus *)asnBNULL)
      {
        maintenanceStatus = (MaintenanceStatus*)object->maintenanceStatus->__create();
        maintenanceStatus->__copy(*object->maintenanceStatus);
      }
      else
      {
        maintenanceStatus = (MaintenanceStatus *) 0;
      }
    }
    else
    {
      this->maintenanceStatus = (MaintenanceStatus*) asnBNULL;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_runningStatus) != asnFALSE)
    {
      if(object->runningStatus != (RunningStatus *)asnBNULL)
      {
        runningStatus = (RunningStatus*)object->runningStatus->__create();
        runningStatus->__copy(*object->runningStatus);
      }
      else
      {
        runningStatus = (RunningStatus *) 0;
      }
    }
    else
    {
      this->runningStatus = (RunningStatus*) asnBNULL;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_climateStatus) != asnFALSE)
    {
      if(object->climateStatus != (ClimateStatus *)asnBNULL)
      {
        climateStatus = (ClimateStatus*)object->climateStatus->__create();
        climateStatus->__copy(*object->climateStatus);
      }
      else
      {
        climateStatus = (ClimateStatus *) 0;
      }
    }
    else
    {
      this->climateStatus = (ClimateStatus*) asnBNULL;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_electricStatus) != asnFALSE)
    {
      if(object->electricStatus != (ElectricStatus *)asnBNULL)
      {
        electricStatus = (ElectricStatus*)object->electricStatus->__create();
        electricStatus->__copy(*object->electricStatus);
      }
      else
      {
        electricStatus = (ElectricStatus *) 0;
      }
    }
    else
    {
      this->electricStatus = (ElectricStatus*) asnBNULL;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_pollutionStatus) != asnFALSE)
    {
      if(object->pollutionStatus != (PollutionStatus *)asnBNULL)
      {
        pollutionStatus = (PollutionStatus*)object->pollutionStatus->__create();
        pollutionStatus->__copy(*object->pollutionStatus);
      }
      else
      {
        pollutionStatus = (PollutionStatus *) 0;
      }
    }
    else
    {
      this->pollutionStatus = (PollutionStatus*) asnBNULL;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_temStatus) != asnFALSE)
    {
      if(object->temStatus != (TEMStatus *)asnBNULL)
      {
        temStatus = (TEMStatus*)object->temStatus->__create();
        temStatus->__copy(*object->temStatus);
      }
      else
      {
        temStatus = (TEMStatus *) 0;
      }
    }
    else
    {
      this->temStatus = (TEMStatus*) asnBNULL;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_carConfig) != asnFALSE)
    {
      if(object->carConfig != (CarConfig *)asnBNULL)
      {
        carConfig = (CarConfig*)object->carConfig->__create();
        carConfig->__copy(*object->carConfig);
      }
      else
      {
        carConfig = (CarConfig *) 0;
      }
    }
    else
    {
      this->carConfig = (CarConfig*) asnBNULL;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_additionalStatus) != asnFALSE)
    {
      if(object->additionalStatus != (AdditionalStatus *)asnBNULL)
      {
        additionalStatus = (AdditionalStatus*)object->additionalStatus->__create();
        additionalStatus->__copy(*object->additionalStatus);
      }
      else
      {
        additionalStatus = (AdditionalStatus *) 0;
      }
    }
    else
    {
      this->additionalStatus = (AdditionalStatus*) asnBNULL;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_msd) != asnFALSE)
    {
      if(object->msd != (OEMMSD *)asnBNULL)
      {
        msd = (OEMMSD*)object->msd->__create();
        msd->__copy(*object->msd);
      }
      else
      {
        msd = (OEMMSD *) 0;
      }
    }
    else
    {
      this->msd = (OEMMSD*) asnBNULL;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_VehicleStatus__diagnostics) != asnFALSE)
    {
      asncECUDiagnosticss *elt_asncECUDiagnosticss;
      elt_asncECUDiagnosticss = (asncECUDiagnosticss*) object->diagnostics.firstElement;
      for (asnMAXUINT countdiagnostics=0; countdiagnostics<object->diagnostics.count; countdiagnostics++)
      {
        diagnostics.addElement(new asncECUDiagnosticss(*elt_asncECUDiagnosticss));
        elt_asncECUDiagnosticss = (asncECUDiagnosticss*) elt_asncECUDiagnosticss->nextElement;
      }
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_theftNotification) != asnFALSE)
    {
      if(object->theftNotification != (TheftNotification *)asnBNULL)
      {
        theftNotification = (TheftNotification*)object->theftNotification->__create();
        theftNotification->__copy(*object->theftNotification);
      }
      else
      {
        theftNotification = (TheftNotification *) 0;
      }
    }
    else
    {
      this->theftNotification = (TheftNotification*) asnBNULL;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_notification) != asnFALSE)
    {
      if(object->notification != (Notification *)asnBNULL)
      {
        notification = (Notification*)object->notification->__create();
        notification->__copy(*object->notification);
      }
      else
      {
        notification = (Notification *) 0;
      }
    }
    else
    {
      this->notification = (Notification*) asnBNULL;
    }
 }
}

#endif // asnCodCopytor
}
