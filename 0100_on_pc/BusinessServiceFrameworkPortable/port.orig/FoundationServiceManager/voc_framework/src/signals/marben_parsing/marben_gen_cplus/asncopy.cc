/*
Copyright (C) 1999-2011 Marben Products. All rights reserved.

THIS FILE IS PROPRIETARY MATERIAL OF MARBEN PRODUCTS.
AND MAY BE USED ONLY BY DIRECT LICENSEES OF ASNSDK PRODUCT.
THIS FILE MAY NOT BE DISTRIBUTED.

===========================================================================

asncopy.cc: C++ API copy constructor methods

Generated by ASNSDK TCE-C++ ASN.1 Compiler v6.0 - REF_8.55 - REF_8.41

===========================================================================
*/

/**@file
 * C++ API copy constructor methods
 */

#include <asn.h>


#ifdef asnCodCopytor
/**
 *    TypeAssignment : RequestBody
 *    Class constructor
 */
RequestBody::RequestBody(const RequestBody& object)
  : asntype()  ,optional(object.optional.length, optionalField)
  ,serviceId()
  ,serviceData()
  ,seq()

{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : RequestBody
 * Copy method
 */
void RequestBody::__copy (const asntype& obj)
{
  const RequestBody* object = asnSCast(const RequestBody*,&obj);
  optionalField[0] = object->optionalField[0];
 {
    if(asnGetPresence(object->optionalField,asn_serviceId) != asnFALSE)
    {
      serviceId = object->serviceId;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_serviceData) != asnFALSE)
    {
      if(object->serviceData != (ServiceData *)asnBNULL)
      {
        serviceData = (ServiceData*)object->serviceData->__create();
        serviceData->__copy(*object->serviceData);
      }
      else
      {
        serviceData = (ServiceData *) 0;
      }
    }
    else
    {
      this->serviceData = (ServiceData*) asnBNULL;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_seq) != asnFALSE)
    {
      seq = object->seq;
    }
 }
}

/**
 *    TypeAssignment : asncserviceParameterss
 *    Class constructor
 */
asncserviceParameterss::asncserviceParameterss(const asncserviceParameterss& object)
  : asnListElement()
  ,optional(object.optional.length, optionalField)
  ,key()
  ,intVal()
  ,stringVal()
  ,boolVal()
  ,timestampVal()
  ,dataVal()
{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : asncserviceParameterss
 * Copy method
 */
void asncserviceParameterss::__copy (const asntype& obj)
{
  const asncserviceParameterss* object = asnSCast(const asncserviceParameterss*,&obj);
  optionalField[0] = object->optionalField[0];
 {
    this->key.__copy (object->key);
 }
 {
    if(asnGetPresence(object->optionalField,asn_intVal) != asnFALSE)
    {
      intVal = object->intVal;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_ServiceParameter__stringVal) != asnFALSE)
    {
      this->stringVal.__copy (object->stringVal);
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_ServiceParameter__boolVal) != asnFALSE)
    {
      boolVal = object->boolVal;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_ServiceParameter__timestampVal) != asnFALSE)
    {
      if(object->timestampVal != (TimeStamp *)asnBNULL)
      {
        timestampVal = (TimeStamp*)object->timestampVal->__create();
        timestampVal->__copy(*object->timestampVal);
      }
      else
      {
        timestampVal = (TimeStamp *) 0;
      }
    }
    else
    {
      this->timestampVal = (TimeStamp*) asnBNULL;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_ServiceParameter__dataVal) != asnFALSE)
    {
      this->dataVal.__copy(object->dataVal);
    }
 }
}

/**
 *    TypeAssignment : asncattributess
 *    Class constructor
 */
asncattributess::asncattributess(const asncattributess& object)
  : asnListElement()
  ,optional(object.optional.length, optionalField)
  ,key()
  ,intVal()
  ,stringVal()
  ,boolVal()
  ,timestampVal()
  ,dataVal()
{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : asncattributess
 * Copy method
 */
void asncattributess::__copy (const asntype& obj)
{
  const asncattributess* object = asnSCast(const asncattributess*,&obj);
  optionalField[0] = object->optionalField[0];
 {
    this->key.__copy (object->key);
 }
 {
    if(asnGetPresence(object->optionalField,asn_intVal) != asnFALSE)
    {
      intVal = object->intVal;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_ServiceParameter__stringVal) != asnFALSE)
    {
      this->stringVal.__copy (object->stringVal);
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_ServiceParameter__boolVal) != asnFALSE)
    {
      boolVal = object->boolVal;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_ServiceParameter__timestampVal) != asnFALSE)
    {
      if(object->timestampVal != (TimeStamp *)asnBNULL)
      {
        timestampVal = (TimeStamp*)object->timestampVal->__create();
        timestampVal->__copy(*object->timestampVal);
      }
      else
      {
        timestampVal = (TimeStamp *) 0;
      }
    }
    else
    {
      this->timestampVal = (TimeStamp*) asnBNULL;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_ServiceParameter__dataVal) != asnFALSE)
    {
      this->dataVal.__copy(object->dataVal);
    }
 }
}

/**
 *    TypeAssignment : asncpoiss
 *    Class constructor
 */
asncpoiss::asncpoiss(const asncpoiss& object)
  : asnListElement()
  ,optional(object.optional.length, optionalField)
  ,name()
  ,position()
  ,type()
  ,contactInfo()
  ,url()
  ,attributes()
{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : asncpoiss
 * Copy method
 */
void asncpoiss::__copy (const asntype& obj)
{
  const asncpoiss* object = asnSCast(const asncpoiss*,&obj);
  optionalField[0] = object->optionalField[0];
 {
    this->name.__copy (object->name);
 }
 {
    if(asnGetPresence(object->optionalField,asn_position) != asnFALSE)
    {
      if(object->position != (Position *)asnBNULL)
      {
        position = (Position*)object->position->__create();
        position->__copy(*object->position);
      }
      else
      {
        position = (Position *) 0;
      }
    }
    else
    {
      this->position = (Position*) asnBNULL;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_type) != asnFALSE)
    {
      this->type.__copy (object->type);
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_contactInfo) != asnFALSE)
    {
      if(object->contactInfo != (ContactInfo *)asnBNULL)
      {
        contactInfo = (ContactInfo*)object->contactInfo->__create();
        contactInfo->__copy(*object->contactInfo);
      }
      else
      {
        contactInfo = (ContactInfo *) 0;
      }
    }
    else
    {
      this->contactInfo = (ContactInfo*) asnBNULL;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_url) != asnFALSE)
    {
      this->url.__copy (object->url);
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_attributes) != asnFALSE)
    {
      asncattributess *elt_asncattributess;
      elt_asncattributess = (asncattributess*) object->attributes.firstElement;
      for (asnMAXUINT countattributes=0; countattributes<object->attributes.count; countattributes++)
      {
        attributes.addElement(new asncattributess(*elt_asncattributess));
        elt_asncattributess = (asncattributess*) elt_asncattributess->nextElement;
      }
    }
 }
}

/**
 *    TypeAssignment : asncConfigurationItem__parameterss
 *    Class constructor
 */
asncConfigurationItem__parameterss::asncConfigurationItem__parameterss(const asncConfigurationItem__parameterss& object)
  : asnListElement()
  ,optional(object.optional.length, optionalField)
  ,key()
  ,intVal()
  ,stringVal()
  ,boolVal()
  ,timestampVal()
  ,dataVal()
{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : asncConfigurationItem__parameterss
 * Copy method
 */
void asncConfigurationItem__parameterss::__copy (const asntype& obj)
{
  const asncConfigurationItem__parameterss* object = asnSCast(const asncConfigurationItem__parameterss*,&obj);
  optionalField[0] = object->optionalField[0];
 {
    this->key.__copy (object->key);
 }
 {
    if(asnGetPresence(object->optionalField,asn_intVal) != asnFALSE)
    {
      intVal = object->intVal;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_ServiceParameter__stringVal) != asnFALSE)
    {
      this->stringVal.__copy (object->stringVal);
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_ServiceParameter__boolVal) != asnFALSE)
    {
      boolVal = object->boolVal;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_ServiceParameter__timestampVal) != asnFALSE)
    {
      if(object->timestampVal != (TimeStamp *)asnBNULL)
      {
        timestampVal = (TimeStamp*)object->timestampVal->__create();
        timestampVal->__copy(*object->timestampVal);
      }
      else
      {
        timestampVal = (TimeStamp *) 0;
      }
    }
    else
    {
      this->timestampVal = (TimeStamp*) asnBNULL;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_ServiceParameter__dataVal) != asnFALSE)
    {
      this->dataVal.__copy(object->dataVal);
    }
 }
}

/**
 *    TypeAssignment : asncitemss
 *    Class constructor
 */
asncitemss::asncitemss(const asncitemss& object)
  : asnListElement()
  ,name()
  ,parameters()
{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : asncitemss
 * Copy method
 */
void asncitemss::__copy (const asntype& obj)
{
  const asncitemss* object = asnSCast(const asncitemss*,&obj);
 {
    this->name.__copy (object->name);
 }
 {
    asncConfigurationItem__parameterss *elt_asncConfigurationItem__parameterss;
    elt_asncConfigurationItem__parameterss = (asncConfigurationItem__parameterss*) object->parameters.firstElement;
    for (asnMAXUINT countparameters=0; countparameters<object->parameters.count; countparameters++)
    {
      parameters.addElement(new asncConfigurationItem__parameterss(*elt_asncConfigurationItem__parameterss));
      elt_asncConfigurationItem__parameterss = (asncConfigurationItem__parameterss*) elt_asncConfigurationItem__parameterss->nextElement;
    }
 }
}

/**
 *    TypeAssignment : asncAdditionalVehicleStatus__signalss
 *    Class constructor
 */
asncAdditionalVehicleStatus__signalss::asncAdditionalVehicleStatus__signalss(const asncAdditionalVehicleStatus__signalss& object)
  : asnListElement()
  ,optional(object.optional.length, optionalField)
  ,key()
  ,collectTime()
  ,value()
  ,stringVal()
  ,boolVal()
  ,timestampVal()
  ,dataVal()
{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : asncAdditionalVehicleStatus__signalss
 * Copy method
 */
void asncAdditionalVehicleStatus__signalss::__copy (const asntype& obj)
{
  const asncAdditionalVehicleStatus__signalss* object = asnSCast(const asncAdditionalVehicleStatus__signalss*,&obj);
  optionalField[0] = object->optionalField[0];
 {
    this->key.__copy (object->key);
 }
 {
    if(asnGetPresence(object->optionalField,asn_collectTime) != asnFALSE)
    {
      if(object->collectTime != (TimeStamp *)asnBNULL)
      {
        collectTime = (TimeStamp*)object->collectTime->__create();
        collectTime->__copy(*object->collectTime);
      }
      else
      {
        collectTime = (TimeStamp *) 0;
      }
    }
    else
    {
      this->collectTime = (TimeStamp*) asnBNULL;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_value) != asnFALSE)
    {
      value = object->value;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_GenericVehicleSignal__stringVal) != asnFALSE)
    {
      this->stringVal.__copy (object->stringVal);
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_GenericVehicleSignal__boolVal) != asnFALSE)
    {
      boolVal = object->boolVal;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_GenericVehicleSignal__timestampVal) != asnFALSE)
    {
      if(object->timestampVal != (TimeStamp *)asnBNULL)
      {
        timestampVal = (TimeStamp*)object->timestampVal->__create();
        timestampVal->__copy(*object->timestampVal);
      }
      else
      {
        timestampVal = (TimeStamp *) 0;
      }
    }
    else
    {
      this->timestampVal = (TimeStamp*) asnBNULL;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_GenericVehicleSignal__dataVal) != asnFALSE)
    {
      this->dataVal.__copy(object->dataVal);
    }
 }
}

/**
 *    TypeAssignment : asncrecentPositionss
 *    Class constructor
 */
asncrecentPositionss::asncrecentPositionss(const asncrecentPositionss& object)
  : asnListElement()
  ,optional(object.optional.length, optionalField)
  ,latitude()
  ,longitude()
  ,altitude()
  ,posCanBeTrusted()
  ,carLocatorStatUploadEn()
  ,marsCoordinates()
{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : asncrecentPositionss
 * Copy method
 */
void asncrecentPositionss::__copy (const asntype& obj)
{
  const asncrecentPositionss* object = asnSCast(const asncrecentPositionss*,&obj);
  optionalField[0] = object->optionalField[0];
 {
    if(asnGetPresence(object->optionalField,asn_latitude) != asnFALSE)
    {
      latitude = object->latitude;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_longitude) != asnFALSE)
    {
      longitude = object->longitude;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_altitude) != asnFALSE)
    {
      altitude = object->altitude;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_posCanBeTrusted) != asnFALSE)
    {
      posCanBeTrusted = object->posCanBeTrusted;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_carLocatorStatUploadEn) != asnFALSE)
    {
      carLocatorStatUploadEn = object->carLocatorStatUploadEn;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_marsCoordinates) != asnFALSE)
    {
      marsCoordinates = object->marsCoordinates;
    }
 }
}

/**
 *    TypeAssignment : asncOEMMSD__signalss
 *    Class constructor
 */
asncOEMMSD__signalss::asncOEMMSD__signalss(const asncOEMMSD__signalss& object)
  : asnListElement()
  ,optional(object.optional.length, optionalField)
  ,key()
  ,collectTime()
  ,value()
  ,stringVal()
  ,boolVal()
  ,timestampVal()
  ,dataVal()
{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : asncOEMMSD__signalss
 * Copy method
 */
void asncOEMMSD__signalss::__copy (const asntype& obj)
{
  const asncOEMMSD__signalss* object = asnSCast(const asncOEMMSD__signalss*,&obj);
  optionalField[0] = object->optionalField[0];
 {
    this->key.__copy (object->key);
 }
 {
    if(asnGetPresence(object->optionalField,asn_collectTime) != asnFALSE)
    {
      if(object->collectTime != (TimeStamp *)asnBNULL)
      {
        collectTime = (TimeStamp*)object->collectTime->__create();
        collectTime->__copy(*object->collectTime);
      }
      else
      {
        collectTime = (TimeStamp *) 0;
      }
    }
    else
    {
      this->collectTime = (TimeStamp*) asnBNULL;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_value) != asnFALSE)
    {
      value = object->value;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_GenericVehicleSignal__stringVal) != asnFALSE)
    {
      this->stringVal.__copy (object->stringVal);
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_GenericVehicleSignal__boolVal) != asnFALSE)
    {
      boolVal = object->boolVal;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_GenericVehicleSignal__timestampVal) != asnFALSE)
    {
      if(object->timestampVal != (TimeStamp *)asnBNULL)
      {
        timestampVal = (TimeStamp*)object->timestampVal->__create();
        timestampVal->__copy(*object->timestampVal);
      }
      else
      {
        timestampVal = (TimeStamp *) 0;
      }
    }
    else
    {
      this->timestampVal = (TimeStamp*) asnBNULL;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_GenericVehicleSignal__dataVal) != asnFALSE)
    {
      this->dataVal.__copy(object->dataVal);
    }
 }
}

/**
 *    TypeAssignment : asncdtcss
 *    Class constructor
 */
asncdtcss::asncdtcss(const asncdtcss& object)
  : asnListElement()
  ,optional(object.optional.length, optionalField)
  ,dtc()
  ,status()
  ,failureCount()
  ,lastFail()
  ,firtFail()
  ,firstFailureOdometer()
  ,firstFailureBatteryVoltage()
  ,firstFailureVehicleSpeed()
{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : asncdtcss
 * Copy method
 */
void asncdtcss::__copy (const asntype& obj)
{
  const asncdtcss* object = asnSCast(const asncdtcss*,&obj);
  optionalField[0] = object->optionalField[0];
 {
    this->dtc.__copy (object->dtc);
 }
 {
    this->status.__copy(object->status);
 }
 {
    if(asnGetPresence(object->optionalField,asn_failureCount) != asnFALSE)
    {
      failureCount = object->failureCount;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_lastFail) != asnFALSE)
    {
      if(object->lastFail != (TimeStamp *)asnBNULL)
      {
        lastFail = (TimeStamp*)object->lastFail->__create();
        lastFail->__copy(*object->lastFail);
      }
      else
      {
        lastFail = (TimeStamp *) 0;
      }
    }
    else
    {
      this->lastFail = (TimeStamp*) asnBNULL;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_firtFail) != asnFALSE)
    {
      if(object->firtFail != (TimeStamp *)asnBNULL)
      {
        firtFail = (TimeStamp*)object->firtFail->__create();
        firtFail->__copy(*object->firtFail);
      }
      else
      {
        firtFail = (TimeStamp *) 0;
      }
    }
    else
    {
      this->firtFail = (TimeStamp*) asnBNULL;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_firstFailureOdometer) != asnFALSE)
    {
      firstFailureOdometer = object->firstFailureOdometer;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_firstFailureBatteryVoltage) != asnFALSE)
    {
      firstFailureBatteryVoltage = object->firstFailureBatteryVoltage;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_firstFailureVehicleSpeed) != asnFALSE)
    {
      firstFailureVehicleSpeed = object->firstFailureVehicleSpeed;
    }
 }
}

/**
 *    TypeAssignment : asncNotification__parameterss
 *    Class constructor
 */
asncNotification__parameterss::asncNotification__parameterss(const asncNotification__parameterss& object)
  : asnListElement()
  ,optional(object.optional.length, optionalField)
  ,key()
  ,intVal()
  ,stringVal()
  ,boolVal()
  ,timestampVal()
  ,dataVal()
{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : asncNotification__parameterss
 * Copy method
 */
void asncNotification__parameterss::__copy (const asntype& obj)
{
  const asncNotification__parameterss* object = asnSCast(const asncNotification__parameterss*,&obj);
  optionalField[0] = object->optionalField[0];
 {
    this->key.__copy (object->key);
 }
 {
    if(asnGetPresence(object->optionalField,asn_intVal) != asnFALSE)
    {
      intVal = object->intVal;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_ServiceParameter__stringVal) != asnFALSE)
    {
      this->stringVal.__copy (object->stringVal);
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_ServiceParameter__boolVal) != asnFALSE)
    {
      boolVal = object->boolVal;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_ServiceParameter__timestampVal) != asnFALSE)
    {
      if(object->timestampVal != (TimeStamp *)asnBNULL)
      {
        timestampVal = (TimeStamp*)object->timestampVal->__create();
        timestampVal->__copy(*object->timestampVal);
      }
      else
      {
        timestampVal = (TimeStamp *) 0;
      }
    }
    else
    {
      this->timestampVal = (TimeStamp*) asnBNULL;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_ServiceParameter__dataVal) != asnFALSE)
    {
      this->dataVal.__copy(object->dataVal);
    }
 }
}

/**
 *    TypeAssignment : asnctrackpointss
 *    Class constructor
 */
asnctrackpointss::asnctrackpointss(const asnctrackpointss& object)
  : asnListElement()
  ,optional(object.optional.length, optionalField)
  ,systemTime()
  ,position()
  ,speed()
  ,direction()
  ,isSVT()
  ,odometer()
  ,travelDistanceSinceLastWaypoint()
  ,fuelConsumptionSinceLastWaypoint()
  ,electricConsumptionSinceLastSample()
  ,electricRegenerationSinceLastSample()
{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : asnctrackpointss
 * Copy method
 */
void asnctrackpointss::__copy (const asntype& obj)
{
  const asnctrackpointss* object = asnSCast(const asnctrackpointss*,&obj);
  optionalField[0] = object->optionalField[0];
 {
    if(object->systemTime != (TimeStamp *)asnBNULL)
    {
      systemTime = (TimeStamp*)object->systemTime->__create();
      systemTime->__copy(*object->systemTime);
    }
    else
    {
      systemTime = (TimeStamp *) 0;
    }
 }
 {
    if(object->position != (Position *)asnBNULL)
    {
      position = (Position*)object->position->__create();
      position->__copy(*object->position);
    }
    else
    {
      position = (Position *) 0;
    }
 }
 {
    speed = object->speed;
 }
 {
    if(asnGetPresence(object->optionalField,asn_TrackPoint__direction) != asnFALSE)
    {
      direction = object->direction;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_isSVT) != asnFALSE)
    {
      isSVT = object->isSVT;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_TrackPoint__odometer) != asnFALSE)
    {
      odometer = object->odometer;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_travelDistanceSinceLastWaypoint) != asnFALSE)
    {
      travelDistanceSinceLastWaypoint = object->travelDistanceSinceLastWaypoint;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_fuelConsumptionSinceLastWaypoint) != asnFALSE)
    {
      fuelConsumptionSinceLastWaypoint = object->fuelConsumptionSinceLastWaypoint;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_electricConsumptionSinceLastSample) != asnFALSE)
    {
      electricConsumptionSinceLastSample = object->electricConsumptionSinceLastSample;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_electricRegenerationSinceLastSample) != asnFALSE)
    {
      electricRegenerationSinceLastSample = object->electricRegenerationSinceLastSample;
    }
 }
}

/**
 *    TypeAssignment : asncwaypointss
 *    Class constructor
 */
asncwaypointss::asncwaypointss(const asncwaypointss& object)
  : asnListElement()
  ,optional(object.optional.length, optionalField)
  ,latitude()
  ,longitude()
  ,altitude()
  ,posCanBeTrusted()
  ,carLocatorStatUploadEn()
  ,marsCoordinates()
{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : asncwaypointss
 * Copy method
 */
void asncwaypointss::__copy (const asntype& obj)
{
  const asncwaypointss* object = asnSCast(const asncwaypointss*,&obj);
  optionalField[0] = object->optionalField[0];
 {
    if(asnGetPresence(object->optionalField,asn_latitude) != asnFALSE)
    {
      latitude = object->latitude;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_longitude) != asnFALSE)
    {
      longitude = object->longitude;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_altitude) != asnFALSE)
    {
      altitude = object->altitude;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_posCanBeTrusted) != asnFALSE)
    {
      posCanBeTrusted = object->posCanBeTrusted;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_carLocatorStatUploadEn) != asnFALSE)
    {
      carLocatorStatUploadEn = object->carLocatorStatUploadEn;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_marsCoordinates) != asnFALSE)
    {
      marsCoordinates = object->marsCoordinates;
    }
 }
}

/**
 *    TypeAssignment : asnctripFragmentss
 *    Class constructor
 */
asnctripFragmentss::asnctripFragmentss(const asnctripFragmentss& object)
  : asnListElement()
  ,optional(object.optional.length, optionalField)
  ,startTime()
  ,startPosition()
  ,startOdometer()
  ,startFuelLevel()
  ,startElectricConsumption()
  ,startElectricRegeneration()
  ,endTime()
  ,endPosition()
  ,endOdometer()
  ,endFuelLevel()
  ,endElectricConsumption()
  ,endElectricRegeneration()
{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : asnctripFragmentss
 * Copy method
 */
void asnctripFragmentss::__copy (const asntype& obj)
{
  const asnctripFragmentss* object = asnSCast(const asnctripFragmentss*,&obj);
  optionalField[0] = object->optionalField[0];
  optionalField[1] = object->optionalField[1];
 {
    if(object->startTime != (TimeStamp *)asnBNULL)
    {
      startTime = (TimeStamp*)object->startTime->__create();
      startTime->__copy(*object->startTime);
    }
    else
    {
      startTime = (TimeStamp *) 0;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_startPosition) != asnFALSE)
    {
      if(object->startPosition != (Position *)asnBNULL)
      {
        startPosition = (Position*)object->startPosition->__create();
        startPosition->__copy(*object->startPosition);
      }
      else
      {
        startPosition = (Position *) 0;
      }
    }
    else
    {
      this->startPosition = (Position*) asnBNULL;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_TripFragment__startOdometer) != asnFALSE)
    {
      startOdometer = object->startOdometer;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_startFuelLevel) != asnFALSE)
    {
      startFuelLevel = object->startFuelLevel;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_startElectricConsumption) != asnFALSE)
    {
      startElectricConsumption = object->startElectricConsumption;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_startElectricRegeneration) != asnFALSE)
    {
      startElectricRegeneration = object->startElectricRegeneration;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_TripFragment__endTime) != asnFALSE)
    {
      if(object->endTime != (TimeStamp *)asnBNULL)
      {
        endTime = (TimeStamp*)object->endTime->__create();
        endTime->__copy(*object->endTime);
      }
      else
      {
        endTime = (TimeStamp *) 0;
      }
    }
    else
    {
      this->endTime = (TimeStamp*) asnBNULL;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_endPosition) != asnFALSE)
    {
      if(object->endPosition != (Position *)asnBNULL)
      {
        endPosition = (Position*)object->endPosition->__create();
        endPosition->__copy(*object->endPosition);
      }
      else
      {
        endPosition = (Position *) 0;
      }
    }
    else
    {
      this->endPosition = (Position*) asnBNULL;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_TripFragment__endOdometer) != asnFALSE)
    {
      endOdometer = object->endOdometer;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_endFuelLevel) != asnFALSE)
    {
      endFuelLevel = object->endFuelLevel;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_endElectricConsumption) != asnFALSE)
    {
      endElectricConsumption = object->endElectricConsumption;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_endElectricRegeneration) != asnFALSE)
    {
      endElectricRegeneration = object->endElectricRegeneration;
    }
 }
}

/**
 *    TypeAssignment : asnctrackPointss
 *    Class constructor
 */
asnctrackPointss::asnctrackPointss(const asnctrackPointss& object)
  : asnListElement()
  ,optional(object.optional.length, optionalField)
  ,systemTime()
  ,position()
  ,speed()
  ,direction()
  ,isSVT()
  ,odometer()
  ,travelDistanceSinceLastWaypoint()
  ,fuelConsumptionSinceLastWaypoint()
  ,electricConsumptionSinceLastSample()
  ,electricRegenerationSinceLastSample()
{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : asnctrackPointss
 * Copy method
 */
void asnctrackPointss::__copy (const asntype& obj)
{
  const asnctrackPointss* object = asnSCast(const asnctrackPointss*,&obj);
  optionalField[0] = object->optionalField[0];
 {
    if(object->systemTime != (TimeStamp *)asnBNULL)
    {
      systemTime = (TimeStamp*)object->systemTime->__create();
      systemTime->__copy(*object->systemTime);
    }
    else
    {
      systemTime = (TimeStamp *) 0;
    }
 }
 {
    if(object->position != (Position *)asnBNULL)
    {
      position = (Position*)object->position->__create();
      position->__copy(*object->position);
    }
    else
    {
      position = (Position *) 0;
    }
 }
 {
    speed = object->speed;
 }
 {
    if(asnGetPresence(object->optionalField,asn_TrackPoint__direction) != asnFALSE)
    {
      direction = object->direction;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_isSVT) != asnFALSE)
    {
      isSVT = object->isSVT;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_TrackPoint__odometer) != asnFALSE)
    {
      odometer = object->odometer;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_travelDistanceSinceLastWaypoint) != asnFALSE)
    {
      travelDistanceSinceLastWaypoint = object->travelDistanceSinceLastWaypoint;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_fuelConsumptionSinceLastWaypoint) != asnFALSE)
    {
      fuelConsumptionSinceLastWaypoint = object->fuelConsumptionSinceLastWaypoint;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_electricConsumptionSinceLastSample) != asnFALSE)
    {
      electricConsumptionSinceLastSample = object->electricConsumptionSinceLastSample;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_electricRegenerationSinceLastSample) != asnFALSE)
    {
      electricRegenerationSinceLastSample = object->electricRegenerationSinceLastSample;
    }
 }
}

/**
 *    TypeAssignment : asncdidDatas
 *    Class constructor
 */
asncdidDatas::asncdidDatas(const asncdidDatas& object)
  : asnListElement()
  ,id()
  ,data()
{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : asncdidDatas
 * Copy method
 */
void asncdidDatas::__copy (const asntype& obj)
{
  const asncdidDatas* object = asnSCast(const asncdidDatas*,&obj);
 {
    id = object->id;
 }
 {
    this->data.__copy(object->data);
 }
}

/**
 *    TypeAssignment : asncdtcDatas
 *    Class constructor
 */
asncdtcDatas::asncdtcDatas(const asncdtcDatas& object)
  : asnListElement()
  ,id()
  ,data()
{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : asncdtcDatas
 * Copy method
 */
void asncdtcDatas::__copy (const asntype& obj)
{
  const asncdtcDatas* object = asnSCast(const asncdtcDatas*,&obj);
 {
    id = object->id;
 }
 {
    this->data.__copy(object->data);
 }
}

/**
 *    TypeAssignment : asncdatas
 *    Class constructor
 */
asncdatas::asncdatas(const asncdatas& object)
  : asnListElement()
  ,ecu()
  ,diagnosticNumber()
  ,didData()
  ,dtcData()
{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : asncdatas
 * Copy method
 */
void asncdatas::__copy (const asntype& obj)
{
  const asncdatas* object = asnSCast(const asncdatas*,&obj);
 {
    ecu = object->ecu;
 }
 {
    this->diagnosticNumber.__copy (object->diagnosticNumber);
 }
 {
    asncdidDatas *elt_asncdidDatas;
    elt_asncdidDatas = (asncdidDatas*) object->didData.firstElement;
    for (asnMAXUINT countdidData=0; countdidData<object->didData.count; countdidData++)
    {
      didData.addElement(new asncdidDatas(*elt_asncdidDatas));
      elt_asncdidDatas = (asncdidDatas*) elt_asncdidDatas->nextElement;
    }
 }
 {
    asncdtcDatas *elt_asncdtcDatas;
    elt_asncdtcDatas = (asncdtcDatas*) object->dtcData.firstElement;
    for (asnMAXUINT countdtcData=0; countdtcData<object->dtcData.count; countdtcData++)
    {
      dtcData.addElement(new asncdtcDatas(*elt_asncdtcDatas));
      elt_asncdtcDatas = (asncdtcDatas*) elt_asncdtcDatas->nextElement;
    }
 }
}

/**
 *    TypeAssignment : asncconditionss
 *    Class constructor
 */
asncconditionss::asncconditionss(const asncconditionss& object)
  : asnListElement()
  ,condition()
{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : asncconditionss
 * Copy method
 */
void asncconditionss::__copy (const asntype& obj)
{
  const asncconditionss* object = asnSCast(const asncconditionss*,&obj);
 {
    this->condition.__copy (object->condition);
 }
}

/**
 *    TypeAssignment : RequestHeader
 *    Class constructor
 */
RequestHeader::RequestHeader(const RequestHeader& object)
  : asntype()  ,optional(object.optional.length, optionalField)
  ,requestid()
  ,timeStamp()
  ,eventId()
  ,creatorId()
  ,messageTTL()
  ,requestType()
  ,ackRequired()

{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : RequestHeader
 * Copy method
 */
void RequestHeader::__copy (const asntype& obj)
{
  const RequestHeader* object = asnSCast(const RequestHeader*,&obj);
  optionalField[0] = object->optionalField[0];
 {
    requestid = object->requestid;
 }
 {
    if(object->timeStamp != (TimeStamp *)asnBNULL)
    {
      timeStamp = (TimeStamp*)object->timeStamp->__create();
      timeStamp->__copy(*object->timeStamp);
    }
    else
    {
      timeStamp = (TimeStamp *) 0;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_eventId) != asnFALSE)
    {
      if(object->eventId != (TimeStamp *)asnBNULL)
      {
        eventId = (TimeStamp*)object->eventId->__create();
        eventId->__copy(*object->eventId);
      }
      else
      {
        eventId = (TimeStamp *) 0;
      }
    }
    else
    {
      this->eventId = (TimeStamp*) asnBNULL;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_creatorId) != asnFALSE)
    {
      creatorId = object->creatorId;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_messageTTL) != asnFALSE)
    {
      messageTTL = object->messageTTL;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_requestType) != asnFALSE)
    {
      requestType = object->requestType;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_ackRequired) != asnFALSE)
    {
      ackRequired = object->ackRequired;
    }
 }
}

/**
 *    TypeAssignment : TimeStamp
 *    Class constructor
 */
TimeStamp::TimeStamp(const TimeStamp& object)
  : asntype()  ,optional(object.optional.length, optionalField)
  ,seconds()
  ,milliseconds()

{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : TimeStamp
 * Copy method
 */
void TimeStamp::__copy (const asntype& obj)
{
  const TimeStamp* object = asnSCast(const TimeStamp*,&obj);
  optionalField[0] = object->optionalField[0];
 {
    seconds = object->seconds;
 }
 {
    if(asnGetPresence(object->optionalField,asn_milliseconds) != asnFALSE)
    {
      milliseconds = object->milliseconds;
    }
 }
}

/**
 *    TypeAssignment : VDServiceRequest
 *    Class constructor
 */
VDServiceRequest::VDServiceRequest(const VDServiceRequest& object)
  : asntype()  ,optional(object.optional.length, optionalField)
  ,header()
  ,body()

{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : VDServiceRequest
 * Copy method
 */
void VDServiceRequest::__copy (const asntype& obj)
{
  const VDServiceRequest* object = asnSCast(const VDServiceRequest*,&obj);
  optionalField[0] = object->optionalField[0];
 {
    if(object->header != (RequestHeader *)asnBNULL)
    {
      header = (RequestHeader*)object->header->__create();
      header->__copy(*object->header);
    }
    else
    {
      header = (RequestHeader *) 0;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_body) != asnFALSE)
    {
      if(object->body != (RequestBody *)asnBNULL)
      {
        body = (RequestBody*)object->body->__create();
        body->__copy(*object->body);
      }
      else
      {
        body = (RequestBody *) 0;
      }
    }
    else
    {
      this->body = (RequestBody*) asnBNULL;
    }
 }
}

/**
 *    TypeAssignment : DIDData
 *    Class constructor
 */
DIDData::DIDData(const DIDData& object)
  : asntype()  ,id()
  ,data()

{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : DIDData
 * Copy method
 */
void DIDData::__copy (const asntype& obj)
{
  const DIDData* object = asnSCast(const DIDData*,&obj);
 {
    id = object->id;
 }
 {
    this->data.__copy(object->data);
 }
}

/**
 *    TypeAssignment : DTCData
 *    Class constructor
 */
DTCData::DTCData(const DTCData& object)
  : asntype()  ,id()
  ,data()

{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : DTCData
 * Copy method
 */
void DTCData::__copy (const asntype& obj)
{
  const DTCData* object = asnSCast(const DTCData*,&obj);
 {
    id = object->id;
 }
 {
    this->data.__copy(object->data);
 }
}

/**
 *    TypeAssignment : ECUData
 *    Class constructor
 */
ECUData::ECUData(const ECUData& object)
  : asntype()  ,ecu()
  ,diagnosticNumber()
  ,didData()
  ,dtcData()

{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : ECUData
 * Copy method
 */
void ECUData::__copy (const asntype& obj)
{
  const ECUData* object = asnSCast(const ECUData*,&obj);
 {
    ecu = object->ecu;
 }
 {
    this->diagnosticNumber.__copy (object->diagnosticNumber);
 }
 {
    asncdidDatas *elt_asncdidDatas;
    elt_asncdidDatas = (asncdidDatas*) object->didData.firstElement;
    for (asnMAXUINT countdidData=0; countdidData<object->didData.count; countdidData++)
    {
      didData.addElement(new asncdidDatas(*elt_asncdidDatas));
      elt_asncdidDatas = (asncdidDatas*) elt_asncdidDatas->nextElement;
    }
 }
 {
    asncdtcDatas *elt_asncdtcDatas;
    elt_asncdtcDatas = (asncdtcDatas*) object->dtcData.firstElement;
    for (asnMAXUINT countdtcData=0; countdtcData<object->dtcData.count; countdtcData++)
    {
      dtcData.addElement(new asncdtcDatas(*elt_asncdtcDatas));
      elt_asncdtcDatas = (asncdtcDatas*) elt_asncdtcDatas->nextElement;
    }
 }
}

/**
 *    TypeAssignment : EcuData__C
 *    Class constructor
 */
asncnoDiagData::asncnoDiagData(const asncnoDiagData& object)
  :EcuData__C(object.alternative),noDiagData()
{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : EcuData__C
 * Copy method
 */
void asncnoDiagData::__copy (const asntype& obj)
{
  const asncnoDiagData* object = asnSCast(const asncnoDiagData*,&obj);
  asnDUMMY(object);
}
/**
 *    TypeAssignment : EcuData__C
 *    Class constructor
 */
asncEcuData__data::asncEcuData__data(const asncEcuData__data& object)
  :EcuData__C(object.alternative),data()
{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : EcuData__C
 * Copy method
 */
void asncEcuData__data::__copy (const asntype& obj)
{
  const asncEcuData__data* object = asnSCast(const asncEcuData__data*,&obj);
  asncdatas *elt_asncdatas;
  elt_asncdatas = (asncdatas*) object->data.firstElement;
  for (asnMAXUINT countdata=0; countdata<object->data.count; countdata++)
  {
    data.addElement(new asncdatas(*elt_asncdatas));
    elt_asncdatas = (asncdatas*) elt_asncdatas->nextElement;
  }
}
/**
 *    TypeAssignment : EcuData
 *    Class constructor
 */
EcuData::EcuData(const EcuData& object)
  : asntype(),value(){
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : EcuData
 * Copy method
 */
void EcuData::__copy (const asntype& obj)
{
  const EcuData* object = asnSCast(const EcuData*,&obj);
  if(object->value != (EcuData__C *)asnBNULL)
  {
    switch(object->value->alternative)
    {
      case asn_noDiagData:
        this->value = new asncnoDiagData(*(asncnoDiagData*) object->value);
        break;
      case asn_EcuData__data:
        this->value = new asncEcuData__data(*(asncEcuData__data*) object->value);
        break;
      default: this->value = (EcuData__C *) 0;
    }
  }
  else
  {
    this->value = (EcuData__C *) 0;
  }
}

/**
 *    TypeAssignment : NEVCoordinatesLongLat
 *    Class constructor
 */
NEVCoordinatesLongLat::NEVCoordinatesLongLat(const NEVCoordinatesLongLat& object)
  : asntype()  ,longitude()
  ,latitude()

{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : NEVCoordinatesLongLat
 * Copy method
 */
void NEVCoordinatesLongLat::__copy (const asntype& obj)
{
  const NEVCoordinatesLongLat* object = asnSCast(const NEVCoordinatesLongLat*,&obj);
 {
    longitude = object->longitude;
 }
 {
    latitude = object->latitude;
 }
}

/**
 *    TypeAssignment : NEVDRPositionData
 *    Class constructor
 */
NEVDRPositionData::NEVDRPositionData(const NEVDRPositionData& object)
  : asntype()  ,longLat()
  ,heading()
  ,speedKmph()
  ,hdopX10()
  ,numSat()
  ,fixTime()
  ,fixType()
  ,drType()
  ,drDistance()

{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : NEVDRPositionData
 * Copy method
 */
void NEVDRPositionData::__copy (const asntype& obj)
{
  const NEVDRPositionData* object = asnSCast(const NEVDRPositionData*,&obj);
 {
    if(object->longLat != (NEVCoordinatesLongLat *)asnBNULL)
    {
      longLat = (NEVCoordinatesLongLat*)object->longLat->__create();
      longLat->__copy(*object->longLat);
    }
    else
    {
      longLat = (NEVCoordinatesLongLat *) 0;
    }
 }
 {
    heading = object->heading;
 }
 {
    speedKmph = object->speedKmph;
 }
 {
    hdopX10 = object->hdopX10;
 }
 {
    numSat = object->numSat;
 }
 {
    if(object->fixTime != (NEVDateTime *)asnBNULL)
    {
      fixTime = (NEVDateTime*)object->fixTime->__create();
      fixTime->__copy(*object->fixTime);
    }
    else
    {
      fixTime = (NEVDateTime *) 0;
    }
 }
 {
    fixType = object->fixType;
 }
 {
    drType = object->drType;
 }
 {
    drDistance = object->drDistance;
 }
}

/**
 *    TypeAssignment : NEVDRVehiclePosition__C
 *    Class constructor
 */
asncnoValidData::asncnoValidData(const asncnoValidData& object)
  :NEVDRVehiclePosition__C(object.alternative),noValidData()
{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : NEVDRVehiclePosition__C
 * Copy method
 */
void asncnoValidData::__copy (const asntype& obj)
{
  const asncnoValidData* object = asnSCast(const asncnoValidData*,&obj);
  asnDUMMY(object);
}
/**
 *    TypeAssignment : NEVDRVehiclePosition__C
 *    Class constructor
 */
asncdrPosition::asncdrPosition(const asncdrPosition& object)
  :NEVDRVehiclePosition__C(object.alternative)  ,longLat()
  ,heading()
  ,speedKmph()
  ,hdopX10()
  ,numSat()
  ,fixTime()
  ,fixType()
  ,drType()
  ,drDistance()

{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : NEVDRVehiclePosition__C
 * Copy method
 */
void asncdrPosition::__copy (const asntype& obj)
{
  const asncdrPosition* object = asnSCast(const asncdrPosition*,&obj);
 {
    if(object->longLat != (NEVCoordinatesLongLat *)asnBNULL)
    {
      longLat = (NEVCoordinatesLongLat*)object->longLat->__create();
      longLat->__copy(*object->longLat);
    }
    else
    {
      longLat = (NEVCoordinatesLongLat *) 0;
    }
 }
 {
    heading = object->heading;
 }
 {
    speedKmph = object->speedKmph;
 }
 {
    hdopX10 = object->hdopX10;
 }
 {
    numSat = object->numSat;
 }
 {
    if(object->fixTime != (NEVDateTime *)asnBNULL)
    {
      fixTime = (NEVDateTime*)object->fixTime->__create();
      fixTime->__copy(*object->fixTime);
    }
    else
    {
      fixTime = (NEVDateTime *) 0;
    }
 }
 {
    fixType = object->fixType;
 }
 {
    drType = object->drType;
 }
 {
    drDistance = object->drDistance;
 }
}
/**
 *    TypeAssignment : NEVDRVehiclePosition
 *    Class constructor
 */
NEVDRVehiclePosition::NEVDRVehiclePosition(const NEVDRVehiclePosition& object)
  : asntype(),value(){
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : NEVDRVehiclePosition
 * Copy method
 */
void NEVDRVehiclePosition::__copy (const asntype& obj)
{
  const NEVDRVehiclePosition* object = asnSCast(const NEVDRVehiclePosition*,&obj);
  if(object->value != (NEVDRVehiclePosition__C *)asnBNULL)
  {
    switch(object->value->alternative)
    {
      case asn_noValidData:
        this->value = new asncnoValidData(*(asncnoValidData*) object->value);
        break;
      case asn_drPosition:
        this->value = new asncdrPosition(*(asncdrPosition*) object->value);
        break;
      default: this->value = (NEVDRVehiclePosition__C *) 0;
    }
  }
  else
  {
    this->value = (NEVDRVehiclePosition__C *) 0;
  }
}

/**
 *    TypeAssignment : NEVDateTime
 *    Class constructor
 */
NEVDateTime::NEVDateTime(const NEVDateTime& object)
  : asntype()  ,year()
  ,month()
  ,day()
  ,hour()
  ,minute()
  ,second()

{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : NEVDateTime
 * Copy method
 */
void NEVDateTime::__copy (const asntype& obj)
{
  const NEVDateTime* object = asnSCast(const NEVDateTime*,&obj);
 {
    year = object->year;
 }
 {
    month = object->month;
 }
 {
    day = object->day;
 }
 {
    hour = object->hour;
 }
 {
    minute = object->minute;
 }
 {
    second = object->second;
 }
}

/**
 *    TypeAssignment : NEVServiceData
 *    Class constructor
 */
NEVServiceData::NEVServiceData(const NEVServiceData& object)
  : asntype()  ,vehicleVin()
  ,testVehicle()
  ,rvdcTriggerCondition()
  ,mdpID()
  ,maID()
  ,position()
  ,ecuData()

{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : NEVServiceData
 * Copy method
 */
void NEVServiceData::__copy (const asntype& obj)
{
  const NEVServiceData* object = asnSCast(const NEVServiceData*,&obj);
 {
    this->vehicleVin.__copy (object->vehicleVin);
 }
 {
    testVehicle = object->testVehicle;
 }
 {
    rvdcTriggerCondition = object->rvdcTriggerCondition;
 }
 {
    mdpID = object->mdpID;
 }
 {
    this->maID.__copy (object->maID);
 }
 {
    if(object->position != (NEVDRVehiclePosition__C *)asnBNULL)
    {
      switch(object->position->alternative)
      {
        case asn_noValidData:
          this->position = new asncnoValidData(*(asncnoValidData*) object->position);
          break;
        case asn_drPosition:
          this->position = new asncdrPosition(*(asncdrPosition*) object->position);
          break;
        default: this->position = (NEVDRVehiclePosition__C *) 0;
      }
    }
    else
    {
      this->position = (NEVDRVehiclePosition__C *) 0;
    }
 }
 {
    if(object->ecuData != (EcuData__C *)asnBNULL)
    {
      switch(object->ecuData->alternative)
      {
        case asn_noDiagData:
          this->ecuData = new asncnoDiagData(*(asncnoDiagData*) object->ecuData);
          break;
        case asn_EcuData__data:
          this->ecuData = new asncEcuData__data(*(asncEcuData__data*) object->ecuData);
          break;
        default: this->ecuData = (EcuData__C *) 0;
      }
    }
    else
    {
      this->ecuData = (EcuData__C *) 0;
    }
 }
}

/**
 *    TypeAssignment : Configuration
 *    Class constructor
 */
Configuration::Configuration(const Configuration& object)
  : asntype()  ,version()
  ,items()

{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : Configuration
 * Copy method
 */
void Configuration::__copy (const asntype& obj)
{
  const Configuration* object = asnSCast(const Configuration*,&obj);
 {
    this->version.__copy (object->version);
 }
 {
    asncitemss *elt_asncitemss;
    elt_asncitemss = (asncitemss*) object->items.firstElement;
    for (asnMAXUINT countitems=0; countitems<object->items.count; countitems++)
    {
      items.addElement(new asncitemss(*elt_asncitemss));
      elt_asncitemss = (asncitemss*) elt_asncitemss->nextElement;
    }
 }
}

/**
 *    TypeAssignment : ConfigurationItem
 *    Class constructor
 */
ConfigurationItem::ConfigurationItem(const ConfigurationItem& object)
  : asntype()  ,name()
  ,parameters()

{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : ConfigurationItem
 * Copy method
 */
void ConfigurationItem::__copy (const asntype& obj)
{
  const ConfigurationItem* object = asnSCast(const ConfigurationItem*,&obj);
 {
    this->name.__copy (object->name);
 }
 {
    asncConfigurationItem__parameterss *elt_asncConfigurationItem__parameterss;
    elt_asncConfigurationItem__parameterss = (asncConfigurationItem__parameterss*) object->parameters.firstElement;
    for (asnMAXUINT countparameters=0; countparameters<object->parameters.count; countparameters++)
    {
      parameters.addElement(new asncConfigurationItem__parameterss(*elt_asncConfigurationItem__parameterss));
      elt_asncConfigurationItem__parameterss = (asncConfigurationItem__parameterss*) elt_asncConfigurationItem__parameterss->nextElement;
    }
 }
}

/**
 *    TypeAssignment : ContactInfo
 *    Class constructor
 */
ContactInfo::ContactInfo(const ContactInfo& object)
  : asntype()  ,optional(object.optional.length, optionalField)
  ,email()
  ,address()
  ,phone1()
  ,phone2()

{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : ContactInfo
 * Copy method
 */
void ContactInfo::__copy (const asntype& obj)
{
  const ContactInfo* object = asnSCast(const ContactInfo*,&obj);
  optionalField[0] = object->optionalField[0];
 {
    if(asnGetPresence(object->optionalField,asn_email) != asnFALSE)
    {
      this->email.__copy (object->email);
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_address) != asnFALSE)
    {
      if(object->address != (PostAddress *)asnBNULL)
      {
        address = (PostAddress*)object->address->__create();
        address->__copy(*object->address);
      }
      else
      {
        address = (PostAddress *) 0;
      }
    }
    else
    {
      this->address = (PostAddress*) asnBNULL;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_phone1) != asnFALSE)
    {
      this->phone1.__copy (object->phone1);
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_phone2) != asnFALSE)
    {
      this->phone2.__copy (object->phone2);
    }
 }
}

/**
 *    TypeAssignment : Error
 *    Class constructor
 */
Error::Error(const Error& object)
  : asntype()  ,optional(object.optional.length, optionalField)
  ,code()
  ,vehicleErrorCode()
  ,message()

{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : Error
 * Copy method
 */
void Error::__copy (const asntype& obj)
{
  const Error* object = asnSCast(const Error*,&obj);
  optionalField[0] = object->optionalField[0];
 {
    code = object->code;
 }
 {
    if(asnGetPresence(object->optionalField,asn_vehicleErrorCode) != asnFALSE)
    {
      vehicleErrorCode = object->vehicleErrorCode;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_Error__message) != asnFALSE)
    {
      this->message.__copy (object->message);
    }
 }
}

/**
 *    TypeAssignment : EventAction
 *    Class constructor
 */
EventAction::EventAction(const EventAction& object)
  : asntype()  ,optional(object.optional.length, optionalField)
  ,triggerTimes()
  ,notifyInterval()

{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : EventAction
 * Copy method
 */
void EventAction::__copy (const asntype& obj)
{
  const EventAction* object = asnSCast(const EventAction*,&obj);
  optionalField[0] = object->optionalField[0];
 {
    if(asnGetPresence(object->optionalField,asn_triggerTimes) != asnFALSE)
    {
      triggerTimes = object->triggerTimes;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_notifyInterval) != asnFALSE)
    {
      notifyInterval = object->notifyInterval;
    }
 }
}

/**
 *    TypeAssignment : EventRule
 *    Class constructor
 */
EventRule::EventRule(const EventRule& object)
  : asntype()  ,optional(object.optional.length, optionalField)
  ,ruleId()
  ,startTime()
  ,endTime()
  ,conditions()
  ,interval()
  ,action()

{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : EventRule
 * Copy method
 */
void EventRule::__copy (const asntype& obj)
{
  const EventRule* object = asnSCast(const EventRule*,&obj);
  optionalField[0] = object->optionalField[0];
 {
    ruleId = object->ruleId;
 }
 {
    if(asnGetPresence(object->optionalField,asn_startTime) != asnFALSE)
    {
      if(object->startTime != (TimeStamp *)asnBNULL)
      {
        startTime = (TimeStamp*)object->startTime->__create();
        startTime->__copy(*object->startTime);
      }
      else
      {
        startTime = (TimeStamp *) 0;
      }
    }
    else
    {
      this->startTime = (TimeStamp*) asnBNULL;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_EventRule__endTime) != asnFALSE)
    {
      if(object->endTime != (TimeStamp *)asnBNULL)
      {
        endTime = (TimeStamp*)object->endTime->__create();
        endTime->__copy(*object->endTime);
      }
      else
      {
        endTime = (TimeStamp *) 0;
      }
    }
    else
    {
      this->endTime = (TimeStamp*) asnBNULL;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_conditions) != asnFALSE)
    {
      asncconditionss *elt_asncconditionss;
      elt_asncconditionss = (asncconditionss*) object->conditions.firstElement;
      for (asnMAXUINT countconditions=0; countconditions<object->conditions.count; countconditions++)
      {
        conditions.addElement(new asncconditionss(*elt_asncconditionss));
        elt_asncconditionss = (asncconditionss*) elt_asncconditionss->nextElement;
      }
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_EventRule__interval) != asnFALSE)
    {
      interval = object->interval;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_action) != asnFALSE)
    {
      if(object->action != (EventAction *)asnBNULL)
      {
        action = (EventAction*)object->action->__create();
        action->__copy(*object->action);
      }
      else
      {
        action = (EventAction *) 0;
      }
    }
    else
    {
      this->action = (EventAction*) asnBNULL;
    }
 }
}

/**
 *    TypeAssignment : GeneralMessage__C
 *    Class constructor
 */
asncGeneralMessage__message::asncGeneralMessage__message(const asncGeneralMessage__message& object)
  :GeneralMessage__C(object.alternative),message()
{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : GeneralMessage__C
 * Copy method
 */
void asncGeneralMessage__message::__copy (const asntype& obj)
{
  const asncGeneralMessage__message* object = asnSCast(const asncGeneralMessage__message*,&obj);
  this->message.__copy(object->message);
}
/**
 *    TypeAssignment : GeneralMessage__C
 *    Class constructor
 */
asncocetMessage::asncocetMessage(const asncocetMessage& object)
  :GeneralMessage__C(object.alternative),ocetMessage()
{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : GeneralMessage__C
 * Copy method
 */
void asncocetMessage::__copy (const asntype& obj)
{
  const asncocetMessage* object = asnSCast(const asncocetMessage*,&obj);
  this->ocetMessage.__copy(object->ocetMessage);
}
/**
 *    TypeAssignment : GeneralMessage
 *    Class constructor
 */
GeneralMessage::GeneralMessage(const GeneralMessage& object)
  : asntype(),value(){
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : GeneralMessage
 * Copy method
 */
void GeneralMessage::__copy (const asntype& obj)
{
  const GeneralMessage* object = asnSCast(const GeneralMessage*,&obj);
  if(object->value != (GeneralMessage__C *)asnBNULL)
  {
    switch(object->value->alternative)
    {
      case asn_GeneralMessage__message:
        this->value = new asncGeneralMessage__message(*(asncGeneralMessage__message*) object->value);
        break;
      case asn_ocetMessage:
        this->value = new asncocetMessage(*(asncocetMessage*) object->value);
        break;
      default: this->value = (GeneralMessage__C *) 0;
    }
  }
  else
  {
    this->value = (GeneralMessage__C *) 0;
  }
}

/**
 *    TypeAssignment : Notification
 *    Class constructor
 */
Notification::Notification(const Notification& object)
  : asntype()  ,optional(object.optional.length, optionalField)
  ,reason()
  ,time()
  ,parameters()

{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : Notification
 * Copy method
 */
void Notification::__copy (const asntype& obj)
{
  const Notification* object = asnSCast(const Notification*,&obj);
  optionalField[0] = object->optionalField[0];
 {
    reason = object->reason;
 }
 {
    if(object->time != (TimeStamp *)asnBNULL)
    {
      time = (TimeStamp*)object->time->__create();
      time->__copy(*object->time);
    }
    else
    {
      time = (TimeStamp *) 0;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_parameters) != asnFALSE)
    {
      asncNotification__parameterss *elt_asncNotification__parameterss;
      elt_asncNotification__parameterss = (asncNotification__parameterss*) object->parameters.firstElement;
      for (asnMAXUINT countparameters=0; countparameters<object->parameters.count; countparameters++)
      {
        parameters.addElement(new asncNotification__parameterss(*elt_asncNotification__parameterss));
        elt_asncNotification__parameterss = (asncNotification__parameterss*) elt_asncNotification__parameterss->nextElement;
      }
    }
 }
}

/**
 *    TypeAssignment : OTA
 *    Class constructor
 */
OTA::OTA(const OTA& object)
  : asntype()  ,optional(object.optional.length, optionalField)
  ,swModel()
  ,swVersion()
  ,downloadUrl()
  ,verificationCode()

{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : OTA
 * Copy method
 */
void OTA::__copy (const asntype& obj)
{
  const OTA* object = asnSCast(const OTA*,&obj);
  optionalField[0] = object->optionalField[0];
 {
    if(asnGetPresence(object->optionalField,asn_swModel) != asnFALSE)
    {
      this->swModel.__copy (object->swModel);
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_OTA__swVersion) != asnFALSE)
    {
      this->swVersion.__copy (object->swVersion);
    }
 }
 {
    this->downloadUrl.__copy (object->downloadUrl);
 }
 {
    if(asnGetPresence(object->optionalField,asn_verificationCode) != asnFALSE)
    {
      this->verificationCode.__copy (object->verificationCode);
    }
 }
}

/**
 *    TypeAssignment : PointOfInterest
 *    Class constructor
 */
PointOfInterest::PointOfInterest(const PointOfInterest& object)
  : asntype()  ,optional(object.optional.length, optionalField)
  ,name()
  ,position()
  ,type()
  ,contactInfo()
  ,url()
  ,attributes()

{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : PointOfInterest
 * Copy method
 */
void PointOfInterest::__copy (const asntype& obj)
{
  const PointOfInterest* object = asnSCast(const PointOfInterest*,&obj);
  optionalField[0] = object->optionalField[0];
 {
    this->name.__copy (object->name);
 }
 {
    if(asnGetPresence(object->optionalField,asn_position) != asnFALSE)
    {
      if(object->position != (Position *)asnBNULL)
      {
        position = (Position*)object->position->__create();
        position->__copy(*object->position);
      }
      else
      {
        position = (Position *) 0;
      }
    }
    else
    {
      this->position = (Position*) asnBNULL;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_type) != asnFALSE)
    {
      this->type.__copy (object->type);
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_contactInfo) != asnFALSE)
    {
      if(object->contactInfo != (ContactInfo *)asnBNULL)
      {
        contactInfo = (ContactInfo*)object->contactInfo->__create();
        contactInfo->__copy(*object->contactInfo);
      }
      else
      {
        contactInfo = (ContactInfo *) 0;
      }
    }
    else
    {
      this->contactInfo = (ContactInfo*) asnBNULL;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_url) != asnFALSE)
    {
      this->url.__copy (object->url);
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_attributes) != asnFALSE)
    {
      asncattributess *elt_asncattributess;
      elt_asncattributess = (asncattributess*) object->attributes.firstElement;
      for (asnMAXUINT countattributes=0; countattributes<object->attributes.count; countattributes++)
      {
        attributes.addElement(new asncattributess(*elt_asncattributess));
        elt_asncattributess = (asncattributess*) elt_asncattributess->nextElement;
      }
    }
 }
}

/**
 *    TypeAssignment : Position
 *    Class constructor
 */
Position::Position(const Position& object)
  : asntype()  ,optional(object.optional.length, optionalField)
  ,latitude()
  ,longitude()
  ,altitude()
  ,posCanBeTrusted()
  ,carLocatorStatUploadEn()
  ,marsCoordinates()

{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : Position
 * Copy method
 */
void Position::__copy (const asntype& obj)
{
  const Position* object = asnSCast(const Position*,&obj);
  optionalField[0] = object->optionalField[0];
 {
    if(asnGetPresence(object->optionalField,asn_latitude) != asnFALSE)
    {
      latitude = object->latitude;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_longitude) != asnFALSE)
    {
      longitude = object->longitude;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_altitude) != asnFALSE)
    {
      altitude = object->altitude;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_posCanBeTrusted) != asnFALSE)
    {
      posCanBeTrusted = object->posCanBeTrusted;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_carLocatorStatUploadEn) != asnFALSE)
    {
      carLocatorStatUploadEn = object->carLocatorStatUploadEn;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_marsCoordinates) != asnFALSE)
    {
      marsCoordinates = object->marsCoordinates;
    }
 }
}

/**
 *    TypeAssignment : PostAddress
 *    Class constructor
 */
PostAddress::PostAddress(const PostAddress& object)
  : asntype()  ,optional(object.optional.length, optionalField)
  ,street()
  ,houseNumber()
  ,city()
  ,region()
  ,postcode()
  ,country()

{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : PostAddress
 * Copy method
 */
void PostAddress::__copy (const asntype& obj)
{
  const PostAddress* object = asnSCast(const PostAddress*,&obj);
  optionalField[0] = object->optionalField[0];
 {
    if(asnGetPresence(object->optionalField,asn_street) != asnFALSE)
    {
      this->street.__copy (object->street);
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_houseNumber) != asnFALSE)
    {
      this->houseNumber.__copy (object->houseNumber);
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_city) != asnFALSE)
    {
      this->city.__copy (object->city);
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_region) != asnFALSE)
    {
      this->region.__copy (object->region);
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_postcode) != asnFALSE)
    {
      this->postcode.__copy (object->postcode);
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_country) != asnFALSE)
    {
      this->country.__copy (object->country);
    }
 }
}

/**
 *    TypeAssignment : RuleCondition
 *    Class constructor
 */
RuleCondition::RuleCondition(const RuleCondition& object)
  : asntype()  ,condition()

{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : RuleCondition
 * Copy method
 */
void RuleCondition::__copy (const asntype& obj)
{
  const RuleCondition* object = asnSCast(const RuleCondition*,&obj);
 {
    this->condition.__copy (object->condition);
 }
}

/**
 *    TypeAssignment : ServiceData
 *    Class constructor
 */
ServiceData::ServiceData(const ServiceData& object)
  : asntype()  ,optional(object.optional.length, optionalField)
  ,serviceTrigger()
  ,serviceParameters()
  ,serviceCommand()
  ,serviceResult()
  ,serviceStatus()
  ,message()
  ,pois()
  ,configuration()
  ,vehicleStatus()
  ,ota()
  ,trip()
  ,tripFragments()
  ,trackPoints()
  ,nevServiceData()
  ,eventRule()

{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : ServiceData
 * Copy method
 */
void ServiceData::__copy (const asntype& obj)
{
  const ServiceData* object = asnSCast(const ServiceData*,&obj);
  optionalField[0] = object->optionalField[0];
  optionalField[1] = object->optionalField[1];
 {
    if(asnGetPresence(object->optionalField,asn_serviceTrigger) != asnFALSE)
    {
      if(object->serviceTrigger != (ServiceTrigger *)asnBNULL)
      {
        serviceTrigger = (ServiceTrigger*)object->serviceTrigger->__create();
        serviceTrigger->__copy(*object->serviceTrigger);
      }
      else
      {
        serviceTrigger = (ServiceTrigger *) 0;
      }
    }
    else
    {
      this->serviceTrigger = (ServiceTrigger*) asnBNULL;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_serviceParameters) != asnFALSE)
    {
      asncserviceParameterss *elt_asncserviceParameterss;
      elt_asncserviceParameterss = (asncserviceParameterss*) object->serviceParameters.firstElement;
      for (asnMAXUINT countserviceParameters=0; countserviceParameters<object->serviceParameters.count; countserviceParameters++)
      {
        serviceParameters.addElement(new asncserviceParameterss(*elt_asncserviceParameterss));
        elt_asncserviceParameterss = (asncserviceParameterss*) elt_asncserviceParameterss->nextElement;
      }
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_serviceCommand) != asnFALSE)
    {
      serviceCommand = object->serviceCommand;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_serviceResult) != asnFALSE)
    {
      if(object->serviceResult != (ServiceResult *)asnBNULL)
      {
        serviceResult = (ServiceResult*)object->serviceResult->__create();
        serviceResult->__copy(*object->serviceResult);
      }
      else
      {
        serviceResult = (ServiceResult *) 0;
      }
    }
    else
    {
      this->serviceResult = (ServiceResult*) asnBNULL;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_serviceStatus) != asnFALSE)
    {
      if(object->serviceStatus != (ServiceStatus *)asnBNULL)
      {
        serviceStatus = (ServiceStatus*)object->serviceStatus->__create();
        serviceStatus->__copy(*object->serviceStatus);
      }
      else
      {
        serviceStatus = (ServiceStatus *) 0;
      }
    }
    else
    {
      this->serviceStatus = (ServiceStatus*) asnBNULL;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_ServiceData__message) != asnFALSE)
    {
      if(object->message != (GeneralMessage__C *)asnBNULL)
      {
        switch(object->message->alternative)
        {
          case asn_GeneralMessage__message:
            this->message = new asncGeneralMessage__message(*(asncGeneralMessage__message*) object->message);
            break;
          case asn_ocetMessage:
            this->message = new asncocetMessage(*(asncocetMessage*) object->message);
            break;
          default: this->message = (GeneralMessage__C *) 0;
        }
      }
      else
      {
        this->message = (GeneralMessage__C *) 0;
      }
    }
    else
    {
      this->message = (GeneralMessage__C*) asnBNULL;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_pois) != asnFALSE)
    {
      asncpoiss *elt_asncpoiss;
      elt_asncpoiss = (asncpoiss*) object->pois.firstElement;
      for (asnMAXUINT countpois=0; countpois<object->pois.count; countpois++)
      {
        pois.addElement(new asncpoiss(*elt_asncpoiss));
        elt_asncpoiss = (asncpoiss*) elt_asncpoiss->nextElement;
      }
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_configuration) != asnFALSE)
    {
      if(object->configuration != (Configuration *)asnBNULL)
      {
        configuration = (Configuration*)object->configuration->__create();
        configuration->__copy(*object->configuration);
      }
      else
      {
        configuration = (Configuration *) 0;
      }
    }
    else
    {
      this->configuration = (Configuration*) asnBNULL;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_vehicleStatus) != asnFALSE)
    {
      if(object->vehicleStatus != (VehicleStatus *)asnBNULL)
      {
        vehicleStatus = (VehicleStatus*)object->vehicleStatus->__create();
        vehicleStatus->__copy(*object->vehicleStatus);
      }
      else
      {
        vehicleStatus = (VehicleStatus *) 0;
      }
    }
    else
    {
      this->vehicleStatus = (VehicleStatus*) asnBNULL;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_ServiceData__ota) != asnFALSE)
    {
      if(object->ota != (OTA *)asnBNULL)
      {
        ota = (OTA*)object->ota->__create();
        ota->__copy(*object->ota);
      }
      else
      {
        ota = (OTA *) 0;
      }
    }
    else
    {
      this->ota = (OTA*) asnBNULL;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_trip) != asnFALSE)
    {
      if(object->trip != (Trip *)asnBNULL)
      {
        trip = (Trip*)object->trip->__create();
        trip->__copy(*object->trip);
      }
      else
      {
        trip = (Trip *) 0;
      }
    }
    else
    {
      this->trip = (Trip*) asnBNULL;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_tripFragments) != asnFALSE)
    {
      asnctripFragmentss *elt_asnctripFragmentss;
      elt_asnctripFragmentss = (asnctripFragmentss*) object->tripFragments.firstElement;
      for (asnMAXUINT counttripFragments=0; counttripFragments<object->tripFragments.count; counttripFragments++)
      {
        tripFragments.addElement(new asnctripFragmentss(*elt_asnctripFragmentss));
        elt_asnctripFragmentss = (asnctripFragmentss*) elt_asnctripFragmentss->nextElement;
      }
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_trackPoints) != asnFALSE)
    {
      asnctrackPointss *elt_asnctrackPointss;
      elt_asnctrackPointss = (asnctrackPointss*) object->trackPoints.firstElement;
      for (asnMAXUINT counttrackPoints=0; counttrackPoints<object->trackPoints.count; counttrackPoints++)
      {
        trackPoints.addElement(new asnctrackPointss(*elt_asnctrackPointss));
        elt_asnctrackPointss = (asnctrackPointss*) elt_asnctrackPointss->nextElement;
      }
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_nevServiceData) != asnFALSE)
    {
      if(object->nevServiceData != (NEVServiceData *)asnBNULL)
      {
        nevServiceData = (NEVServiceData*)object->nevServiceData->__create();
        nevServiceData->__copy(*object->nevServiceData);
      }
      else
      {
        nevServiceData = (NEVServiceData *) 0;
      }
    }
    else
    {
      this->nevServiceData = (NEVServiceData*) asnBNULL;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_eventRule) != asnFALSE)
    {
      if(object->eventRule != (EventRule *)asnBNULL)
      {
        eventRule = (EventRule*)object->eventRule->__create();
        eventRule->__copy(*object->eventRule);
      }
      else
      {
        eventRule = (EventRule *) 0;
      }
    }
    else
    {
      this->eventRule = (EventRule*) asnBNULL;
    }
 }
}

/**
 *    TypeAssignment : ServiceParameter
 *    Class constructor
 */
ServiceParameter::ServiceParameter(const ServiceParameter& object)
  : asntype()  ,optional(object.optional.length, optionalField)
  ,key()
  ,intVal()
  ,stringVal()
  ,boolVal()
  ,timestampVal()
  ,dataVal()

{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : ServiceParameter
 * Copy method
 */
void ServiceParameter::__copy (const asntype& obj)
{
  const ServiceParameter* object = asnSCast(const ServiceParameter*,&obj);
  optionalField[0] = object->optionalField[0];
 {
    this->key.__copy (object->key);
 }
 {
    if(asnGetPresence(object->optionalField,asn_intVal) != asnFALSE)
    {
      intVal = object->intVal;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_ServiceParameter__stringVal) != asnFALSE)
    {
      this->stringVal.__copy (object->stringVal);
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_ServiceParameter__boolVal) != asnFALSE)
    {
      boolVal = object->boolVal;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_ServiceParameter__timestampVal) != asnFALSE)
    {
      if(object->timestampVal != (TimeStamp *)asnBNULL)
      {
        timestampVal = (TimeStamp*)object->timestampVal->__create();
        timestampVal->__copy(*object->timestampVal);
      }
      else
      {
        timestampVal = (TimeStamp *) 0;
      }
    }
    else
    {
      this->timestampVal = (TimeStamp*) asnBNULL;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_ServiceParameter__dataVal) != asnFALSE)
    {
      this->dataVal.__copy(object->dataVal);
    }
 }
}

/**
 *    TypeAssignment : ServiceResult
 *    Class constructor
 */
ServiceResult::ServiceResult(const ServiceResult& object)
  : asntype()  ,optional(object.optional.length, optionalField)
  ,operationSucceeded()
  ,error()

{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : ServiceResult
 * Copy method
 */
void ServiceResult::__copy (const asntype& obj)
{
  const ServiceResult* object = asnSCast(const ServiceResult*,&obj);
  optionalField[0] = object->optionalField[0];
 {
    operationSucceeded = object->operationSucceeded;
 }
 {
    if(asnGetPresence(object->optionalField,asn_error) != asnFALSE)
    {
      if(object->error != (Error *)asnBNULL)
      {
        error = (Error*)object->error->__create();
        error->__copy(*object->error);
      }
      else
      {
        error = (Error *) 0;
      }
    }
    else
    {
      this->error = (Error*) asnBNULL;
    }
 }
}

/**
 *    TypeAssignment : ServiceStatus
 *    Class constructor
 */
ServiceStatus::ServiceStatus(const ServiceStatus& object)
  : asntype()  ,remoteControlInhibited()

{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : ServiceStatus
 * Copy method
 */
void ServiceStatus::__copy (const asntype& obj)
{
  const ServiceStatus* object = asnSCast(const ServiceStatus*,&obj);
 {
    remoteControlInhibited = object->remoteControlInhibited;
 }
}

/**
 *    TypeAssignment : ServiceTrigger
 *    Class constructor
 */
ServiceTrigger::ServiceTrigger(const ServiceTrigger& object)
  : asntype()  ,optional(object.optional.length, optionalField)
  ,scheduledTime()
  ,recurrentOperation()
  ,duration()
  ,interval()
  ,occurs()
  ,endTime()

{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : ServiceTrigger
 * Copy method
 */
void ServiceTrigger::__copy (const asntype& obj)
{
  const ServiceTrigger* object = asnSCast(const ServiceTrigger*,&obj);
  optionalField[0] = object->optionalField[0];
 {
    if(asnGetPresence(object->optionalField,asn_scheduledTime) != asnFALSE)
    {
      if(object->scheduledTime != (TimeStamp *)asnBNULL)
      {
        scheduledTime = (TimeStamp*)object->scheduledTime->__create();
        scheduledTime->__copy(*object->scheduledTime);
      }
      else
      {
        scheduledTime = (TimeStamp *) 0;
      }
    }
    else
    {
      this->scheduledTime = (TimeStamp*) asnBNULL;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_recurrentOperation) != asnFALSE)
    {
      recurrentOperation = object->recurrentOperation;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_duration) != asnFALSE)
    {
      duration = object->duration;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_ServiceTrigger__interval) != asnFALSE)
    {
      interval = object->interval;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_occurs) != asnFALSE)
    {
      occurs = object->occurs;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_ServiceTrigger__endTime) != asnFALSE)
    {
      if(object->endTime != (TimeStamp *)asnBNULL)
      {
        endTime = (TimeStamp*)object->endTime->__create();
        endTime->__copy(*object->endTime);
      }
      else
      {
        endTime = (TimeStamp *) 0;
      }
    }
    else
    {
      this->endTime = (TimeStamp*) asnBNULL;
    }
 }
}

/**
 *    TypeAssignment : TrackPoint
 *    Class constructor
 */
TrackPoint::TrackPoint(const TrackPoint& object)
  : asntype()  ,optional(object.optional.length, optionalField)
  ,systemTime()
  ,position()
  ,speed()
  ,direction()
  ,isSVT()
  ,odometer()
  ,travelDistanceSinceLastWaypoint()
  ,fuelConsumptionSinceLastWaypoint()
  ,electricConsumptionSinceLastSample()
  ,electricRegenerationSinceLastSample()

{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : TrackPoint
 * Copy method
 */
void TrackPoint::__copy (const asntype& obj)
{
  const TrackPoint* object = asnSCast(const TrackPoint*,&obj);
  optionalField[0] = object->optionalField[0];
 {
    if(object->systemTime != (TimeStamp *)asnBNULL)
    {
      systemTime = (TimeStamp*)object->systemTime->__create();
      systemTime->__copy(*object->systemTime);
    }
    else
    {
      systemTime = (TimeStamp *) 0;
    }
 }
 {
    if(object->position != (Position *)asnBNULL)
    {
      position = (Position*)object->position->__create();
      position->__copy(*object->position);
    }
    else
    {
      position = (Position *) 0;
    }
 }
 {
    speed = object->speed;
 }
 {
    if(asnGetPresence(object->optionalField,asn_TrackPoint__direction) != asnFALSE)
    {
      direction = object->direction;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_isSVT) != asnFALSE)
    {
      isSVT = object->isSVT;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_TrackPoint__odometer) != asnFALSE)
    {
      odometer = object->odometer;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_travelDistanceSinceLastWaypoint) != asnFALSE)
    {
      travelDistanceSinceLastWaypoint = object->travelDistanceSinceLastWaypoint;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_fuelConsumptionSinceLastWaypoint) != asnFALSE)
    {
      fuelConsumptionSinceLastWaypoint = object->fuelConsumptionSinceLastWaypoint;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_electricConsumptionSinceLastSample) != asnFALSE)
    {
      electricConsumptionSinceLastSample = object->electricConsumptionSinceLastSample;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_electricRegenerationSinceLastSample) != asnFALSE)
    {
      electricRegenerationSinceLastSample = object->electricRegenerationSinceLastSample;
    }
 }
}

/**
 *    TypeAssignment : Trip
 *    Class constructor
 */
Trip::Trip(const Trip& object)
  : asntype()  ,optional(object.optional.length, optionalField)
  ,tripId()
  ,startTime()
  ,startOdometer()
  ,fuelConsumption()
  ,traveledDistance()
  ,trackpoints()
  ,waypoints()
  ,avgSpeed()
  ,endTime()
  ,endOdometer()
  ,electricConsumption()
  ,electricRegeneration()

{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : Trip
 * Copy method
 */
void Trip::__copy (const asntype& obj)
{
  const Trip* object = asnSCast(const Trip*,&obj);
  optionalField[0] = object->optionalField[0];
 {
    tripId = object->tripId;
 }
 {
    if(object->startTime != (TimeStamp *)asnBNULL)
    {
      startTime = (TimeStamp*)object->startTime->__create();
      startTime->__copy(*object->startTime);
    }
    else
    {
      startTime = (TimeStamp *) 0;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_Trip__startOdometer) != asnFALSE)
    {
      startOdometer = object->startOdometer;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_fuelConsumption) != asnFALSE)
    {
      fuelConsumption = object->fuelConsumption;
    }
 }
 {
    traveledDistance = object->traveledDistance;
 }
 {
    asnctrackpointss *elt_asnctrackpointss;
    elt_asnctrackpointss = (asnctrackpointss*) object->trackpoints.firstElement;
    for (asnMAXUINT counttrackpoints=0; counttrackpoints<object->trackpoints.count; counttrackpoints++)
    {
      trackpoints.addElement(new asnctrackpointss(*elt_asnctrackpointss));
      elt_asnctrackpointss = (asnctrackpointss*) elt_asnctrackpointss->nextElement;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_waypoints) != asnFALSE)
    {
      asncwaypointss *elt_asncwaypointss;
      elt_asncwaypointss = (asncwaypointss*) object->waypoints.firstElement;
      for (asnMAXUINT countwaypoints=0; countwaypoints<object->waypoints.count; countwaypoints++)
      {
        waypoints.addElement(new asncwaypointss(*elt_asncwaypointss));
        elt_asncwaypointss = (asncwaypointss*) elt_asncwaypointss->nextElement;
      }
    }
 }
 {
    avgSpeed = object->avgSpeed;
 }
 {
    if(object->endTime != (TimeStamp *)asnBNULL)
    {
      endTime = (TimeStamp*)object->endTime->__create();
      endTime->__copy(*object->endTime);
    }
    else
    {
      endTime = (TimeStamp *) 0;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_Trip__endOdometer) != asnFALSE)
    {
      endOdometer = object->endOdometer;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_electricConsumption) != asnFALSE)
    {
      electricConsumption = object->electricConsumption;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_electricRegeneration) != asnFALSE)
    {
      electricRegeneration = object->electricRegeneration;
    }
 }
}

/**
 *    TypeAssignment : TripFragment
 *    Class constructor
 */
TripFragment::TripFragment(const TripFragment& object)
  : asntype()  ,optional(object.optional.length, optionalField)
  ,startTime()
  ,startPosition()
  ,startOdometer()
  ,startFuelLevel()
  ,startElectricConsumption()
  ,startElectricRegeneration()
  ,endTime()
  ,endPosition()
  ,endOdometer()
  ,endFuelLevel()
  ,endElectricConsumption()
  ,endElectricRegeneration()

{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : TripFragment
 * Copy method
 */
void TripFragment::__copy (const asntype& obj)
{
  const TripFragment* object = asnSCast(const TripFragment*,&obj);
  optionalField[0] = object->optionalField[0];
  optionalField[1] = object->optionalField[1];
 {
    if(object->startTime != (TimeStamp *)asnBNULL)
    {
      startTime = (TimeStamp*)object->startTime->__create();
      startTime->__copy(*object->startTime);
    }
    else
    {
      startTime = (TimeStamp *) 0;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_startPosition) != asnFALSE)
    {
      if(object->startPosition != (Position *)asnBNULL)
      {
        startPosition = (Position*)object->startPosition->__create();
        startPosition->__copy(*object->startPosition);
      }
      else
      {
        startPosition = (Position *) 0;
      }
    }
    else
    {
      this->startPosition = (Position*) asnBNULL;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_TripFragment__startOdometer) != asnFALSE)
    {
      startOdometer = object->startOdometer;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_startFuelLevel) != asnFALSE)
    {
      startFuelLevel = object->startFuelLevel;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_startElectricConsumption) != asnFALSE)
    {
      startElectricConsumption = object->startElectricConsumption;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_startElectricRegeneration) != asnFALSE)
    {
      startElectricRegeneration = object->startElectricRegeneration;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_TripFragment__endTime) != asnFALSE)
    {
      if(object->endTime != (TimeStamp *)asnBNULL)
      {
        endTime = (TimeStamp*)object->endTime->__create();
        endTime->__copy(*object->endTime);
      }
      else
      {
        endTime = (TimeStamp *) 0;
      }
    }
    else
    {
      this->endTime = (TimeStamp*) asnBNULL;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_endPosition) != asnFALSE)
    {
      if(object->endPosition != (Position *)asnBNULL)
      {
        endPosition = (Position*)object->endPosition->__create();
        endPosition->__copy(*object->endPosition);
      }
      else
      {
        endPosition = (Position *) 0;
      }
    }
    else
    {
      this->endPosition = (Position*) asnBNULL;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_TripFragment__endOdometer) != asnFALSE)
    {
      endOdometer = object->endOdometer;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_endFuelLevel) != asnFALSE)
    {
      endFuelLevel = object->endFuelLevel;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_endElectricConsumption) != asnFALSE)
    {
      endElectricConsumption = object->endElectricConsumption;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_endElectricRegeneration) != asnFALSE)
    {
      endElectricRegeneration = object->endElectricRegeneration;
    }
 }
}

/**
 *    TypeAssignment : AdditionalVehicleStatus
 *    Class constructor
 */
AdditionalVehicleStatus::AdditionalVehicleStatus(const AdditionalVehicleStatus& object)
  : asntype()  ,optional(object.optional.length, optionalField)
  ,confAndId()
  ,drivingSafetyStatus()
  ,maintenanceStatus()
  ,runningStatus()
  ,climateStatus()
  ,drivingBehaviourStatus()
  ,pollutionStatus()
  ,ecuWarningMessages()
  ,electricVehicleStatus()
  ,carConfig()
  ,signals()
  ,data()

{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : AdditionalVehicleStatus
 * Copy method
 */
void AdditionalVehicleStatus::__copy (const asntype& obj)
{
  const AdditionalVehicleStatus* object = asnSCast(const AdditionalVehicleStatus*,&obj);
  optionalField[0] = object->optionalField[0];
  optionalField[1] = object->optionalField[1];
 {
    if(asnGetPresence(object->optionalField,asn_confAndId) != asnFALSE)
    {
      if(object->confAndId != (ConfigurationAndIdentity *)asnBNULL)
      {
        confAndId = (ConfigurationAndIdentity*)object->confAndId->__create();
        confAndId->__copy(*object->confAndId);
      }
      else
      {
        confAndId = (ConfigurationAndIdentity *) 0;
      }
    }
    else
    {
      this->confAndId = (ConfigurationAndIdentity*) asnBNULL;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_drivingSafetyStatus) != asnFALSE)
    {
      if(object->drivingSafetyStatus != (DrivingSafetyStatus *)asnBNULL)
      {
        drivingSafetyStatus = (DrivingSafetyStatus*)object->drivingSafetyStatus->__create();
        drivingSafetyStatus->__copy(*object->drivingSafetyStatus);
      }
      else
      {
        drivingSafetyStatus = (DrivingSafetyStatus *) 0;
      }
    }
    else
    {
      this->drivingSafetyStatus = (DrivingSafetyStatus*) asnBNULL;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_maintenanceStatus) != asnFALSE)
    {
      if(object->maintenanceStatus != (MaintenanceStatus *)asnBNULL)
      {
        maintenanceStatus = (MaintenanceStatus*)object->maintenanceStatus->__create();
        maintenanceStatus->__copy(*object->maintenanceStatus);
      }
      else
      {
        maintenanceStatus = (MaintenanceStatus *) 0;
      }
    }
    else
    {
      this->maintenanceStatus = (MaintenanceStatus*) asnBNULL;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_runningStatus) != asnFALSE)
    {
      if(object->runningStatus != (RunningStatus *)asnBNULL)
      {
        runningStatus = (RunningStatus*)object->runningStatus->__create();
        runningStatus->__copy(*object->runningStatus);
      }
      else
      {
        runningStatus = (RunningStatus *) 0;
      }
    }
    else
    {
      this->runningStatus = (RunningStatus*) asnBNULL;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_climateStatus) != asnFALSE)
    {
      if(object->climateStatus != (ClimateStatus *)asnBNULL)
      {
        climateStatus = (ClimateStatus*)object->climateStatus->__create();
        climateStatus->__copy(*object->climateStatus);
      }
      else
      {
        climateStatus = (ClimateStatus *) 0;
      }
    }
    else
    {
      this->climateStatus = (ClimateStatus*) asnBNULL;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_drivingBehaviourStatus) != asnFALSE)
    {
      if(object->drivingBehaviourStatus != (DrivingBehaviourStatus *)asnBNULL)
      {
        drivingBehaviourStatus = (DrivingBehaviourStatus*)object->drivingBehaviourStatus->__create();
        drivingBehaviourStatus->__copy(*object->drivingBehaviourStatus);
      }
      else
      {
        drivingBehaviourStatus = (DrivingBehaviourStatus *) 0;
      }
    }
    else
    {
      this->drivingBehaviourStatus = (DrivingBehaviourStatus*) asnBNULL;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_pollutionStatus) != asnFALSE)
    {
      if(object->pollutionStatus != (PollutionStatus *)asnBNULL)
      {
        pollutionStatus = (PollutionStatus*)object->pollutionStatus->__create();
        pollutionStatus->__copy(*object->pollutionStatus);
      }
      else
      {
        pollutionStatus = (PollutionStatus *) 0;
      }
    }
    else
    {
      this->pollutionStatus = (PollutionStatus*) asnBNULL;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_ecuWarningMessages) != asnFALSE)
    {
      asncEcuWarningMessagess *elt_asncEcuWarningMessagess;
      elt_asncEcuWarningMessagess = (asncEcuWarningMessagess*) object->ecuWarningMessages.firstElement;
      for (asnMAXUINT countecuWarningMessages=0; countecuWarningMessages<object->ecuWarningMessages.count; countecuWarningMessages++)
      {
        ecuWarningMessages.addElement(new asncEcuWarningMessagess(*elt_asncEcuWarningMessagess));
        elt_asncEcuWarningMessagess = (asncEcuWarningMessagess*) elt_asncEcuWarningMessagess->nextElement;
      }
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_electricVehicleStatus) != asnFALSE)
    {
      if(object->electricVehicleStatus != (ElectricVehicleStatus *)asnBNULL)
      {
        electricVehicleStatus = (ElectricVehicleStatus*)object->electricVehicleStatus->__create();
        electricVehicleStatus->__copy(*object->electricVehicleStatus);
      }
      else
      {
        electricVehicleStatus = (ElectricVehicleStatus *) 0;
      }
    }
    else
    {
      this->electricVehicleStatus = (ElectricVehicleStatus*) asnBNULL;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_carConfig) != asnFALSE)
    {
      if(object->carConfig != (CarConfig *)asnBNULL)
      {
        carConfig = (CarConfig*)object->carConfig->__create();
        carConfig->__copy(*object->carConfig);
      }
      else
      {
        carConfig = (CarConfig *) 0;
      }
    }
    else
    {
      this->carConfig = (CarConfig*) asnBNULL;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_AdditionalVehicleStatus__signals) != asnFALSE)
    {
      asncAdditionalVehicleStatus__signalss *elt_asncAdditionalVehicleStatus__signalss;
      elt_asncAdditionalVehicleStatus__signalss = (asncAdditionalVehicleStatus__signalss*) object->signals.firstElement;
      for (asnMAXUINT countsignals=0; countsignals<object->signals.count; countsignals++)
      {
        signals.addElement(new asncAdditionalVehicleStatus__signalss(*elt_asncAdditionalVehicleStatus__signalss));
        elt_asncAdditionalVehicleStatus__signalss = (asncAdditionalVehicleStatus__signalss*) elt_asncAdditionalVehicleStatus__signalss->nextElement;
      }
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_AdditionalVehicleStatus__data) != asnFALSE)
    {
      this->data.__copy(object->data);
    }
 }
}

/**
 *    TypeAssignment : BasicVehicleStatus
 *    Class constructor
 */
BasicVehicleStatus::BasicVehicleStatus(const BasicVehicleStatus& object)
  : asntype()  ,optional(object.optional.length, optionalField)
  ,position()
  ,speed()
  ,speedValidity()
  ,direction()
  ,engineStatus()
  ,keyStatus()
  ,engineBlockedStatus()
  ,distanceToEmpty()
  ,usageMode()

{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : BasicVehicleStatus
 * Copy method
 */
void BasicVehicleStatus::__copy (const asntype& obj)
{
  const BasicVehicleStatus* object = asnSCast(const BasicVehicleStatus*,&obj);
  optionalField[0] = object->optionalField[0];
 {
    if(object->position != (Position *)asnBNULL)
    {
      position = (Position*)object->position->__create();
      position->__copy(*object->position);
    }
    else
    {
      position = (Position *) 0;
    }
 }
 {
    speed = object->speed;
 }
 {
    if(asnGetPresence(object->optionalField,asn_BasicVehicleStatus__speedValidity) != asnFALSE)
    {
      speedValidity = object->speedValidity;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_BasicVehicleStatus__direction) != asnFALSE)
    {
      direction = object->direction;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_engineStatus) != asnFALSE)
    {
      engineStatus = object->engineStatus;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_keyStatus) != asnFALSE)
    {
      keyStatus = object->keyStatus;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_engineBlockedStatus) != asnFALSE)
    {
      engineBlockedStatus = object->engineBlockedStatus;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_distanceToEmpty) != asnFALSE)
    {
      distanceToEmpty = object->distanceToEmpty;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_usageMode) != asnFALSE)
    {
      usageMode = object->usageMode;
    }
 }
}

/**
 *    TypeAssignment : BatteryStatus
 *    Class constructor
 */
BatteryStatus::BatteryStatus(const BatteryStatus& object)
  : asntype()  ,optional(object.optional.length, optionalField)
  ,stateOfCharge()
  ,chargeLevel()
  ,stateOfHealth()
  ,voltage()

{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : BatteryStatus
 * Copy method
 */
void BatteryStatus::__copy (const asntype& obj)
{
  const BatteryStatus* object = asnSCast(const BatteryStatus*,&obj);
  optionalField[0] = object->optionalField[0];
 {
    if(asnGetPresence(object->optionalField,asn_BatteryStatus__stateOfCharge) != asnFALSE)
    {
      stateOfCharge = object->stateOfCharge;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_BatteryStatus__chargeLevel) != asnFALSE)
    {
      chargeLevel = object->chargeLevel;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_stateOfHealth) != asnFALSE)
    {
      stateOfHealth = object->stateOfHealth;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_voltage) != asnFALSE)
    {
      voltage = object->voltage;
    }
 }
}

/**
 *    TypeAssignment : CarConfig
 *    Class constructor
 */
CarConfig::CarConfig(const CarConfig& object)
  : asntype()  ,optional(object.optional.length, optionalField)
  ,heatedFrontSeats()
  ,parkingClimateLevel()
  ,heatedSteeringWheel()

{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : CarConfig
 * Copy method
 */
void CarConfig::__copy (const asntype& obj)
{
  const CarConfig* object = asnSCast(const CarConfig*,&obj);
  optionalField[0] = object->optionalField[0];
 {
    if(asnGetPresence(object->optionalField,asn_heatedFrontSeats) != asnFALSE)
    {
      heatedFrontSeats = object->heatedFrontSeats;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_parkingClimateLevel) != asnFALSE)
    {
      parkingClimateLevel = object->parkingClimateLevel;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_heatedSteeringWheel) != asnFALSE)
    {
      heatedSteeringWheel = object->heatedSteeringWheel;
    }
 }
}

/**
 *    TypeAssignment : ClimateStatus
 *    Class constructor
 */
ClimateStatus::ClimateStatus(const ClimateStatus& object)
  : asntype()  ,optional(object.optional.length, optionalField)
  ,winStatusDriver()
  ,winStatusDriverValidity()
  ,winStatusPassenger()
  ,winStatusPassengerValidity()
  ,winStatusDriverRear()
  ,winStatusDriverRearValidity()
  ,winStatusPassengerRear()
  ,winStatusPassengerRearValidity()
  ,sunroofOpenStatus()
  ,sunroofOpenStatusValidity()
  ,ventilateStatus()
  ,winPosDriver()
  ,winPosPassenger()
  ,winPosDriverRear()
  ,winPosPassengerRear()
  ,interiorTemp()
  ,exteriorTemp()
  ,exteriorTempValidity()
  ,preClimateActive()
  ,airCleanSts()
  ,winCloseReminder()
  ,drvHeatSts()
  ,passHeatingSts()
  ,rlHeatingSts()
  ,rrHeatingSts()
  ,drvVentSts()
  ,passVentSts()
  ,rrVentSts()
  ,rlVentSts()

{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : ClimateStatus
 * Copy method
 */
void ClimateStatus::__copy (const asntype& obj)
{
  const ClimateStatus* object = asnSCast(const ClimateStatus*,&obj);
  optionalField[0] = object->optionalField[0];
  optionalField[1] = object->optionalField[1];
  optionalField[2] = object->optionalField[2];
  optionalField[3] = object->optionalField[3];
 {
    if(asnGetPresence(object->optionalField,asn_winStatusDriver) != asnFALSE)
    {
      winStatusDriver = object->winStatusDriver;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_winStatusDriverValidity) != asnFALSE)
    {
      winStatusDriverValidity = object->winStatusDriverValidity;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_winStatusPassenger) != asnFALSE)
    {
      winStatusPassenger = object->winStatusPassenger;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_winStatusPassengerValidity) != asnFALSE)
    {
      winStatusPassengerValidity = object->winStatusPassengerValidity;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_winStatusDriverRear) != asnFALSE)
    {
      winStatusDriverRear = object->winStatusDriverRear;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_winStatusDriverRearValidity) != asnFALSE)
    {
      winStatusDriverRearValidity = object->winStatusDriverRearValidity;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_winStatusPassengerRear) != asnFALSE)
    {
      winStatusPassengerRear = object->winStatusPassengerRear;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_winStatusPassengerRearValidity) != asnFALSE)
    {
      winStatusPassengerRearValidity = object->winStatusPassengerRearValidity;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_sunroofOpenStatus) != asnFALSE)
    {
      sunroofOpenStatus = object->sunroofOpenStatus;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_sunroofOpenStatusValidity) != asnFALSE)
    {
      sunroofOpenStatusValidity = object->sunroofOpenStatusValidity;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_ventilateStatus) != asnFALSE)
    {
      ventilateStatus = object->ventilateStatus;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_winPosDriver) != asnFALSE)
    {
      winPosDriver = object->winPosDriver;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_winPosPassenger) != asnFALSE)
    {
      winPosPassenger = object->winPosPassenger;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_winPosDriverRear) != asnFALSE)
    {
      winPosDriverRear = object->winPosDriverRear;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_winPosPassengerRear) != asnFALSE)
    {
      winPosPassengerRear = object->winPosPassengerRear;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_interiorTemp) != asnFALSE)
    {
      interiorTemp = object->interiorTemp;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_exteriorTemp) != asnFALSE)
    {
      exteriorTemp = object->exteriorTemp;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_exteriorTempValidity) != asnFALSE)
    {
      exteriorTempValidity = object->exteriorTempValidity;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_preClimateActive) != asnFALSE)
    {
      preClimateActive = object->preClimateActive;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_airCleanSts) != asnFALSE)
    {
      airCleanSts = object->airCleanSts;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_winCloseReminder) != asnFALSE)
    {
      winCloseReminder = object->winCloseReminder;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_drvHeatSts) != asnFALSE)
    {
      drvHeatSts = object->drvHeatSts;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_passHeatingSts) != asnFALSE)
    {
      passHeatingSts = object->passHeatingSts;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_rlHeatingSts) != asnFALSE)
    {
      rlHeatingSts = object->rlHeatingSts;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_rrHeatingSts) != asnFALSE)
    {
      rrHeatingSts = object->rrHeatingSts;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_drvVentSts) != asnFALSE)
    {
      drvVentSts = object->drvVentSts;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_passVentSts) != asnFALSE)
    {
      passVentSts = object->passVentSts;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_rrVentSts) != asnFALSE)
    {
      rrVentSts = object->rrVentSts;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_rlVentSts) != asnFALSE)
    {
      rlVentSts = object->rlVentSts;
    }
 }
}

/**
 *    TypeAssignment : ConfigurationAndIdentity
 *    Class constructor
 */
ConfigurationAndIdentity::ConfigurationAndIdentity(const ConfigurationAndIdentity& object)
  : asntype()  ,optional(object.optional.length, optionalField)
  ,vin()
  ,fuelType()

{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : ConfigurationAndIdentity
 * Copy method
 */
void ConfigurationAndIdentity::__copy (const asntype& obj)
{
  const ConfigurationAndIdentity* object = asnSCast(const ConfigurationAndIdentity*,&obj);
  optionalField[0] = object->optionalField[0];
 {
    if(asnGetPresence(object->optionalField,asn_ConfigurationAndIdentity__vin) != asnFALSE)
    {
      this->vin.__copy (object->vin);
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_fuelType) != asnFALSE)
    {
      fuelType = object->fuelType;
    }
 }
}

/**
 *    TypeAssignment : DiagnosticTroubleCode
 *    Class constructor
 */
DiagnosticTroubleCode::DiagnosticTroubleCode(const DiagnosticTroubleCode& object)
  : asntype()  ,optional(object.optional.length, optionalField)
  ,dtc()
  ,status()
  ,failureCount()
  ,lastFail()
  ,firtFail()
  ,firstFailureOdometer()
  ,firstFailureBatteryVoltage()
  ,firstFailureVehicleSpeed()

{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : DiagnosticTroubleCode
 * Copy method
 */
void DiagnosticTroubleCode::__copy (const asntype& obj)
{
  const DiagnosticTroubleCode* object = asnSCast(const DiagnosticTroubleCode*,&obj);
  optionalField[0] = object->optionalField[0];
 {
    this->dtc.__copy (object->dtc);
 }
 {
    this->status.__copy(object->status);
 }
 {
    if(asnGetPresence(object->optionalField,asn_failureCount) != asnFALSE)
    {
      failureCount = object->failureCount;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_lastFail) != asnFALSE)
    {
      if(object->lastFail != (TimeStamp *)asnBNULL)
      {
        lastFail = (TimeStamp*)object->lastFail->__create();
        lastFail->__copy(*object->lastFail);
      }
      else
      {
        lastFail = (TimeStamp *) 0;
      }
    }
    else
    {
      this->lastFail = (TimeStamp*) asnBNULL;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_firtFail) != asnFALSE)
    {
      if(object->firtFail != (TimeStamp *)asnBNULL)
      {
        firtFail = (TimeStamp*)object->firtFail->__create();
        firtFail->__copy(*object->firtFail);
      }
      else
      {
        firtFail = (TimeStamp *) 0;
      }
    }
    else
    {
      this->firtFail = (TimeStamp*) asnBNULL;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_firstFailureOdometer) != asnFALSE)
    {
      firstFailureOdometer = object->firstFailureOdometer;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_firstFailureBatteryVoltage) != asnFALSE)
    {
      firstFailureBatteryVoltage = object->firstFailureBatteryVoltage;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_firstFailureVehicleSpeed) != asnFALSE)
    {
      firstFailureVehicleSpeed = object->firstFailureVehicleSpeed;
    }
 }
}

/**
 *    TypeAssignment : DrivingBehaviourStatus
 *    Class constructor
 */
DrivingBehaviourStatus::DrivingBehaviourStatus(const DrivingBehaviourStatus& object)
  : asntype()  ,optional(object.optional.length, optionalField)
  ,brakePedalDepressed()
  ,brakePedalDepressedValidity()
  ,engineSpeed()
  ,engineSpeedValidity()
  ,transimissionGearPostion()
  ,cruiseControlStatus()

{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : DrivingBehaviourStatus
 * Copy method
 */
void DrivingBehaviourStatus::__copy (const asntype& obj)
{
  const DrivingBehaviourStatus* object = asnSCast(const DrivingBehaviourStatus*,&obj);
  optionalField[0] = object->optionalField[0];
 {
    if(asnGetPresence(object->optionalField,asn_brakePedalDepressed) != asnFALSE)
    {
      brakePedalDepressed = object->brakePedalDepressed;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_brakePedalDepressedValidity) != asnFALSE)
    {
      brakePedalDepressedValidity = object->brakePedalDepressedValidity;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_engineSpeed) != asnFALSE)
    {
      engineSpeed = object->engineSpeed;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_engineSpeedValidity) != asnFALSE)
    {
      engineSpeedValidity = object->engineSpeedValidity;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_transimissionGearPostion) != asnFALSE)
    {
      transimissionGearPostion = object->transimissionGearPostion;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_cruiseControlStatus) != asnFALSE)
    {
      cruiseControlStatus = object->cruiseControlStatus;
    }
 }
}

/**
 *    TypeAssignment : DrivingSafetyStatus
 *    Class constructor
 */
DrivingSafetyStatus::DrivingSafetyStatus(const DrivingSafetyStatus& object)
  : asntype()  ,optional(object.optional.length, optionalField)
  ,srsStatus()
  ,vehicleAlarm()
  ,doorOpenStatusDriver()
  ,doorOpenStatusPassenger()
  ,doorOpenStatusDriverRear()
  ,doorOpenStatusPassengerRear()
  ,doorLockStatusDriver()
  ,doorLockStatusPassenger()
  ,doorLockStatusDriverRear()
  ,doorLockStatusPassengerRear()
  ,trunkOpenStatus()
  ,trunkLockStatus()
  ,engineHoodOpenStatus()
  ,centralLockingStatus()
  ,seatBeltStatusDriver()
  ,seatBeltStatusPassenger()
  ,seatBeltStatusDriverRear()
  ,seatBeltStatusPassengerRear()
  ,handBrakeStatus()
  ,electricParkBrakeStatus()
  ,electricParkBrakeStatusValidity()

{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : DrivingSafetyStatus
 * Copy method
 */
void DrivingSafetyStatus::__copy (const asntype& obj)
{
  const DrivingSafetyStatus* object = asnSCast(const DrivingSafetyStatus*,&obj);
  optionalField[0] = object->optionalField[0];
  optionalField[1] = object->optionalField[1];
  optionalField[2] = object->optionalField[2];
 {
    if(asnGetPresence(object->optionalField,asn_srsStatus) != asnFALSE)
    {
      srsStatus = object->srsStatus;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_vehicleAlarm) != asnFALSE)
    {
      vehicleAlarm = object->vehicleAlarm;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_doorOpenStatusDriver) != asnFALSE)
    {
      doorOpenStatusDriver = object->doorOpenStatusDriver;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_doorOpenStatusPassenger) != asnFALSE)
    {
      doorOpenStatusPassenger = object->doorOpenStatusPassenger;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_doorOpenStatusDriverRear) != asnFALSE)
    {
      doorOpenStatusDriverRear = object->doorOpenStatusDriverRear;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_doorOpenStatusPassengerRear) != asnFALSE)
    {
      doorOpenStatusPassengerRear = object->doorOpenStatusPassengerRear;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_doorLockStatusDriver) != asnFALSE)
    {
      doorLockStatusDriver = object->doorLockStatusDriver;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_doorLockStatusPassenger) != asnFALSE)
    {
      doorLockStatusPassenger = object->doorLockStatusPassenger;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_doorLockStatusDriverRear) != asnFALSE)
    {
      doorLockStatusDriverRear = object->doorLockStatusDriverRear;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_doorLockStatusPassengerRear) != asnFALSE)
    {
      doorLockStatusPassengerRear = object->doorLockStatusPassengerRear;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_trunkOpenStatus) != asnFALSE)
    {
      trunkOpenStatus = object->trunkOpenStatus;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_trunkLockStatus) != asnFALSE)
    {
      trunkLockStatus = object->trunkLockStatus;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_engineHoodOpenStatus) != asnFALSE)
    {
      engineHoodOpenStatus = object->engineHoodOpenStatus;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_centralLockingStatus) != asnFALSE)
    {
      centralLockingStatus = object->centralLockingStatus;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_seatBeltStatusDriver) != asnFALSE)
    {
      seatBeltStatusDriver = object->seatBeltStatusDriver;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_seatBeltStatusPassenger) != asnFALSE)
    {
      seatBeltStatusPassenger = object->seatBeltStatusPassenger;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_seatBeltStatusDriverRear) != asnFALSE)
    {
      seatBeltStatusDriverRear = object->seatBeltStatusDriverRear;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_seatBeltStatusPassengerRear) != asnFALSE)
    {
      seatBeltStatusPassengerRear = object->seatBeltStatusPassengerRear;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_handBrakeStatus) != asnFALSE)
    {
      handBrakeStatus = object->handBrakeStatus;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_electricParkBrakeStatus) != asnFALSE)
    {
      electricParkBrakeStatus = object->electricParkBrakeStatus;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_electricParkBrakeStatusValidity) != asnFALSE)
    {
      electricParkBrakeStatusValidity = object->electricParkBrakeStatusValidity;
    }
 }
}

/**
 *    TypeAssignment : ECUDiagnostic
 *    Class constructor
 */
ECUDiagnostic::ECUDiagnostic(const ECUDiagnostic& object)
  : asntype()  ,optional(object.optional.length, optionalField)
  ,ecuID()
  ,diagnosticResult()
  ,dtcs()
  ,exceptionCode()

{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : ECUDiagnostic
 * Copy method
 */
void ECUDiagnostic::__copy (const asntype& obj)
{
  const ECUDiagnostic* object = asnSCast(const ECUDiagnostic*,&obj);
  optionalField[0] = object->optionalField[0];
 {
    this->ecuID.__copy (object->ecuID);
 }
 {
    diagnosticResult = object->diagnosticResult;
 }
 {
    if(asnGetPresence(object->optionalField,asn_dtcs) != asnFALSE)
    {
      asncdtcss *elt_asncdtcss;
      elt_asncdtcss = (asncdtcss*) object->dtcs.firstElement;
      for (asnMAXUINT countdtcs=0; countdtcs<object->dtcs.count; countdtcs++)
      {
        dtcs.addElement(new asncdtcss(*elt_asncdtcss));
        elt_asncdtcss = (asncdtcss*) elt_asncdtcss->nextElement;
      }
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_exceptionCode) != asnFALSE)
    {
      exceptionCode = object->exceptionCode;
    }
 }
}

/**
 *    TypeAssignment : asncECUDiagnosticss
 *    Class constructor
 */
asncECUDiagnosticss::asncECUDiagnosticss(const asncECUDiagnosticss& object)
  : asnListElement()
  ,optional(object.optional.length, optionalField)
  ,ecuID()
  ,diagnosticResult()
  ,dtcs()
  ,exceptionCode()
{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : asncECUDiagnosticss
 * Copy method
 */
void asncECUDiagnosticss::__copy (const asntype& obj)
{
  const asncECUDiagnosticss* object = asnSCast(const asncECUDiagnosticss*,&obj);
  optionalField[0] = object->optionalField[0];
 {
    this->ecuID.__copy (object->ecuID);
 }
 {
    diagnosticResult = object->diagnosticResult;
 }
 {
    if(asnGetPresence(object->optionalField,asn_dtcs) != asnFALSE)
    {
      asncdtcss *elt_asncdtcss;
      elt_asncdtcss = (asncdtcss*) object->dtcs.firstElement;
      for (asnMAXUINT countdtcs=0; countdtcs<object->dtcs.count; countdtcs++)
      {
        dtcs.addElement(new asncdtcss(*elt_asncdtcss));
        elt_asncdtcss = (asncdtcss*) elt_asncdtcss->nextElement;
      }
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_exceptionCode) != asnFALSE)
    {
      exceptionCode = object->exceptionCode;
    }
 }
}
/**
 *    TypeAssignment : ECUDiagnostics
 *    Class constructor
 */
ECUDiagnostics::ECUDiagnostics(const ECUDiagnostics& object)
  : asntype(),value(){
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : ECUDiagnostics
 * Copy method
 */
void ECUDiagnostics::__copy (const asntype& obj)
{
  const ECUDiagnostics* object = asnSCast(const ECUDiagnostics*,&obj);
  asncECUDiagnosticss *elt_asncECUDiagnosticss;
  elt_asncECUDiagnosticss = (asncECUDiagnosticss*) object->value.firstElement;
  for (asnMAXUINT countvalue=0; countvalue<object->value.count; countvalue++)
  {
    value.addElement(new asncECUDiagnosticss(*elt_asncECUDiagnosticss));
    elt_asncECUDiagnosticss = (asncECUDiagnosticss*) elt_asncECUDiagnosticss->nextElement;
  }
}

/**
 *    TypeAssignment : asncEcuWarningMessagess
 *    Class constructor
 */
asncEcuWarningMessagess::asncEcuWarningMessagess(const asncEcuWarningMessagess& object)
  : asnListElement()
  ,optional(object.optional.length, optionalField)
  ,key()
  ,collectTime()
  ,value()
  ,stringVal()
  ,boolVal()
  ,timestampVal()
  ,dataVal()
{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : asncEcuWarningMessagess
 * Copy method
 */
void asncEcuWarningMessagess::__copy (const asntype& obj)
{
  const asncEcuWarningMessagess* object = asnSCast(const asncEcuWarningMessagess*,&obj);
  optionalField[0] = object->optionalField[0];
 {
    this->key.__copy (object->key);
 }
 {
    if(asnGetPresence(object->optionalField,asn_collectTime) != asnFALSE)
    {
      if(object->collectTime != (TimeStamp *)asnBNULL)
      {
        collectTime = (TimeStamp*)object->collectTime->__create();
        collectTime->__copy(*object->collectTime);
      }
      else
      {
        collectTime = (TimeStamp *) 0;
      }
    }
    else
    {
      this->collectTime = (TimeStamp*) asnBNULL;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_value) != asnFALSE)
    {
      value = object->value;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_GenericVehicleSignal__stringVal) != asnFALSE)
    {
      this->stringVal.__copy (object->stringVal);
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_GenericVehicleSignal__boolVal) != asnFALSE)
    {
      boolVal = object->boolVal;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_GenericVehicleSignal__timestampVal) != asnFALSE)
    {
      if(object->timestampVal != (TimeStamp *)asnBNULL)
      {
        timestampVal = (TimeStamp*)object->timestampVal->__create();
        timestampVal->__copy(*object->timestampVal);
      }
      else
      {
        timestampVal = (TimeStamp *) 0;
      }
    }
    else
    {
      this->timestampVal = (TimeStamp*) asnBNULL;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_GenericVehicleSignal__dataVal) != asnFALSE)
    {
      this->dataVal.__copy(object->dataVal);
    }
 }
}
/**
 *    TypeAssignment : EcuWarningMessages
 *    Class constructor
 */
EcuWarningMessages::EcuWarningMessages(const EcuWarningMessages& object)
  : asntype(),value(){
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : EcuWarningMessages
 * Copy method
 */
void EcuWarningMessages::__copy (const asntype& obj)
{
  const EcuWarningMessages* object = asnSCast(const EcuWarningMessages*,&obj);
  asncEcuWarningMessagess *elt_asncEcuWarningMessagess;
  elt_asncEcuWarningMessagess = (asncEcuWarningMessagess*) object->value.firstElement;
  for (asnMAXUINT countvalue=0; countvalue<object->value.count; countvalue++)
  {
    value.addElement(new asncEcuWarningMessagess(*elt_asncEcuWarningMessagess));
    elt_asncEcuWarningMessagess = (asncEcuWarningMessagess*) elt_asncEcuWarningMessagess->nextElement;
  }
}

/**
 *    TypeAssignment : ElectricVehicleStatus
 *    Class constructor
 */
ElectricVehicleStatus::ElectricVehicleStatus(const ElectricVehicleStatus& object)
  : asntype()  ,optional(object.optional.length, optionalField)
  ,isCharging()
  ,isPluggedIn()
  ,stateOfCharge()
  ,chargeLevel()
  ,timeToFullyCharged()
  ,statusOfChargerConnection()
  ,chargerState()
  ,distanceToEmptyOnBatteryOnly()
  ,ems48VSOC()
  ,emsHVRBSError()
  ,emsRBSModeDisplay()
  ,emsOVPActive()
  ,ems48vPackTemp1()
  ,ems48vPackTemp2()
  ,emsBMSLBuildSwVersion()
  ,emsCBRemainingLife()
  ,chargeHvSts()
  ,ptReady()
  ,averPowerConsumption()
  ,chargeSts()

{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : ElectricVehicleStatus
 * Copy method
 */
void ElectricVehicleStatus::__copy (const asntype& obj)
{
  const ElectricVehicleStatus* object = asnSCast(const ElectricVehicleStatus*,&obj);
  optionalField[0] = object->optionalField[0];
  optionalField[1] = object->optionalField[1];
 {
    if(asnGetPresence(object->optionalField,asn_isCharging) != asnFALSE)
    {
      isCharging = object->isCharging;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_isPluggedIn) != asnFALSE)
    {
      isPluggedIn = object->isPluggedIn;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_ElectricVehicleStatus__stateOfCharge) != asnFALSE)
    {
      stateOfCharge = object->stateOfCharge;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_ElectricVehicleStatus__chargeLevel) != asnFALSE)
    {
      chargeLevel = object->chargeLevel;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_timeToFullyCharged) != asnFALSE)
    {
      timeToFullyCharged = object->timeToFullyCharged;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_statusOfChargerConnection) != asnFALSE)
    {
      statusOfChargerConnection = object->statusOfChargerConnection;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_chargerState) != asnFALSE)
    {
      chargerState = object->chargerState;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_distanceToEmptyOnBatteryOnly) != asnFALSE)
    {
      distanceToEmptyOnBatteryOnly = object->distanceToEmptyOnBatteryOnly;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_ems48VSOC) != asnFALSE)
    {
      ems48VSOC = object->ems48VSOC;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_emsHVRBSError) != asnFALSE)
    {
      emsHVRBSError = object->emsHVRBSError;
    }
 }
 {
    emsRBSModeDisplay = object->emsRBSModeDisplay;
 }
 {
    emsOVPActive = object->emsOVPActive;
 }
 {
    ems48vPackTemp1 = object->ems48vPackTemp1;
 }
 {
    ems48vPackTemp2 = object->ems48vPackTemp2;
 }
 {
    if(asnGetPresence(object->optionalField,asn_emsBMSLBuildSwVersion) != asnFALSE)
    {
      this->emsBMSLBuildSwVersion.__copy (object->emsBMSLBuildSwVersion);
    }
 }
 {
    emsCBRemainingLife = object->emsCBRemainingLife;
 }
 {
    if(asnGetPresence(object->optionalField,asn_chargeHvSts) != asnFALSE)
    {
      chargeHvSts = object->chargeHvSts;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_ptReady) != asnFALSE)
    {
      ptReady = object->ptReady;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_averPowerConsumption) != asnFALSE)
    {
      averPowerConsumption = object->averPowerConsumption;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_chargeSts) != asnFALSE)
    {
      chargeSts = object->chargeSts;
    }
 }
}

/**
 *    TypeAssignment : GenericVehicleSignal
 *    Class constructor
 */
GenericVehicleSignal::GenericVehicleSignal(const GenericVehicleSignal& object)
  : asntype()  ,optional(object.optional.length, optionalField)
  ,key()
  ,collectTime()
  ,value()
  ,stringVal()
  ,boolVal()
  ,timestampVal()
  ,dataVal()

{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : GenericVehicleSignal
 * Copy method
 */
void GenericVehicleSignal::__copy (const asntype& obj)
{
  const GenericVehicleSignal* object = asnSCast(const GenericVehicleSignal*,&obj);
  optionalField[0] = object->optionalField[0];
 {
    this->key.__copy (object->key);
 }
 {
    if(asnGetPresence(object->optionalField,asn_collectTime) != asnFALSE)
    {
      if(object->collectTime != (TimeStamp *)asnBNULL)
      {
        collectTime = (TimeStamp*)object->collectTime->__create();
        collectTime->__copy(*object->collectTime);
      }
      else
      {
        collectTime = (TimeStamp *) 0;
      }
    }
    else
    {
      this->collectTime = (TimeStamp*) asnBNULL;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_value) != asnFALSE)
    {
      value = object->value;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_GenericVehicleSignal__stringVal) != asnFALSE)
    {
      this->stringVal.__copy (object->stringVal);
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_GenericVehicleSignal__boolVal) != asnFALSE)
    {
      boolVal = object->boolVal;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_GenericVehicleSignal__timestampVal) != asnFALSE)
    {
      if(object->timestampVal != (TimeStamp *)asnBNULL)
      {
        timestampVal = (TimeStamp*)object->timestampVal->__create();
        timestampVal->__copy(*object->timestampVal);
      }
      else
      {
        timestampVal = (TimeStamp *) 0;
      }
    }
    else
    {
      this->timestampVal = (TimeStamp*) asnBNULL;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_GenericVehicleSignal__dataVal) != asnFALSE)
    {
      this->dataVal.__copy(object->dataVal);
    }
 }
}

/**
 *    TypeAssignment : MaintenanceStatus
 *    Class constructor
 */
MaintenanceStatus::MaintenanceStatus(const MaintenanceStatus& object)
  : asntype()  ,optional(object.optional.length, optionalField)
  ,mainBatteryStatus()
  ,tyreStatusDriver()
  ,tyreStatusPassenger()
  ,tyreStatusDriverRear()
  ,tyreStatusPassengerRear()
  ,tyrePreWarningDriver()
  ,tyrePreWarningPassenger()
  ,tyrePreWarningDriverRear()
  ,tyrePreWarningPassengerRear()
  ,engineHrsToService()
  ,distanceToService()
  ,daysToService()
  ,serviceWarningStatus()
  ,serviceWarningTrigger()
  ,odometer()
  ,brakeFluidLevelStatus()
  ,washerFluidLevelStatus()

{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : MaintenanceStatus
 * Copy method
 */
void MaintenanceStatus::__copy (const asntype& obj)
{
  const MaintenanceStatus* object = asnSCast(const MaintenanceStatus*,&obj);
  optionalField[0] = object->optionalField[0];
  optionalField[1] = object->optionalField[1];
  optionalField[2] = object->optionalField[2];
 {
    if(asnGetPresence(object->optionalField,asn_mainBatteryStatus) != asnFALSE)
    {
      if(object->mainBatteryStatus != (BatteryStatus *)asnBNULL)
      {
        mainBatteryStatus = (BatteryStatus*)object->mainBatteryStatus->__create();
        mainBatteryStatus->__copy(*object->mainBatteryStatus);
      }
      else
      {
        mainBatteryStatus = (BatteryStatus *) 0;
      }
    }
    else
    {
      this->mainBatteryStatus = (BatteryStatus*) asnBNULL;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_tyreStatusDriver) != asnFALSE)
    {
      tyreStatusDriver = object->tyreStatusDriver;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_tyreStatusPassenger) != asnFALSE)
    {
      tyreStatusPassenger = object->tyreStatusPassenger;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_tyreStatusDriverRear) != asnFALSE)
    {
      tyreStatusDriverRear = object->tyreStatusDriverRear;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_tyreStatusPassengerRear) != asnFALSE)
    {
      tyreStatusPassengerRear = object->tyreStatusPassengerRear;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_tyrePreWarningDriver) != asnFALSE)
    {
      tyrePreWarningDriver = object->tyrePreWarningDriver;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_tyrePreWarningPassenger) != asnFALSE)
    {
      tyrePreWarningPassenger = object->tyrePreWarningPassenger;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_tyrePreWarningDriverRear) != asnFALSE)
    {
      tyrePreWarningDriverRear = object->tyrePreWarningDriverRear;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_tyrePreWarningPassengerRear) != asnFALSE)
    {
      tyrePreWarningPassengerRear = object->tyrePreWarningPassengerRear;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_engineHrsToService) != asnFALSE)
    {
      engineHrsToService = object->engineHrsToService;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_distanceToService) != asnFALSE)
    {
      distanceToService = object->distanceToService;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_daysToService) != asnFALSE)
    {
      daysToService = object->daysToService;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_serviceWarningStatus) != asnFALSE)
    {
      serviceWarningStatus = object->serviceWarningStatus;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_serviceWarningTrigger) != asnFALSE)
    {
      serviceWarningTrigger = object->serviceWarningTrigger;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_MaintenanceStatus__odometer) != asnFALSE)
    {
      odometer = object->odometer;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_brakeFluidLevelStatus) != asnFALSE)
    {
      brakeFluidLevelStatus = object->brakeFluidLevelStatus;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_washerFluidLevelStatus) != asnFALSE)
    {
      washerFluidLevelStatus = object->washerFluidLevelStatus;
    }
 }
}

/**
 *    TypeAssignment : NetworkAccessStatus
 *    Class constructor
 */
NetworkAccessStatus::NetworkAccessStatus(const NetworkAccessStatus& object)
  : asntype()  ,optional(object.optional.length, optionalField)
  ,simInfo()
  ,mobileNetwork()

{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : NetworkAccessStatus
 * Copy method
 */
void NetworkAccessStatus::__copy (const asntype& obj)
{
  const NetworkAccessStatus* object = asnSCast(const NetworkAccessStatus*,&obj);
  optionalField[0] = object->optionalField[0];
 {
    if(asnGetPresence(object->optionalField,asn_simInfo) != asnFALSE)
    {
      if(object->simInfo != (SIMInfo *)asnBNULL)
      {
        simInfo = (SIMInfo*)object->simInfo->__create();
        simInfo->__copy(*object->simInfo);
      }
      else
      {
        simInfo = (SIMInfo *) 0;
      }
    }
    else
    {
      this->simInfo = (SIMInfo*) asnBNULL;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_mobileNetwork) != asnFALSE)
    {
      this->mobileNetwork.__copy (object->mobileNetwork);
    }
 }
}

/**
 *    TypeAssignment : OEMMSD
 *    Class constructor
 */
OEMMSD::OEMMSD(const OEMMSD& object)
  : asntype()  ,optional(object.optional.length, optionalField)
  ,automaticActivation()
  ,testCall()
  ,position()
  ,vehicleType()
  ,vin()
  ,fuelType()
  ,direction()
  ,numberOfPassengers()
  ,recentPositions()
  ,speed()
  ,speedValidity()
  ,signals()

{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : OEMMSD
 * Copy method
 */
void OEMMSD::__copy (const asntype& obj)
{
  const OEMMSD* object = asnSCast(const OEMMSD*,&obj);
  optionalField[0] = object->optionalField[0];
 {
    automaticActivation = object->automaticActivation;
 }
 {
    testCall = object->testCall;
 }
 {
    if(object->position != (Position *)asnBNULL)
    {
      position = (Position*)object->position->__create();
      position->__copy(*object->position);
    }
    else
    {
      position = (Position *) 0;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_vehicleType) != asnFALSE)
    {
      vehicleType = object->vehicleType;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_OEMMSD__vin) != asnFALSE)
    {
      this->vin.__copy (object->vin);
    }
 }
 {
    fuelType = object->fuelType;
 }
 {
    direction = object->direction;
 }
 {
    if(asnGetPresence(object->optionalField,asn_numberOfPassengers) != asnFALSE)
    {
      numberOfPassengers = object->numberOfPassengers;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_recentPositions) != asnFALSE)
    {
      asncrecentPositionss *elt_asncrecentPositionss;
      elt_asncrecentPositionss = (asncrecentPositionss*) object->recentPositions.firstElement;
      for (asnMAXUINT countrecentPositions=0; countrecentPositions<object->recentPositions.count; countrecentPositions++)
      {
        recentPositions.addElement(new asncrecentPositionss(*elt_asncrecentPositionss));
        elt_asncrecentPositionss = (asncrecentPositionss*) elt_asncrecentPositionss->nextElement;
      }
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_speed) != asnFALSE)
    {
      speed = object->speed;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_OEMMSD__speedValidity) != asnFALSE)
    {
      speedValidity = object->speedValidity;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_OEMMSD__signals) != asnFALSE)
    {
      asncOEMMSD__signalss *elt_asncOEMMSD__signalss;
      elt_asncOEMMSD__signalss = (asncOEMMSD__signalss*) object->signals.firstElement;
      for (asnMAXUINT countsignals=0; countsignals<object->signals.count; countsignals++)
      {
        signals.addElement(new asncOEMMSD__signalss(*elt_asncOEMMSD__signalss));
        elt_asncOEMMSD__signalss = (asncOEMMSD__signalss*) elt_asncOEMMSD__signalss->nextElement;
      }
    }
 }
}

/**
 *    TypeAssignment : PollutionStatus
 *    Class constructor
 */
PollutionStatus::PollutionStatus(const PollutionStatus& object)
  : asntype()  ,optional(object.optional.length, optionalField)
  ,interiorPM25()
  ,exteriorPM25()

{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : PollutionStatus
 * Copy method
 */
void PollutionStatus::__copy (const asntype& obj)
{
  const PollutionStatus* object = asnSCast(const PollutionStatus*,&obj);
  optionalField[0] = object->optionalField[0];
 {
    if(asnGetPresence(object->optionalField,asn_interiorPM25) != asnFALSE)
    {
      interiorPM25 = object->interiorPM25;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_exteriorPM25) != asnFALSE)
    {
      exteriorPM25 = object->exteriorPM25;
    }
 }
}

/**
 *    TypeAssignment : RunningStatus
 *    Class constructor
 */
RunningStatus::RunningStatus(const RunningStatus& object)
  : asntype()  ,optional(object.optional.length, optionalField)
  ,engineOilLevelStatus()
  ,engineOilTemperature()
  ,engineOilPressureWarning()
  ,engineCoolantTemperature()
  ,engineCoolantTemperatureValidity()
  ,engineCoolantLevelStatus()
  ,fuelLevel()
  ,fuelLevelStatus()
  ,aveFuelConsumption()
  ,aveFuelConsumptionInLatestDrivingCycle()
  ,avgSpeed()
  ,tripMeter1()
  ,tripMeter2()
  ,bulbStatus()

{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : RunningStatus
 * Copy method
 */
void RunningStatus::__copy (const asntype& obj)
{
  const RunningStatus* object = asnSCast(const RunningStatus*,&obj);
  optionalField[0] = object->optionalField[0];
  optionalField[1] = object->optionalField[1];
 {
    if(asnGetPresence(object->optionalField,asn_engineOilLevelStatus) != asnFALSE)
    {
      engineOilLevelStatus = object->engineOilLevelStatus;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_engineOilTemperature) != asnFALSE)
    {
      engineOilTemperature = object->engineOilTemperature;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_engineOilPressureWarning) != asnFALSE)
    {
      engineOilPressureWarning = object->engineOilPressureWarning;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_engineCoolantTemperature) != asnFALSE)
    {
      engineCoolantTemperature = object->engineCoolantTemperature;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_engineCoolantTemperatureValidity) != asnFALSE)
    {
      engineCoolantTemperatureValidity = object->engineCoolantTemperatureValidity;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_engineCoolantLevelStatus) != asnFALSE)
    {
      engineCoolantLevelStatus = object->engineCoolantLevelStatus;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_fuelLevel) != asnFALSE)
    {
      fuelLevel = object->fuelLevel;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_fuelLevelStatus) != asnFALSE)
    {
      fuelLevelStatus = object->fuelLevelStatus;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_aveFuelConsumption) != asnFALSE)
    {
      aveFuelConsumption = object->aveFuelConsumption;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_aveFuelConsumptionInLatestDrivingCycle) != asnFALSE)
    {
      aveFuelConsumptionInLatestDrivingCycle = object->aveFuelConsumptionInLatestDrivingCycle;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_avgSpeed) != asnFALSE)
    {
      avgSpeed = object->avgSpeed;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_tripMeter1) != asnFALSE)
    {
      tripMeter1 = object->tripMeter1;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_tripMeter2) != asnFALSE)
    {
      tripMeter2 = object->tripMeter2;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_bulbStatus) != asnFALSE)
    {
      bulbStatus = object->bulbStatus;
    }
 }
}

/**
 *    TypeAssignment : SIMInfo
 *    Class constructor
 */
SIMInfo::SIMInfo(const SIMInfo& object)
  : asntype()  ,optional(object.optional.length, optionalField)
  ,msisdn()
  ,imsi()
  ,iccId()

{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : SIMInfo
 * Copy method
 */
void SIMInfo::__copy (const asntype& obj)
{
  const SIMInfo* object = asnSCast(const SIMInfo*,&obj);
  optionalField[0] = object->optionalField[0];
 {
    if(asnGetPresence(object->optionalField,asn_msisdn) != asnFALSE)
    {
      this->msisdn.__copy (object->msisdn);
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_imsi) != asnFALSE)
    {
      this->imsi.__copy (object->imsi);
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_iccId) != asnFALSE)
    {
      this->iccId.__copy (object->iccId);
    }
 }
}

/**
 *    TypeAssignment : TEMStatus
 *    Class constructor
 */
TEMStatus::TEMStatus(const TEMStatus& object)
  : asntype()  ,optional(object.optional.length, optionalField)
  ,vin()
  ,powerSource()
  ,backupBattery()
  ,powerMode()
  ,sleepCycleNextWakeupTime()
  ,serviceProvisoned()
  ,healthStatus()
  ,diagnostics()
  ,networkAccessStatus()
  ,serialNumber()
  ,completeECUPartNumbers()
  ,imei()
  ,hwVersion()
  ,swVersion()
  ,mpuVersion()
  ,mcuVersion()

{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : TEMStatus
 * Copy method
 */
void TEMStatus::__copy (const asntype& obj)
{
  const TEMStatus* object = asnSCast(const TEMStatus*,&obj);
  optionalField[0] = object->optionalField[0];
  optionalField[1] = object->optionalField[1];
 {
    if(asnGetPresence(object->optionalField,asn_TEMStatus__vin) != asnFALSE)
    {
      this->vin.__copy (object->vin);
    }
 }
 {
    powerSource = object->powerSource;
 }
 {
    if(asnGetPresence(object->optionalField,asn_TEMStatus__backupBattery) != asnFALSE)
    {
      if(object->backupBattery != (BatteryStatus *)asnBNULL)
      {
        backupBattery = (BatteryStatus*)object->backupBattery->__create();
        backupBattery->__copy(*object->backupBattery);
      }
      else
      {
        backupBattery = (BatteryStatus *) 0;
      }
    }
    else
    {
      this->backupBattery = (BatteryStatus*) asnBNULL;
    }
 }
 {
    powerMode = object->powerMode;
 }
 {
    if(asnGetPresence(object->optionalField,asn_sleepCycleNextWakeupTime) != asnFALSE)
    {
      if(object->sleepCycleNextWakeupTime != (TimeStamp *)asnBNULL)
      {
        sleepCycleNextWakeupTime = (TimeStamp*)object->sleepCycleNextWakeupTime->__create();
        sleepCycleNextWakeupTime->__copy(*object->sleepCycleNextWakeupTime);
      }
      else
      {
        sleepCycleNextWakeupTime = (TimeStamp *) 0;
      }
    }
    else
    {
      this->sleepCycleNextWakeupTime = (TimeStamp*) asnBNULL;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_serviceProvisoned) != asnFALSE)
    {
      serviceProvisoned = object->serviceProvisoned;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_healthStatus) != asnFALSE)
    {
      healthStatus = object->healthStatus;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_TEMStatus__diagnostics) != asnFALSE)
    {
      if(object->diagnostics != (ECUDiagnostic *)asnBNULL)
      {
        diagnostics = (ECUDiagnostic*)object->diagnostics->__create();
        diagnostics->__copy(*object->diagnostics);
      }
      else
      {
        diagnostics = (ECUDiagnostic *) 0;
      }
    }
    else
    {
      this->diagnostics = (ECUDiagnostic*) asnBNULL;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_networkAccessStatus) != asnFALSE)
    {
      if(object->networkAccessStatus != (NetworkAccessStatus *)asnBNULL)
      {
        networkAccessStatus = (NetworkAccessStatus*)object->networkAccessStatus->__create();
        networkAccessStatus->__copy(*object->networkAccessStatus);
      }
      else
      {
        networkAccessStatus = (NetworkAccessStatus *) 0;
      }
    }
    else
    {
      this->networkAccessStatus = (NetworkAccessStatus*) asnBNULL;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_serialNumber) != asnFALSE)
    {
      this->serialNumber.__copy (object->serialNumber);
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_completeECUPartNumbers) != asnFALSE)
    {
      this->completeECUPartNumbers.__copy (object->completeECUPartNumbers);
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_imei) != asnFALSE)
    {
      this->imei.__copy (object->imei);
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_hwVersion) != asnFALSE)
    {
      this->hwVersion.__copy (object->hwVersion);
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_TEMStatus__swVersion) != asnFALSE)
    {
      this->swVersion.__copy (object->swVersion);
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_mpuVersion) != asnFALSE)
    {
      this->mpuVersion.__copy (object->mpuVersion);
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_mcuVersion) != asnFALSE)
    {
      this->mcuVersion.__copy (object->mcuVersion);
    }
 }
}

/**
 *    TypeAssignment : TheftNotification
 *    Class constructor
 */
TheftNotification::TheftNotification(const TheftNotification& object)
  : asntype()  ,time()
  ,activated()

{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : TheftNotification
 * Copy method
 */
void TheftNotification::__copy (const asntype& obj)
{
  const TheftNotification* object = asnSCast(const TheftNotification*,&obj);
 {
    if(object->time != (TimeStamp *)asnBNULL)
    {
      time = (TimeStamp*)object->time->__create();
      time->__copy(*object->time);
    }
    else
    {
      time = (TimeStamp *) 0;
    }
 }
 {
    activated = object->activated;
 }
}

/**
 *    TypeAssignment : VehicleStatus
 *    Class constructor
 */
VehicleStatus::VehicleStatus(const VehicleStatus& object)
  : asntype()  ,optional(object.optional.length, optionalField)
  ,basicVehicleStatus()
  ,additionalVehicleStatus()
  ,msd()
  ,temStatus()
  ,diagnostics()
  ,theftNotification()
  ,notification()

{
  __copy(object);
}
/**
 * RUNTIME PRIVATE METHOD. ACCESS TO THIS METHOD IS FORBIDDEN TO THE USER.
 * TypeAssignment : VehicleStatus
 * Copy method
 */
void VehicleStatus::__copy (const asntype& obj)
{
  const VehicleStatus* object = asnSCast(const VehicleStatus*,&obj);
  optionalField[0] = object->optionalField[0];
 {
    if(asnGetPresence(object->optionalField,asn_basicVehicleStatus) != asnFALSE)
    {
      if(object->basicVehicleStatus != (BasicVehicleStatus *)asnBNULL)
      {
        basicVehicleStatus = (BasicVehicleStatus*)object->basicVehicleStatus->__create();
        basicVehicleStatus->__copy(*object->basicVehicleStatus);
      }
      else
      {
        basicVehicleStatus = (BasicVehicleStatus *) 0;
      }
    }
    else
    {
      this->basicVehicleStatus = (BasicVehicleStatus*) asnBNULL;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_additionalVehicleStatus) != asnFALSE)
    {
      if(object->additionalVehicleStatus != (AdditionalVehicleStatus *)asnBNULL)
      {
        additionalVehicleStatus = (AdditionalVehicleStatus*)object->additionalVehicleStatus->__create();
        additionalVehicleStatus->__copy(*object->additionalVehicleStatus);
      }
      else
      {
        additionalVehicleStatus = (AdditionalVehicleStatus *) 0;
      }
    }
    else
    {
      this->additionalVehicleStatus = (AdditionalVehicleStatus*) asnBNULL;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_msd) != asnFALSE)
    {
      if(object->msd != (OEMMSD *)asnBNULL)
      {
        msd = (OEMMSD*)object->msd->__create();
        msd->__copy(*object->msd);
      }
      else
      {
        msd = (OEMMSD *) 0;
      }
    }
    else
    {
      this->msd = (OEMMSD*) asnBNULL;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_temStatus) != asnFALSE)
    {
      if(object->temStatus != (TEMStatus *)asnBNULL)
      {
        temStatus = (TEMStatus*)object->temStatus->__create();
        temStatus->__copy(*object->temStatus);
      }
      else
      {
        temStatus = (TEMStatus *) 0;
      }
    }
    else
    {
      this->temStatus = (TEMStatus*) asnBNULL;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_VehicleStatus__diagnostics) != asnFALSE)
    {
      asncECUDiagnosticss *elt_asncECUDiagnosticss;
      elt_asncECUDiagnosticss = (asncECUDiagnosticss*) object->diagnostics.firstElement;
      for (asnMAXUINT countdiagnostics=0; countdiagnostics<object->diagnostics.count; countdiagnostics++)
      {
        diagnostics.addElement(new asncECUDiagnosticss(*elt_asncECUDiagnosticss));
        elt_asncECUDiagnosticss = (asncECUDiagnosticss*) elt_asncECUDiagnosticss->nextElement;
      }
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_theftNotification) != asnFALSE)
    {
      if(object->theftNotification != (TheftNotification *)asnBNULL)
      {
        theftNotification = (TheftNotification*)object->theftNotification->__create();
        theftNotification->__copy(*object->theftNotification);
      }
      else
      {
        theftNotification = (TheftNotification *) 0;
      }
    }
    else
    {
      this->theftNotification = (TheftNotification*) asnBNULL;
    }
 }
 {
    if(asnGetPresence(object->optionalField,asn_notification) != asnFALSE)
    {
      if(object->notification != (Notification *)asnBNULL)
      {
        notification = (Notification*)object->notification->__create();
        notification->__copy(*object->notification);
      }
      else
      {
        notification = (Notification *) 0;
      }
    }
    else
    {
      this->notification = (Notification*) asnBNULL;
    }
 }
}

#endif // asnCodCopytor
