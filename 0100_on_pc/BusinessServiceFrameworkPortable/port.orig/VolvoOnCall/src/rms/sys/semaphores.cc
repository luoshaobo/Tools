////////////////////////////////////////////////////////////////////////////
// Copyright (C) 2018 Continental Automotive GmbH
// Unless required by applicable law or agreed to in writing, // software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//  @file semaphores.h
//  This file handles the communication with the VuC, using the OTP VCS-interface
 
// @project     GLY_TCAM
// @subsystem   VolvoOnCall
// @author      Jiaojiao Shen
// @Init date   12-Sep-2018
////////////////////////////////////////////////////////////////////////////

#include <rms/sys/semaphores.h>

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//! \fn Semaphores::Semaphores(const int32_t locks)
//! \brief The constructor for the Semaphores class
//! \param[in] locks Maximum number of locks or concurrent readers
//! \return void
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
Semaphores::Semaphores(const int32_t locks):
        mLocks(locks), mLocksMax(locks) {
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//! \fn Semaphores::~Semaphores()
//! \brief The destructor for the Semaphores class
//! \return void
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
Semaphores::~Semaphores() {
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//! \fn Semaphores::lockRead()
//! \brief Function to acquire single lock(right to read)
//! \return void
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void Semaphores::lockRead() {
    boost::unique_lock<boost::mutex> lock(mMutex);
    mCv.wait(lock, Pred(mLocks, 0));
    mLocks--;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//! \fn Semaphores::unlockRead()
//! \brief Function to free single lock(right to read)
//! \return void
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void Semaphores::unlockRead() {
    boost::unique_lock<boost::mutex> lock(mMutex);
    if (mLocks < mLocksMax) {
        mLocks++;
    }
    lock.unlock();
    mCv.notify_all();
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//! \fn Semaphores::lockWrite()
//! \brief Function to acquire all locks and ensure exclusive access(right to write)
//! \return void
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void Semaphores::lockWrite() {
    boost::unique_lock<boost::mutex> lock(mMutex);
    if(0 >= mLocks)
    {
        mCv.wait(lock, Pred(mLocks, 0));
    }
    mLocks = mLocks-mLocksMax;
    mCv.wait(lock, Pred(mLocks, -1));
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//! \fn Semaphores::unlockWrite()
//! \brief Function to free all locks(right to write)
//! \return void
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void Semaphores::unlockWrite() {
    boost::unique_lock<boost::mutex> lock(mMutex);
    mLocks = mLocksMax;
    lock.unlock();
    mCv.notify_all();
}
